# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/candle.rb
class Candle
  attr_reader :timestamp, :open, :high, :low, :close, :volume

  def initialize(ts:, open:, high:, low:, close:, volume:)
    @timestamp = ts
    @open = open.to_f
    @high = high.to_f
    @low = low.to_f
    @close = close.to_f
    @volume = volume.to_i
  end

  def bullish? = close >= open
  def bearish? = close < open
end

# File: app/models/candle_series.rb
class CandleSeries
  include Enumerable

  attr_reader :symbol, :interval, :candles

  def initialize(symbol:, interval: '5')
    @symbol = symbol
    @interval = interval
    @candles = []
  end

  def each(&) = candles.each(&)
  def add_candle(candle) = candles << candle

  def load_from_raw(response)
    normalise_candles(response).each do |row|
      @candles << Candle.new(
        ts: Time.zone.parse(row[:timestamp].to_s),
        open: row[:open], high: row[:high],
        low: row[:low], close: row[:close],
        volume: row[:volume]
      )
    end
  end

  def normalise_candles(resp)
    return [] if resp.blank?

    return resp.map { |c| slice_candle(c) } if resp.is_a?(Array)

    raise "Unexpected candle format: #{resp.class}" unless resp.is_a?(Hash) && resp['high'].is_a?(Array)

    size = resp['high'].size
    (0...size).map do |i|
      {
        open: resp['open'][i].to_f,
        close: resp['close'][i].to_f,
        high: resp['high'][i].to_f,
        low: resp['low'][i].to_f,
        timestamp: Time.zone.at(resp['timestamp'][i]),
        volume: resp['volume'][i].to_i
      }
    end
  end

  def opens  = candles.map(&:open)
  def closes = candles.map(&:close)
  def highs  = candles.map(&:high)
  def lows   = candles.map(&:low)

  def hlc
    candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        high: c.high,
        low: c.low,
        close: c.close
      }
    end
  end

  def atr(period = 14)
    TechnicalAnalysis::Atr.calculate(hlc, period: period).first.atr
  end

  def swing_high?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].high
    left = candles[(index - lookback)...index].map(&:high)
    right = candles[(index + 1)..(index + lookback)].map(&:high)
    current > left.max && current > right.max
  end

  def swing_low?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].low
    left = candles[(index - lookback)...index].map(&:low)
    right = candles[(index + 1)..(index + lookback)].map(&:low)
    current < left.min && current < right.min
  end

  def recent_highs(n = 20)
    candles.last(n).map(&:high)
  end

  def recent_lows(n = 20)
    candles.last(n).map(&:low)
  end

  def previous_swing_high
    recent_highs.sort[-2] # 2nd highest
  end

  def previous_swing_low
    recent_lows.sort[1]   # 2nd lowest
  end

  def liquidity_grab_up?(lookback: 20)
    high_now = candles.last.high
    high_prev = previous_swing_high

    high_now > high_prev &&
      candles.last.close < high_prev && # Rejection after breakout
      candles.last.bearish?
  end

  def liquidity_grab_down?(lookback: 20)
    low_now = candles.last.low
    low_prev = previous_swing_low

    low_now < low_prev &&
      candles.last.close > low_prev && # Rejection after breakdown
      candles.last.bullish?
  end

  def rsi(period = 14)
    RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: closes, period: period).call
  end

  def moving_average(period = 20)
    RubyTechnicalAnalysis::MovingAverages.new(series: closes, period: period)
  end

  def sma(period = 20)
    moving_average(period).sma
  end

  def ema(period = 20)
    moving_average(period).ema
  end

  def macd(fast_period = 12, slow_period = 26, signal_period = 9)
    macd = RubyTechnicalAnalysis::Macd.new(series: closes, fast_period: fast_period, slow_period: slow_period, signal_period: signal_period)
    macd.call
  end

  def rate_of_change(period = 5)
    closes = self.closes
    return nil if closes.size < period + 1

    # ((current_close - close_n_periods_ago) / close_n_periods_ago) * 100
    roc_series = []
    closes.each_with_index do |price, idx|
      if idx < period
        roc_series << nil # not enough data for these initial points
      else
        previous_price = closes[idx - period]
        roc_series << (((price - previous_price) / previous_price.to_f) * 100.0)
      end
    end
    roc_series
  end

  def supertrend_signal
    trend_line = Indicators::Supertrend.new(series: self).call
    return nil if trend_line.empty?

    latest_close = closes.last
    latest_trend = trend_line.last

    return :long_entry if latest_close > latest_trend

    :short_entry if latest_close < latest_trend
  end

  def inside_bar?(i)
    return false if i < 1

    curr = @candles[i]
    prev = @candles[i - 1]
    curr.high < prev.high && curr.low > prev.low
  end

  def bollinger_bands(period: 20)
    return nil if candles.size < period

    bb = RubyTechnicalAnalysis::BollingerBands.new(
      series: closes,
      period: period
    ).call

    { upper: bb[0], lower: bb[1], middle: bb[2] }
  end

  def donchian_channel(period: 20)
    return nil if candles.size < period

    dc = candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        value: c.close
      }
    end
    TechnicalAnalysis::Dc.calculate(dc, period: period)
  end
end

# File: app/models/concerns/candle_extension.rb
# Extend Instrument with candle series integration
module CandleExtension
  extend ActiveSupport::Concern

  included do
    def candles(interval: '5')
      raw_data = intraday_ohlc(interval: interval)
      return nil unless raw_data

      series = CandleSeries.new(symbol: symbol_name, interval: interval)
      series.load_from_raw(raw_data)
      series
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end

    def rsi(period = 14, interval: '5')
      cs = candles(interval: interval)
      cs&.rsi(period)
    end

    def macd(fast_period = 12, slow_period = 26, signal_period = 9, interval: '5')
      cs = candles(interval: interval)
      macd_result = cs&.macd(fast_period, slow_period, signal_period)
      return nil unless macd_result

      {
        macd: macd_result[0],
        signal: macd_result[1],
        histogram: macd_result[2]
      }
    end

    def adx(period = 14, interval: '5')
      cs = candles(interval: interval)
      closes = cs&.closes
      highs  = cs&.highs
      lows   = cs&.lows
      return nil unless closes && highs && lows

      hlc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end

      ta_adx = TechnicalAnalysis::Adx.calculate(hlc, period: period).first
      ta_adx&.adx
    end

    def supertrend_signal(interval: '5')
      cs = candles(interval: interval)
      cs&.supertrend_signal
    end

    def liquidity_grab_up?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_up?
    end

    def liquidity_grab_down?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_down?
    end

    def bollinger_bands(period: 20, interval: '5')
      cs = candles(interval: interval)
      return nil unless cs

      cs.bollinger_bands(period: period)
    end

    def donchian_channel(period: 20, interval: '5')
      cs = candles(interval: interval)

      dc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          value: c.close
        }
      end
      TechnicalAnalysis::Dc.calculate(dc, period: period)
    end

    def obv(interval: '5')
      dcv = candles(interval: interval).candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          close: c.close,
          volume: c.volume || 0
        }
      end

      TechnicalAnalysis::Obv.calculate(dcv)
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end
  end
end


# File: app/models/concerns/instrument_helpers.rb
module InstrumentHelpers
  extend ActiveSupport::Concern
  include CandleExtension

  included do
    # Enums common to Instrument and Derivative
    enum :exchange, { nse: 'NSE', bse: 'BSE', mcx: 'MCX' }
    enum :segment, { index: 'I', equity: 'E', currency: 'C', derivatives: 'D', commodity: 'M' }, prefix: true
    enum :instrument_code, {
      index: 'INDEX',
      futures_index: 'FUTIDX',
      options_index: 'OPTIDX',
      equity: 'EQUITY',
      futures_stock: 'FUTSTK',
      options_stock: 'OPTSTK',
      futures_currency: 'FUTCUR',
      options_currency: 'OPTCUR',
      futures_commodity: 'FUTCOM',
      options_commodity: 'OPTFUT'
    }, prefix: true

    scope :nse, -> { where(exchange: 'NSE') }
    scope :bse, -> { where(exchange: 'BSE') }

    # Validations for enums can also go here, if common
  end

  # Shared instance methods for market data fetching and helpers
  def ltp
    fetch_ltp_from_api
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def quote_ltp
    quote = quotes.order(tick_time: :desc).first
    return nil unless quote

    quote.ltp.to_f
  rescue StandardError => e
    Rails.logger.error("Failed to fetch latest quote LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def fetch_ltp_from_api
    response = DhanHQ::Models::MarketFeed.ltp(exch_segment_enum)
    response.dig('data', exchange_segment, security_id.to_s, 'last_price') if response['status'] == 'success'
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP from API for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def ohlc
    response = DhanHQ::Models::MarketFeed.ohlc(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def historical_ohlc(from_date: nil, to_date: nil, oi: false)
    DhanHQ::Models::HistoricalData.daily(
      securityId: security_id,
      exchangeSegment: exchange_segment,
      instrument: instrument_type,
      oi: oi,
      fromDate: from_date || (Time.zone.today - 365).to_s,
      toDate: to_date || (Time.zone.today - 1).to_s,
      expiryCode: 0
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Historical OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def intraday_ohlc(interval: '5', oi: false, from_date: nil, to_date: nil)
    to_date ||= MarketCalendar.today_or_last_trading_day.to_s
    from_date ||= (Date.parse(to_date) - 5).to_s # fetch last 5 sessions by default

    DhanHQ::Models::HistoricalData.intraday(
      security_id: security_id,
      exchange_segment: exchange_segment,
      instrument: instrument_type,
      interval: interval,
      oi: oi,
      from_date: from_date || (Time.zone.today - 90).to_s,
      to_date: to_date || (Time.zone.today - 1).to_s
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Intraday OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def depth
    response = DhanHQ::Models::MarketFeed.quote(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  # Helper method: dynamic exchange_segment string for API calls
  def exchange_segment
    case [exchange.to_sym, segment.to_sym]
    when %i[nse index], %i[bse index] then 'IDX_I'
    when %i[nse equity] then 'NSE_EQ'
    when %i[bse equity] then 'BSE_EQ'
    when %i[nse derivatives] then 'NSE_FNO'
    when %i[bse derivatives] then 'BSE_FNO'
    when %i[nse currency] then 'NSE_CURRENCY'
    when %i[bse currency] then 'BSE_CURRENCY'
    when %i[mcx commodity] then 'MCX_COMM'
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  private

  def exch_segment_enum
    { exchange_segment => [security_id.to_i] }
  end

  def numeric_value?(value)
    value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
  end
end

# File: app/models/concerns/instrument_type_mapping.rb
# frozen_string_literal: true

module InstrumentTypeMapping
  # ------------------------------------------------------------------
  # Parent → child mapping straight from Dhan CSV spec
  # ------------------------------------------------------------------
  PARENT_TO_CHILDREN = {
    'INDEX' => %w[FUTIDX OPTIDX],
    'EQUITY' => %w[FUTSTK OPTSTK],
    # Commodity & Currency don’t have their own high-level codes in CSV,
    # so we treat the futures variant itself as “parent”.
    'FUTCOM' => %w[OPTFUT],
    'FUTCUR' => %w[OPTCUR]
  }.freeze

  # ------------------------------------------------------------------
  # Child → parent lookup (built from the hash above)
  # ------------------------------------------------------------------
  CHILD_TO_PARENT =
    PARENT_TO_CHILDREN.flat_map { |parent, kids| kids.map { |kid| [kid, parent] } }
                      .to_h
                      .freeze

  # --------------------------------------------------
  # Public helpers
  # --------------------------------------------------

  # Given *any* code, return its underlying parent.
  #   underlying_for("FUTIDX")  => "INDEX"
  #   underlying_for("INDEX")   => "INDEX"
  def self.underlying_for(code)
    CHILD_TO_PARENT[code] || code
  end

  # Given an underlying parent, return all derivative codes
  #   derivative_codes_for("INDEX") => ["FUTIDX","OPTIDX"]
  def self.derivative_codes_for(parent_code)
    PARENT_TO_CHILDREN[parent_code] || []
  end

  # Convenience lists
  def self.all_parents  = PARENT_TO_CHILDREN.keys
  def self.all_children = CHILD_TO_PARENT.keys
end


# File: app/models/derivative.rb
class Derivative < ApplicationRecord
  include InstrumentHelpers

  belongs_to :instrument

  scope :options, -> { where.not(option_type: [nil, '']) }
  scope :futures, -> { where(option_type: [nil, '']) }
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  include InstrumentHelpers

  has_many :derivatives, dependent: :destroy

  accepts_nested_attributes_for :derivatives, allow_destroy: true

  # API Methods
  def fetch_option_chain(expiry = nil)
    expiry ||= expiry_list.first
    data = DhanHQ::Models::OptionChain.fetch(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment,
      expiry: expiry
    )
    return nil unless data

    filtered_data = filter_option_chain_data(data)

    { last_price: data['last_price'], oc: filtered_data }
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{security_id}: #{e.message}")
    nil
  end

  def filter_option_chain_data(data)
    data['oc'].select do |_strike, option_data|
      call_data = option_data['ce']
      put_data = option_data['pe']

      has_call_values = call_data && call_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end
      has_put_values = put_data && put_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end

      has_call_values || has_put_values
    end
  end

  def expiry_list
    DhanHQ::Models::OptionChain.fetch_expiry_list(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment
    )
  end
end


# File: app/services/algo_runner.rb
class AlgoRunner
  def self.execute_all
    Instrument.watchlist.find_each do |inst|
      result = Strategies::BasicTrendStrategy.call(inst)
      case result
      when :buy_ce
        Execution::OrderExecutor.buy_option_ce(inst)
      end
    end
  end
end

# File: app/services/analysis/options_behaviour_analyzer.rb
module Analysis
  class OptionsBehaviourAnalyzer < ApplicationService
    def initialize(option_chain:, expiry:, underlying_spot:, symbol:, historical: [])
      @chain = option_chain.with_indifferent_access
      @expiry = expiry
      @spot = underlying_spot
      @symbol = symbol
      @historical = historical
    end

    def call
      atm = determine_atm
      return nil unless atm

      analysis = {
        symbol: @symbol,
        expiry: @expiry,
        spot: @spot,
        atm: atm,
        ce: extract_behaviour_data(atm, :ce),
        pe: extract_behaviour_data(atm, :pe),
        time: Time.zone.now
      }

      notify("🧠 Behaviour Data Prepared for #{@symbol}\n\n#{analysis.inspect.truncate(1200)}", tag: 'OPTIONS_BEHAVIOUR')

      analysis
    end

    private

    def determine_atm
      @chain[:oc].keys.map(&:to_f).min_by { |s| (@spot - s).abs }
    end

    def extract_behaviour_data(strike, side)
      data = @chain[:oc][format('%.6f', strike)][side.to_s]
      return {} unless data

      {
        last_price: data['last_price'],
        iv: data['implied_volatility'],
        delta: data.dig('greeks', 'delta'),
        gamma: data.dig('greeks', 'gamma'),
        theta: data.dig('greeks', 'theta'),
        vega: data.dig('greeks', 'vega'),
        oi: data['oi'],
        volume: data['volume'],
        price_change: data['last_price'].to_f - data['previous_close_price'].to_f,
        oi_change: data['oi'].to_i - data['previous_oi'].to_i
      }
    end
  end
end

# File: app/services/application_service.rb
# frozen_string_literal: true

class ApplicationService
  def self.call(...)
    new(...).call
  end

  private

  # ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
  # 📣 Telegram Integration
  # ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

  def notify_step(step, message = nil)
    notify("🔹 Step: #{step}\n#{message || '...'}", tag: step.to_s.upcase)
  end

  def notify_success(message = '✅ Step completed successfully')
    notify(message, tag: 'SUCCESS')
  end

  def notify_failure(error, step = nil)
    notify("❌ Failure#{" at #{step}" if step}: #{error.class} – #{error.message}", tag: 'FAILURE')
  end

  def notify(message, tag: nil)
    context = "[#{self.class.name}]"
    final_message = tag.present? ? "#{context} [#{tag}] \n\n #{message}" : "#{context} #{message}"
    TelegramNotifier.send_message(final_message)
  rescue StandardError => e
    log_error("Telegram Notify Failed: #{e.class} - #{e.message}")
  end

  def typing_ping
    TelegramNotifier.send_chat_action(chat_id: nil, action: 'typing')
  rescue StandardError => e
    log_error("Telegram Typing Action Failed: #{e.class} - #{e.message}")
  end

  # ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
  # 🧾 Logging Helpers (auto-prefix with class name)
  # ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

  %i[info warn error debug].each do |lvl|
    define_method("log_#{lvl}") do |msg|
      Rails.logger.send(lvl, "[#{self.class.name}] #{msg}")
    end
  end
end

# File: app/services/execution/order_executor.rb
module Execution
  class OrderExecutor
    def self.buy_option_ce(instrument)
      # Derive CE option symbol from spot instrument
      derivative = DerivativePicker.pick_ce(instrument)

      order = DhanHQ::Models::Order.new(
        transaction_type: 'BUY',
        exchange_segment: 'NSE_FNO',
        product_type: 'INTRADAY',
        order_type: 'MARKET',
        validity: 'DAY',
        security_id: derivative.security_id,
        quantity: derivative.lot_size
      )

      order.save
    end
  end
end

# File: app/services/indicators/breaker_block.rb
module Indicators
  class BreakerBlock
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def identify
      breakers = []

      @candles.each_with_index do |candle, i|
        next if i < 5

        prev = @candles[i - 1]
        before_prev = @candles[i - 2]

        # 1️⃣ Detect bullish breaker (failed bullish OB -> turns bearish)
        if bullish_ob_fail?(before_prev, prev, candle)
          breakers << {
            type: :bearish_breaker,
            breaker_zone: { high: before_prev.high, low: before_prev.low },
            broken_at: candle.timestamp,
            retest_pending: true
          }
        end

        # 2️⃣ Detect bearish breaker (failed bearish OB -> turns bullish)
        next unless bearish_ob_fail?(before_prev, prev, candle)

        breakers << {
          type: :bullish_breaker,
          breaker_zone: { high: before_prev.high, low: before_prev.low },
          broken_at: candle.timestamp,
          retest_pending: true
        }
      end

      breakers
    end

    private

    def bullish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bullish? &&
        next_candle.low < ob.low &&         # OB invalidated
        breaker_candle.close > ob.high      # Breaker confirmation
    end

    def bearish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bearish? &&
        next_candle.high > ob.high &&       # OB invalidated
        breaker_candle.close < ob.low       # Breaker confirmation
    end
  end
end

# File: app/services/indicators/calculator.rb
module Indicators
  class Calculator
    def initialize(series)
      @series = series
    end

    def rsi(period = 14)
      RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: @series.closes, period:).call
    end

    def macd
      RubyTechnicalAnalysis::Macd.new(series: @series.closes).call
    end

    def adx(period = 14)
      hlc = @series.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end
      TechnicalAnalysis::Adx.calculate(hlc, period:).last.adx
    end

    def bullish_signal?
      rsi < 30 && adx > 20 && series.closes.last > series.closes[-2]
    end

    def bearish_signal?
      rsi > 70 && adx > 20 && series.closes.last < series.closes[-2]
    end
  end
end

# File: app/services/indicators/fair_value_gap.rb
module Indicators
  class FairValueGap
    def initialize(series)
      @series = series
    end

    def detect
      fvg_zones = []
      @series.each_cons(3).with_index do |(c1, _c2, c3), i|
        if c3.low > c1.high
          fvg_zones << { index: i + 1, from: c1.high, to: c3.low, direction: :up }
        elsif c3.high < c1.low
          fvg_zones << { index: i + 1, from: c3.high, to: c1.low, direction: :down }
        end
      end
      fvg_zones
    end
  end
end


# File: app/services/indicators/intrinio_wrapper.rb
# app/services/indicators/intrinio_wrapper.rb
module Indicators
  class IntrinioWrapper
    SUPPORTED = TechnicalAnalysis::Indicator.names.map(&:to_s)
    attr_reader :data

    def initialize(data)
      @data = data
    end

    # example: RSI
    def rsi(period: 14)
      vals = TechnicalAnalysis::Rsi.calculate(data,
                                              period: period, price_key: :close)
      vals.map(&:value)
    end

    def adx(period: 14)
      vals = TechnicalAnalysis::Adx.calculate(data, period: period, price_key: :close)
      vals.map(&:adx)
    end

    def macd(fast: 12, slow: 26, signal: 9)
      TechnicalAnalysis::Macd.calculate(data,
                                        fast_period: fast, slow_period: slow, signal_period: signal, price_key: :close)
    end

    def obv
      TechnicalAnalysis::Obv.calculate(data, price_key: :close, volume_key: :volume)
    end

    # .. auto-generate other wrappers via meta-programming if you like
    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  rescue TechnicalAnalysis::ValidationError => e
    Rails.logger.warn("[IntrinioWrapper] #{e.class}: #{e.message}")
    []
  end
end


# File: app/services/indicators/order_block.rb
module Indicators
  class OrderBlock
    def initialize(series)
      @series = series
    end

    def bullish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bearish? && next_c.bullish? && next_c.close > prev.high
      end
    end

    def bearish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bullish? && next_c.bearish? && next_c.close < prev.low
      end
    end
  end
end


# File: app/services/indicators/ruby_ta_wrapper.rb
# app/services/indicators/ruby_ta_wrapper.rb
module Indicators
  class RubyTAWrapper
    SUPPORTED = %w[
      rsi macd stochastic_intraday momentum_index chaikin_money_flow
      bollinger_bands pivot_points mass_index qstick rate_of_change
      wilders_smoothing volume_oscillator williams_r price_channel
    ].freeze
    attr_reader :series

    def initialize(series) = @series = series

    # e.g.
    def rsi(period: 14)
      t = RubyTechnicalAnalysis::RelativeStrengthIndex.new(
               series: series.closes, period: period
             )
      t.valid? ? t.call : []
    end

    def macd(fast: 12, slow: 26, signal: 9)
      t = RubyTechnicalAnalysis::MACD.new(series: series.closes,
                                          fast_period: fast, slow_period: slow, signal_period: signal)
      t.valid? ? t.call : []
    end

    # ... same pattern for other SUPPORTED indicators

    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  end
end


# File: app/services/indicators/structure.rb
module Indicators
  class Structure
    def initialize(series:)
      @series = series
    end

    def break_of_structure
      bos_points = []

      @series.candles.each_with_index do |c, i|
        if @series.swing_high?(i) && c.close < c.open
          bos_points << { index: i, type: :bos, direction: :down }
        elsif @series.swing_low?(i) && c.close > c.open
          bos_points << { index: i, type: :bos, direction: :up }
        end
      end
      bos_points
    end
  end
end


# File: app/services/indicators/supertrend.rb
module Indicators
  class Supertrend < ApplicationService
    attr_reader :series, :period, :multiplier, :supertrend_values, :candles

    def initialize(series:, period: 10, multiplier: 3.0)
      @series = series
      @candles = series.candles
      @period = period
      @multiplier = multiplier
      @supertrend_values = []
    end

    def call
      atr = calculate_atr
      return [] if atr.empty?

      supertrend = []
      trend = [] # :bullish or :bearish

      candles.each_with_index do |candle, i|
        next if i < period

        hl2 = (candle.high + candle.low) / 2.0
        upper_band = hl2 + (multiplier * atr[i])
        lower_band = hl2 - (multiplier * atr[i])

        if i == period
          supertrend[i] = upper_band
          trend[i] = :bearish
        else
          prev_close = candles[i - 1].close
          prev_supertrend = supertrend[i - 1]

          if prev_close <= supertrend[i - 1]
            supertrend[i] = [upper_band, prev_supertrend].min
            trend[i] = candle.close <= supertrend[i] ? :bearish : :bullish
          else
            supertrend[i] = [lower_band, prev_supertrend].max
            trend[i] = candle.close >= supertrend[i] ? :bullish : :bearish
          end
        end

        supertrend_values[i] = supertrend[i]
      end

      supertrend_values
    end

    private

    def calculate_atr
      tr = []
      atr = []

      candles.each_with_index do |candle, i|
        if i.zero?
          tr[i] = candle.high - candle.low
        else
          prev_close = candles[i - 1].close
          tr[i] = [
            candle.high - candle.low,
            (candle.high - prev_close).abs,
            (candle.low - prev_close).abs
          ].max
        end
      end

      # Simple Moving Average for ATR
      (0...candles.size).each do |i|
        atr[i] = if i < period
                   nil
                 else
                   tr[(i - period + 1)..i].compact.sum / period
                 end
      end

      atr
    end
  end
end


# File: app/services/instruments_importer.rb
# app/services/instruments_importer.rb
# frozen_string_literal: true

require 'csv'
require 'open-uri'

class InstrumentsImporter
  CSV_URL         = 'https://images.dhan.co/api-data/api-scrip-master-detailed.csv'
  CACHE_PATH      = Rails.root.join('tmp/dhan_scrip_master.csv') # ← NEW
  CACHE_MAX_AGE   = 24.hours # ← NEW
  VALID_EXCHANGES = %w[NSE BSE].freeze
  BATCH_SIZE      = 1_000

  class << self
    # ------------------------------------------------------------
    # Public entry point
    # ------------------------------------------------------------
    def import_from_url
      csv_text = fetch_csv_with_cache # ← NEW (was: URI.open(CSV_URL).read)
      import_from_csv(csv_text)
    end

    # ------------------------------------------------------------
    # Fetch CSV with 24-hour cache
    # ------------------------------------------------------------
    # ← NEW helper
    def fetch_csv_with_cache
      if CACHE_PATH.exist? && Time.current - CACHE_PATH.mtime < CACHE_MAX_AGE
        Rails.logger.info "Using cached CSV (#{CACHE_PATH})"
        return CACHE_PATH.read
      end

      Rails.logger.info 'Downloading fresh CSV from Dhan…'
      csv_text = URI.open(CSV_URL).read

      CACHE_PATH.dirname.mkpath
      File.write(CACHE_PATH, csv_text)
      Rails.logger.info "Saved CSV to #{CACHE_PATH}"

      csv_text
    rescue StandardError => e
      Rails.logger.warn "CSV download failed: #{e.message}"
      raise e if CACHE_PATH.exist? == false   # don’t swallow if no fallback

      Rails.logger.warn 'Falling back to cached CSV (may be stale)'
      CACHE_PATH.read
    end
    private :fetch_csv_with_cache             # keep helper private

    def import_from_csv(csv_content)
      instruments_rows, derivatives_rows = build_batches(csv_content)
      Rails.logger.debug instruments_rows.size, derivatives_rows.size
      # instruments_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }
      # derivatives_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }

      import_instruments!(instruments_rows)  unless instruments_rows.empty?
      import_derivatives!(derivatives_rows)  unless derivatives_rows.empty?
    end

    private

    # ------------------------------------------------------------
    # 1. Split CSV rows
    # ------------------------------------------------------------
    def build_batches(csv_content)
      instruments = []
      derivatives = []

      CSV.parse(csv_content, headers: true).each do |row|
        next unless VALID_EXCHANGES.include?(row['EXCH_ID'])

        attrs = build_attrs(row)

        if row['SEGMENT'] == 'D'   # Derivative
          derivatives << attrs.slice(*Derivative.column_names.map(&:to_sym))
        else                       # Cash / Index
          instruments << attrs.slice(*Instrument.column_names.map(&:to_sym))
        end
      end

      [instruments, derivatives]
    end

    def build_attrs(row)
      now = Time.zone.now
      {
        security_id: row['SECURITY_ID'],
        exchange: row['EXCH_ID'],
        segment: row['SEGMENT'],
        isin: row['ISIN'],
        instrument_code: row['INSTRUMENT'],
        underlying_security_id: row['UNDERLYING_SECURITY_ID'],
        underlying_symbol: row['UNDERLYING_SYMBOL'],
        symbol_name: row['SYMBOL_NAME'],
        display_name: row['DISPLAY_NAME'],
        instrument_type: row['INSTRUMENT_TYPE'],
        series: row['SERIES'],
        lot_size: row['LOT_SIZE']&.to_i,
        expiry_date: safe_date(row['SM_EXPIRY_DATE']),
        strike_price: row['STRIKE_PRICE']&.to_f,
        option_type: row['OPTION_TYPE'],
        tick_size: row['TICK_SIZE']&.to_f,
        expiry_flag: row['EXPIRY_FLAG'],
        bracket_flag: row['BRACKET_FLAG'],
        cover_flag: row['COVER_FLAG'],
        asm_gsm_flag: row['ASM_GSM_FLAG'],
        asm_gsm_category: row['ASM_GSM_CATEGORY'],
        buy_sell_indicator: row['BUY_SELL_INDICATOR'],
        buy_co_min_margin_per: row['BUY_CO_MIN_MARGIN_PER']&.to_f,
        sell_co_min_margin_per: row['SELL_CO_MIN_MARGIN_PER']&.to_f,
        buy_co_sl_range_max_perc: row['BUY_CO_SL_RANGE_MAX_PERC']&.to_f,
        sell_co_sl_range_max_perc: row['SELL_CO_SL_RANGE_MAX_PERC']&.to_f,
        buy_co_sl_range_min_perc: row['BUY_CO_SL_RANGE_MIN_PERC']&.to_f,
        sell_co_sl_range_min_perc: row['SELL_CO_SL_RANGE_MIN_PERC']&.to_f,
        buy_bo_min_margin_per: row['BUY_BO_MIN_MARGIN_PER']&.to_f,
        sell_bo_min_margin_per: row['SELL_BO_MIN_MARGIN_PER']&.to_f,
        buy_bo_sl_range_max_perc: row['BUY_BO_SL_RANGE_MAX_PERC']&.to_f,
        sell_bo_sl_range_max_perc: row['SELL_BO_SL_RANGE_MAX_PERC']&.to_f,
        buy_bo_sl_range_min_perc: row['BUY_BO_SL_RANGE_MIN_PERC']&.to_f,
        sell_bo_sl_min_range: row['SELL_BO_SL_MIN_RANGE']&.to_f,
        buy_bo_profit_range_max_perc: row['BUY_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        sell_bo_profit_range_max_perc: row['SELL_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        buy_bo_profit_range_min_perc: row['BUY_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        sell_bo_profit_range_min_perc: row['SELL_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        mtf_leverage: row['MTF_LEVERAGE']&.to_f,
        created_at: now,
        updated_at: now
      }
    end

    # ------------------------------------------------------------
    # 3. Upsert instruments
    # ------------------------------------------------------------
    def import_instruments!(rows)
      res = Instrument.import(
        rows,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            display_name isin instrument_code instrument_type
            underlying_symbol lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Instruments: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4. Upsert derivatives
    # ------------------------------------------------------------
    def import_derivatives!(rows)
      with_parent, without_parent = attach_instrument_ids(rows)

      Rails.logger.info "Derivatives w/ parent: #{with_parent.size}"
      Rails.logger.info "Derivatives w/o parent: #{without_parent.size}"

      return if with_parent.empty?

      res = Derivative.import(
        with_parent,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            symbol_name display_name isin instrument_code instrument_type
            underlying_symbol series lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Derivatives: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4a. Attach instrument_id to each derivative row
    # ------------------------------------------------------------
    def attach_instrument_ids(rows)
      enum_to_csv = Instrument.instrument_codes

      # 🔑 lookup key = [csv_code, UNDERLYING_SYMBOL]
      lookup = Instrument.pluck(
        :id, :instrument_code, :underlying_symbol, :exchange, :segment
      ).each_with_object({}) do |(id, enum_code, sym, _exch, _seg), h|
        next if sym.blank?

        csv_code = enum_to_csv[enum_code] || enum_code # keep CSV code itself
        key      = [csv_code, sym.upcase]
        h[key]   = id
      end

      Rails.logger.debug { "lookup size: #{lookup.size}" }

      with_parent    = []
      without_parent = []
      count = 0
      rows.each do |h|
        count += 1 if h[:underlying_symbol]
        next without_parent << h if h[:underlying_symbol].blank?

        parent_code = InstrumentTypeMapping.underlying_for(h[:instrument_code]) # FUTIDX ➜ INDEX
        key         = [parent_code, h[:underlying_symbol].upcase]

        if (pid = lookup[key])
          h[:instrument_id] = pid
          with_parent << h
        else
          without_parent << h
        end
      end

      [with_parent, without_parent]
    end

    # ------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------
    def safe_date(str)
      Date.parse(str)
    rescue StandardError
      nil
    end

    def map_segment(char)
      { 'I' => 'index', 'E' => 'equity', 'C' => 'currency',
        'D' => 'derivatives', 'M' => 'commodity' }[char] || char.downcase
    end
  end
end

# File: app/services/market_calendar.rb
module MarketCalendar
  MARKET_HOLIDAYS = [
    # Add static or API-fetched holiday dates here
    Date.new(2025, 8, 15)
    # ...
  ]

  def self.trading_day?(date)
    weekday = date.on_weekday?
    !MARKET_HOLIDAYS.include?(date) && weekday
  end

  def self.last_trading_day(from: Time.zone.today)
    date = from
    date -= 1 until trading_day?(date)
    date
  end

  def self.today_or_last_trading_day
    trading_day?(Time.zone.today) ? Time.zone.today : last_trading_day
  end
end


# File: app/services/openai/behaviour_explainer.rb
module Openai
  class BehaviourExplainer < ApplicationService
    def initialize(analysis_hash)
      @data = analysis_hash
    end

    def call
      prompt = build_prompt
      typing_ping
      completion = OpenAI::Client.new.chat(
        parameters: {
          model: 'gpt-4',
          messages: [
            { role: 'system', content: 'You are an options trading expert' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7
        }
      )
      result = completion.dig('choices', 0, 'message', 'content')
      notify("📘 AI Options Insight for #{@data[:symbol]}:\n\n#{result}", tag: 'AI_EXPLAIN')
      result
    rescue StandardError => e
      notify_failure(e, :openai)
      nil
    end

    def build_prompt
      <<~PROMPT
        Given the following ATM options data for #{@data[:symbol]} (#{@data[:expiry]}), analyze the market sentiment and expected move direction:

        CE:
        • Price: #{@data[:ce][:last_price]}
        • IV: #{@data[:ce][:iv]}
        • Δ: #{@data[:ce][:delta]}
        • θ: #{@data[:ce][:theta]}
        • OI: #{@data[:ce][:oi]}
        • Price Change: #{@data[:ce][:price_change]}

        PE:
        • Price: #{@data[:pe][:last_price]}
        • IV: #{@data[:pe][:iv]}
        • Δ: #{@data[:pe][:delta]}
        • θ: #{@data[:pe][:theta]}
        • OI: #{@data[:pe][:oi]}
        • Price Change: #{@data[:pe][:price_change]}

        Spot: #{@data[:spot]}
        ATM: #{@data[:atm]}

        Respond with:
        - Sentiment: Bullish / Bearish / Neutral
        - Reasoning
        - Suggested next move for CE or PE buying (if any)
      PROMPT
    end
  end
end

# File: app/services/option/chain_analyzer.rb


# File: app/services/smc/bos.rb
# SMC Component: Break of Structure (BOS)
module Smc
  class Bos < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      index = candles.size - 2
      return false if index < 4

      # Detect BOS: Higher High followed by higher low (bullish) or Lower Low + Lower High (bearish)
      last_high = candles[index].high
      prev_high = candles[index - 2].high
      last_low  = candles[index].low
      prev_low  = candles[index - 2].low

      bullish_bos = last_high > prev_high && candles[index + 1].low > prev_low
      bearish_bos = last_low < prev_low && candles[index + 1].high < prev_high

      bullish_bos || bearish_bos
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/choch.rb
# SMC Component: Change of Character (CHOCH)
module Smc
  class Choch < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      recent = candles.last(5)
      prev = candles.last(10)[0...5]

      bullish_choch = recent.first.low > prev.map(&:low).max && recent.last.close > recent.first.open
      bearish_choch = recent.first.high < prev.map(&:high).min && recent.last.close < recent.first.open

      bullish_choch || bearish_choch
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/fair_value_gap.rb
# frozen_string_literal: true

module Smc
  class FairValueGap < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 3

      # Use last 3 candles
      c1, c2, c3 = candles[-3..]

      bullish_gap = c3.low > c1.high
      bearish_gap = c3.high < c1.low

      bullish_gap || bearish_gap
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/inducement.rb
# frozen_string_literal: true

module Smc
  class Inducement < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      lookback = 15
      current = candles.last
      past = candles.last(lookback + 1)[0...lookback]

      inducement_up = false
      inducement_down = false

      # False breakout above previous highs (trap long buyers)
      highest_past_high = past.map(&:high).max
      inducement_up = true if current.high > highest_past_high && current.close < highest_past_high && current.bearish?

      # False breakdown below previous lows (trap short sellers)
      lowest_past_low = past.map(&:low).min
      inducement_down = true if current.low < lowest_past_low && current.close > lowest_past_low && current.bullish?

      inducement_up || inducement_down
    rescue StandardError => e
      Rails.logger.error("SMC::Inducement error: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/interpreter.rb
module SMC
  class Interpreter < ApplicationService
    def initialize(analysis_hash)
      @analysis = analysis_hash
    end

    def call
      client = OpenAI::Client.new(...)
      prompt = build_prompt
      response = client.chat(... prompt ...)
      JSON.parse(response.dig("choices", 0, "message", "content"))
    end

    def build_prompt
      openai_prompt_for_smc(@analysis)
    end
  end
end


# File: app/services/smc/mitigation.rb
# frozen_string_literal: true

module Smc
  class Mitigation < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      # Reuse previously defined Order Blocks
      order_blocks = Smc::OrderBlock.call(series: series)
      return false if order_blocks.blank?

      # Pick the last known OB zone
      ob = order_blocks.last
      return false unless ob[:index] && ob[:type] && ob[:range]

      # Only consider mitigation attempts that come after 3 candles from OB
      mitigation_index = ob[:index] + 3
      return false if candles.size <= mitigation_index

      # Look for price touching or reacting from OB zone in later candles
      candles[mitigation_index..].each do |candle|
        if ob[:type] == :bullish
          return true if candle.low <= ob[:range][:low] && candle.close > ob[:range][:low]
        elsif ob[:type] == :bearish
          return true if candle.high >= ob[:range][:high] && candle.close < ob[:range][:high]
        end
      end

      false
    rescue StandardError => e
      Rails.logger.error("Mitigation check failed: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/order_block.rb
# frozen_string_literal: true

module Smc
  class OrderBlock < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      last_index = candles.size - 1
      lookback = 10

      (last_index - lookback).upto(last_index - 2) do |i|
        curr = candles[i]
        nxt  = candles[i + 1]

        # Bullish Order Block: Last bearish candle before strong bullish candle
        return true if curr.bearish? && nxt.bullish? && nxt.close > nxt.open + series.atr && price_respected_order_block?(curr.low, :bullish)

        # Bearish Order Block: Last bullish candle before strong bearish candle
        return true if curr.bullish? && nxt.bearish? && nxt.close < nxt.open - series.atr && price_respected_order_block?(curr.high, :bearish)
      end

      false
    end

    private

    attr_reader :series, :candles

    def price_respected_order_block?(level, direction)
      last = candles.last
      if direction == :bullish
        last.low >= level
      else
        last.high <= level
      end
    end
  end
end


# File: app/services/strategies/base_indicator_strategy.rb
module Strategies
  class BaseIndicatorStrategy
    attr_reader :instrument, :series, :interval

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def initialize(instrument, series: nil, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = series || instrument.candles(interval)
    end

    def series
      @series ||= instrument.candles(interval)
    end

    def candles
      @candles ||= series.candles
    end

    def closes
      @closes ||= candles.map(&:close)
    end

    def highs
      @highs ||= candles.map(&:high)
    end

    def lows
      @lows ||= candles.map(&:low)
    end

    def opens
      @opens ||= candles.map(&:open)
    end

    def volumes
      @volumes ||= candles.map(&:volume)
    end

    def last_candle
      @last_candle ||= candles.last
    end

    def signal?
      raise NotImplementedError, "#{self.class.name} must implement #signal?"
    end

    def signal_details
      result = signal?
      return nil unless result

      {
        signal: result,
        confidence: confidence_score,
        reason: reason_text
      }
    end
  end
end

# File: app/services/strategies/basic_trend_strategy.rb
module Strategies
  class BasicTrendStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw_data = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw_data)
    end

    def call
      calc = Indicators::Calculator.new(@series)
      if calc.bullish_signal?
        :buy_ce
      elsif calc.bearish_signal?
        :buy_pe
      else
        :hold
      end
    end
  end
end

# File: app/services/strategies/bollinger_rsi.rb
module Strategies
  class BollingerRsi < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      close = instrument.candles.closes.last
      bands = instrument.bollinger_bands

      pp "RSI: #{rsi}, Close: #{close}, Bands: #{bands.inspect}"
      return :buy_ce if close > bands[:upper] && rsi < 70

      :buy_pe if close < bands[:lower] && rsi > 30
    end

    def confidence_score = 65
    def reason_text = "BB/RSI: Close=#{series.closes.last}, RSI=#{series.rsi}, Bands=#{series.bollinger_bands.inspect}"
  end
end



# File: app/services/strategies/donchian_adx.rb
module Strategies
  class DonchianAdx < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      donchians = instrument.donchian_channel
      adx = instrument.adx

      return :buy_ce if close > donchians.first.upper_bound && adx > 25

      :buy_pe if close < donchians.first.lower_bound && adx > 25
    end

    def confidence_score = 70
    def reason_text = "Donchian/ADX: Close=#{instrument.candles.closes.last}, Donchian=#{instrument.donchian_channel.first.inspect}, ADX=#{instrument.adx}"
  end
end



# File: app/services/strategies/holy_grail_strategy.rb
# frozen_string_literal: true

module Strategies
  class HolyGrailStrategy < BaseIndicatorStrategy
    STRATEGIES = {
      rsi_adx: Strategies::RsiAdxCombo,
      macd_supertrend: Strategies::MacdSupertrend,
      bollinger_rsi: Strategies::BollingerRsi,
      donchian_adx: Strategies::DonchianAdx
      # vwap_rsi: Strategies::VwapRsi,
      # obv_macd: Strategies::ObvMacd
    }.freeze

    STRATEGY_WEIGHTS = {
      rsi_adx: 0.15,
      macd_supertrend: 0.2,
      bollinger_rsi: 0.15,
      donchian_adx: 0.15
      # vwap_rsi: 0.15,
      # obv_macd: 0.2
    }.freeze

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def call
      results = run_all_strategies

      top_signal = results[:votes].max_by { |_signal, w| w }&.first || :hold
      final_score = results[:score]

      {
        strategy: :holygrail,
        instrument: instrument.symbol,
        action: top_signal,
        confidence: final_score.round(2),
        reasons: results[:reasons],
        telemetry: results[:telemetry],
        decision: final_score >= 0.65 ? top_signal : :hold
      }
    end

    # ✨ AI Prompt Payload: use this output to pass to OpenAI
    def ai_prompt_payload
      result = call
      <<~PROMPT.strip
        Instrument: #{result[:instrument]}
        Final Action: #{result[:action].to_s.upcase}
        Confidence Score: #{result[:confidence]}%
        Decision Reasoning:
        #{result[:reasons].map { |r| "- #{r}" }.join("\n")}

        Indicator Telemetry:
        #{result[:telemetry].map { |k, v| "#{k.to_s.titleize}: #{v}" }.join("\n")}

        Based on the above, analyze the current market structure, probable support/resistance zones, and possible close for today. If market is closed, prepare analysis for next session. Suggest any CE/PE trade or HOLD decision with SL/TP levels.
      PROMPT
    end

    private

    attr_reader :instrument, :series

    def run_all_strategies
      results = {
        score: 0.0,
        votes: Hash.new(0),
        reasons: [],
        telemetry: {}
      }

      STRATEGIES.each do |key, klass|
        strat = klass.new(instrument, series: series)
        outcome = strat.signal_details

        next unless outcome

        weight = STRATEGY_WEIGHTS[key]
        results[:votes][outcome[:signal]] += weight
        results[:score] += outcome[:confidence] * weight
        results[:reasons] << "#{key.to_s.titleize} → #{outcome[:signal].to_s.upcase} (#{(outcome[:confidence] * weight).round(1)} pts)"
        results[:telemetry][key] = outcome[:reason]
      end

      results
    end
  end
end

# File: app/services/strategies/liquidity_grab_strategy.rb
module Strategies
  class LiquidityGrabStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      grab_up = @series.liquidity_grab_up?
      grab_down = @series.liquidity_grab_down?

      return :short if grab_up
      return :long  if grab_down

      false
    end
  end
end

# File: app/services/strategies/macd_supertrend.rb
module Strategies
  class MacdSupertrend < BaseIndicatorStrategy
    def signal?
      macd = instrument.macd
      supertrend = instrument.supertrend_signal

      macd_line = macd[:macd]
      signal_line = macd[:signal]

      if macd_line > signal_line && supertrend == :long_entry
        :buy_ce
      elsif macd_line < signal_line && supertrend == :short_entry
        :buy_pe
      end
    end

    def confidence_score = 75
    def reason_text = "MACD/ST: MACD=#{instrument.macd[:macd]}, Signal=#{instrument.macd[:signal]}, Supertrend=#{instrument.supertrend_signal}"
  end
end



# File: app/services/strategies/obv_macd.rb
module Strategies
  class ObvMacd < BaseIndicatorStrategy
    def signal?
      obv = series.obv
      macd = series.macd
      macd_line = macd.last[:macd]
      signal_line = macd.last[:signal]

      return :buy_ce if obv_trending_up?(obv) && macd_line > signal_line

      :buy_pe if obv_trending_down?(obv) && macd_line < signal_line
    end

    def obv_trending_up?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b > a }
    end

    def obv_trending_down?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b < a }
    end

    def confidence_score = 70
    def reason_text = "OBV/MACD: OBV trend detected, MACD=#{series.macd.last[:macd]}, Signal=#{series.macd.last[:signal]}"
  end
end


# File: app/services/strategies/price_action_strategy.rb
module Strategies
  class PriceActionStrategy < ApplicationService
    def initialize(instrument, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = CandleSeries.new(symbol: instrument.symbol_name, interval:)
      raw = instrument.intraday_ohlc(interval: interval)
      @series.load_from_raw(raw)
    end

    def signal?
      # basic setup
      @last = @series.candles.last
      @prev = @series.candles[-2]
      @third = @series.candles[-3]

      bullish_pinbar? || bearish_engulfing? || breakout_candle?
    end

    private

    def bullish_pinbar?
      body = (@last.close - @last.open).abs
      lower_wick = @last.open - @last.low if @last.bullish?
      lower_wick = @last.close - @last.low if @last.bearish?

      lower_wick && lower_wick > body * 2 && @last.close > @last.open
    end

    def bearish_engulfing?
      @prev.bullish? &&
        @last.bearish? &&
        @last.open > @prev.close &&
        @last.close < @prev.open
    end

    def breakout_candle?
      highs = @series.candles[-5..-2].map(&:high)
      @last.high > highs.max && @last.close > highs.max
    end
  end
end

# File: app/services/strategies/rsi_adx_combo.rb
module Strategies
  class RsiAdxCombo < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      adx = instrument.adx

      return :buy_ce if rsi > 30 && adx > 20

      :buy_pe if rsi < 70 && adx > 20
    end

    def confidence_score = 70

    def reason_text
      "RSI/ADX Combo: RSI=#{instrument.rsi.round(2)}, ADX=#{instrument.adx.round(2)}"
    end
  end
end



# File: app/services/strategies/smart_money_strategy.rb
module Strategies
  class SmartMoneyStrategy
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      fvg     = Indicators::FairValueGap.new(@series).detect.last
      blocks  = Indicators::OrderBlock.new(@series).bullish_order_blocks.last
      bos     = Indicators::Structure.new(@series).break_of_structure.last

      return false unless bos && fvg && blocks

      # Apply filters (e.g., direction match)
      bos[:direction] == :up && blocks[:low] > fvg[:from]
    end

    def analysis_result
      {
        symbol: @instrument.symbol_name,
        interval: @series.interval,
        structure: Indicators::Structure.new(@series).summary,
        order_blocks: Indicators::OrderBlock.new(@series).summary,
        fair_value_gaps: Indicators::FairValueGap.new(@series).summary,
        current_price: @series.closes.last,
        signal: signal? ? :long_entry : :hold
      }
    end
  end
end


# File: app/services/strategies/smc_strategy.rb
# frozen_string_literal: true

module Strategies
  class SmcStrategy < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
      @score = 0
      @reasons = []
    end

    def call
      return hold_signal('Not enough candles') if candles.size < 50

      # Run all Smc indicators
      bos     = Smc::Bos.call(series: series)
      choch   = Smc::Choch.call(series: series)
      order_blocks = Smc::OrderBlock.call(series: series)
      fvg     = Smc::FairValueGap.call(series: series)
      mitg    = Smc::Mitigation.call(series: series)
      induc   = Smc::Inducement.call(series: series)
      grab_up = series.liquidity_grab_up?
      grab_dn = series.liquidity_grab_down?

      # Scoring
      apply_score(:bos, bos)
      apply_score(:choch, choch)
      apply_score(:order_block, order_blocks)
      apply_score(:fvg, fvg)
      apply_score(:mitigation, mitg)
      apply_score(:inducement, induc)
      apply_score(:liquidity_grab_up, grab_up)
      apply_score(:liquidity_grab_down, grab_dn)

      confidence = score

      if confidence >= 70 && (bos || choch)
        action = if grab_up
                   :buy_pe
                 else
                   grab_dn ? :buy_ce : :hold
                 end
        build_signal(action, confidence)
      else
        hold_signal("Low Smc confidence: #{confidence}%")
      end
    rescue StandardError => e
      notify_failure(e, 'SmcStrategy')
      hold_signal("Exception: #{e.message}")
    end

    private

    attr_reader :series, :score, :reasons, :candles

    def apply_score(name, result)
      return unless result

      weight = case name
               when :bos then 20
               when :choch then 15
               when :order_block then 10
               when :fvg then 10
               when :mitigation then 10
               when :inducement then 10
               when :liquidity_grab_up, :liquidity_grab_down then 15
               else 0
               end

      @score += weight
      reasons << "#{name.to_s.titleize} = TRUE (+#{weight})"
    end

    def build_signal(action, confidence)
      {
        strategy: :Smc,
        action: action,
        confidence: confidence,
        reasons: reasons,
        stop_loss: derive_sl(action),
        take_profit: derive_tp(action)
      }
    end

    def derive_sl(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.low - atr : last.high + atr
    end

    def derive_tp(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.close + (3 * atr) : last.close - (3 * atr)
    end

    def hold_signal(reason)
      {
        strategy: :Smc,
        action: :hold,
        confidence: score,
        reasons: reasons << reason
      }
    end
  end
end


# File: app/services/strategies/vwap_rsi.rb
module Strategies
  class VwapRsi < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      vwap = instrument.vwap
      rsi = instrument.rsi

      return :buy_ce if close > vwap && rsi > 40

      :buy_pe if close < vwap && rsi < 60
    end

    def confidence_score = 60
    def reason_text = "VWAP/RSI: Close=#{series.closes.last}, VWAP=#{series.vwap}, RSI=#{series.rsi.last}"
  end
end



# File: app/services/telegram_notifier.rb
# frozen_string_literal: true

require 'net/http'
require 'uri'

class TelegramNotifier
  TELEGRAM_API = 'https://api.telegram.org'

  def self.send_message(text, chat_id: nil, **extra_params)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendMessage', chat_id:, text:, **extra_params)
  end

  def self.send_chat_action(action:, chat_id: nil)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendChatAction', chat_id:, action:)
  end

  private_class_method def self.post(method, **params)
    uri = URI("#{TELEGRAM_API}/bot#{ENV.fetch('TELEGRAM_BOT_TOKEN')}/#{method}")
    res = Net::HTTP.post_form(uri, params)
    Rails.logger.error("Telegram #{method} failed: #{res.body}") unless res.is_a?(Net::HTTPSuccess)
    res
  rescue StandardError => e
    Rails.logger.error("Telegram #{method} error: #{e.message}")
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/import_instruments.rake
namespace :instruments do
  desc 'Import instruments from DhanHQ CSV'
  task import: :environment do
    pp 'Starting instruments import...'
    start_time = Time.current

    begin
      InstrumentsImporter.import_from_url

      duration = Time.current - start_time
      pp "\nImport completed successfully in #{duration.round(2)} seconds!"
      pp "Total Instruments: #{Instrument.count}"
      pp "Total Derivatives: #{Derivative.count}"

      # Show some stats
      pp "\n--- Stats ---"
      pp "NSE Instruments: #{Instrument.nse.count}"
      pp "BSE Instruments: #{Instrument.bse.count}"
      pp "NSE Derivatives: #{Derivative.nse.count}"
      pp "BSE Derivatives: #{Derivative.bse.count}"
      pp "Options: #{Derivative.options.count}"
      pp "Futures: #{Derivative.futures.count}"
      pp 'Instruments: Instrument.count'
      pp 'Derivatives: Derivative.count'
      pp "TOTAL: #{Instrument.count + Derivative.count}"
    rescue StandardError => e
      pp "Import failed: #{e.message}"
      pp e.backtrace.join("\n")
    end
  end

  desc 'Clear all instruments and derivatives'
  task clear: :environment do
    pp 'Clearing all instruments and derivatives...'
    Derivative.delete_all
    Instrument.delete_all
    pp 'Cleared successfully!'
  end

  desc 'Reimport (clear and import)'
  task reimport: %i[clear import]
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end


# File: config/initializers/dhanhq.rb
require 'DhanHQ'

DhanHQ.configure_with_env

# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += %i[
  passw email secret token _key crypt salt certificate otp ssn cvv cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/openai.rb
OpenAI.configure do |config|
  config.access_token = ENV.fetch('OPENAI_API_KEY', nil)
end

