# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/controllers/holdings_controller.rb
class HoldingsController < ApplicationController
end


# File: app/controllers/positions_controller.rb
class PositionsController < ApplicationController
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/jobs/mtf_start_job.rb
# app/jobs/mtf_start_job.rb
class MtfStartJob < ApplicationJob
  queue_as :default
  def perform
    # Live::WsHub.instance.start!(mode: :quote) # already in initializer; idempotent
    Runner::MtfLoop.start(symbols: %w[NIFTY BANKNIFTY], timeframe: '15m')
  end
end


# File: app/jobs/scalp_session_runner_job.rb
class ScalpSessionRunnerJob < ApplicationJob
  queue_as :default

  # Long-running job â€“ ensure delayed_job timeout is high enough or disabled for this queue
  def perform(date: Date.current, capital: 100_000.0, max_day_loss: 3000.0, roster: %w[NIFTY BANKNIFTY], risk_rupees: 600.0)
    session = ScalpSession.find_or_create_by!(trade_date: date) do |s|
      s.capital      = capital
      s.max_day_loss = max_day_loss
      s.params = {
        'risk_rupees' => risk_rupees,
        'roster' => roster,
        'profit_trigger_rupees' => 1000.0,
        'no_entries_after' => '15:00'
      }
    end
    Scalp::Runner.call(session: session)
  end
end

# File: app/jobs/scalp_session_stop_job.rb
class ScalpSessionStopJob < ApplicationJob
  queue_as :default

  def perform(date: Date.current)
    if (session = ScalpSession.find_by(trade_date: date))
      # simple signal: flip status â†’ runner loop will see it
      session.update!(status: :killed)
    end
  end
end

# File: app/lib/state/events.rb
# app/lib/state/events.rb
module State
  class Events
    PATH = Rails.root.join("tmp/trader_events.ndjson")

    def self.log(type:, data:)
      File.open(PATH, "a") { |f| f.puts({ ts: Time.now.iso8601, type:, data: }.to_json) }
    rescue => e
      Rails.logger.warn("Event log fail: #{e.class} #{e.message}")
    end

    def self.replay!
      return unless File.exist?(PATH)
      File.foreach(PATH) do |line|
        evt = JSON.parse(line) rescue next
        apply(evt["type"], evt["data"].deep_symbolize_keys)
      end
    end

    def self.apply(type, data)
      case type.to_sym
      when :order_upsert   then State::OrderCache.put!(data[:client_ref], data)
      when :order_delete   then # optional, already handled
      when :position_upsert then State::PositionCache.upsert!(**data.slice(:seg,:sid,:prod), attrs: data)
      when :position_delete then State::PositionCache.delete!(**data.slice(:seg,:sid,:prod))
      end
    end
  end
end


# File: app/lib/state/order_cache.rb
# app/lib/state/order_cache.rb
module State
  class OrderCache
    KEY = 'orders:v1' # single hash stored in Rails.cache

    def self.fetch_all
      Rails.cache.fetch(KEY) { {} } # { client_ref => { ... } }
    end

    def self.get(client_ref) = fetch_all[client_ref]

    def self.put!(client_ref, payload)
      h = fetch_all
      h[client_ref] = payload
      Rails.cache.write(KEY, h)
      Events.log(type: :order_upsert, data: payload)
      true
    end

    def self.find_by_broker_id(oid)
      fetch_all.values.find { |o| o[:broker_order_id] == oid }
    end

    def self.delete!(client_ref)
      h = fetch_all
      h.delete(client_ref)
      Rails.cache.write(KEY, h)
      Events.log(type: :order_delete, data: { client_ref: })
    end
  end
end


# File: app/lib/state/position_cache.rb
# app/lib/state/position_cache.rb
module State
  class PositionCache
    KEY = 'positions:v1' # { pos_key => {...} }

    def self.key(seg:, sid:, prod:)
      "#{seg}:#{sid}:#{prod}"
    end

    def self.fetch_all
      Rails.cache.fetch(KEY) { {} }
    end

    def self.get(seg:, sid:, prod:)
      fetch_all[key(seg:, sid:, prod:)]
    end

    def self.upsert!(seg:, sid:, prod:, attrs:)
      h = fetch_all
      k = key(seg:, sid:, prod:)
      h[k] = (h[k] || {}).merge(attrs).merge(updated_at: Time.current)
      Rails.cache.write(KEY, h)
      Events.log(type: :position_upsert, data: h[k].merge(key: k))
      h[k]
    end

    def self.delete!(seg:, sid:, prod:)
      h = fetch_all
      h.delete(key(seg:, sid:, prod:))
      Rails.cache.write(KEY, h)
      Events.log(type: :position_delete, data: { seg:, sid:, prod: })
    end
  end
end


# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/candle.rb
class Candle
  attr_reader :timestamp, :open, :high, :low, :close, :volume

  def initialize(ts:, open:, high:, low:, close:, volume:)
    @timestamp = ts
    @open = open.to_f
    @high = high.to_f
    @low = low.to_f
    @close = close.to_f
    @volume = volume.to_i
  end

  def bullish? = close >= open
  def bearish? = close < open
end

# File: app/models/candle_series.rb
class CandleSeries
  include Enumerable

  attr_reader :symbol, :interval, :candles

  def initialize(symbol:, interval: '5')
    @symbol = symbol
    @interval = interval
    @candles = []
  end

  def each(&) = candles.each(&)
  def add_candle(candle) = candles << candle

  def load_from_raw(response)
    normalise_candles(response).each do |row|
      @candles << Candle.new(
        ts: Time.zone.parse(row[:timestamp].to_s),
        open: row[:open], high: row[:high],
        low: row[:low], close: row[:close],
        volume: row[:volume]
      )
    end
  end

  def normalise_candles(resp)
    return [] if resp.blank?

    return resp.map { |c| slice_candle(c) } if resp.is_a?(Array)

    raise "Unexpected candle format: #{resp.class}" unless resp.is_a?(Hash) && resp['high'].is_a?(Array)

    size = resp['high'].size
    (0...size).map do |i|
      {
        open: resp['open'][i].to_f,
        close: resp['close'][i].to_f,
        high: resp['high'][i].to_f,
        low: resp['low'][i].to_f,
        timestamp: Time.zone.at(resp['timestamp'][i]),
        volume: resp['volume'][i].to_i
      }
    end
  end

  # Normalises a single candle entry which may be provided either as a Hash
  # with symbol/string keys or as an Array in the order:
  # [timestamp, open, high, low, close, volume].
  def slice_candle(candle)
    if candle.is_a?(Hash)
      {
        open: candle[:open] || candle['open'],
        close: candle[:close] || candle['close'],
        high: candle[:high] || candle['high'],
        low: candle[:low] || candle['low'],
        timestamp: candle[:timestamp] || candle['timestamp'],
        volume: candle[:volume] || candle['volume'] || 0
      }
    elsif candle.respond_to?(:[]) && candle.size >= 6
      {
        timestamp: candle[0],
        open: candle[1],
        high: candle[2],
        low: candle[3],
        close: candle[4],
        volume: candle[5]
      }
    else
      raise "Unexpected candle format: #{candle.inspect}"
    end
  end

  def opens  = candles.map(&:open)
  def closes = candles.map(&:close)
  def highs  = candles.map(&:high)
  def lows   = candles.map(&:low)

  def hlc
    candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        high: c.high,
        low: c.low,
        close: c.close
      }
    end
  end

  def atr(period = 14)
    TechnicalAnalysis::Atr.calculate(hlc, period: period).first.atr
  end

  def swing_high?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].high
    left = candles[(index - lookback)...index].map(&:high)
    right = candles[(index + 1)..(index + lookback)].map(&:high)
    current > left.max && current > right.max
  end

  def swing_low?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].low
    left = candles[(index - lookback)...index].map(&:low)
    right = candles[(index + 1)..(index + lookback)].map(&:low)
    current < left.min && current < right.min
  end

  def recent_highs(n = 20)
    candles.last(n).map(&:high)
  end

  def recent_lows(n = 20)
    candles.last(n).map(&:low)
  end

  def previous_swing_high
    recent_highs.sort[-2] # 2nd highest
  end

  def previous_swing_low
    recent_lows.sort[1]   # 2nd lowest
  end

  def liquidity_grab_up?(lookback: 20)
    high_now = candles.last.high
    high_prev = previous_swing_high

    high_now > high_prev &&
      candles.last.close < high_prev && # Rejection after breakout
      candles.last.bearish?
  end

  def liquidity_grab_down?(lookback: 20)
    low_now = candles.last.low
    low_prev = previous_swing_low

    low_now < low_prev &&
      candles.last.close > low_prev && # Rejection after breakdown
      candles.last.bullish?
  end

  def rsi(period = 14)
    RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: closes, period: period).call
  end

  def moving_average(period = 20)
    RubyTechnicalAnalysis::MovingAverages.new(series: closes, period: period)
  end

  def sma(period = 20)
    moving_average(period).sma
  end

  def ema(period = 20)
    moving_average(period).ema
  end

  def macd(fast_period = 12, slow_period = 26, signal_period = 9)
    macd = RubyTechnicalAnalysis::Macd.new(series: closes, fast_period: fast_period, slow_period: slow_period, signal_period: signal_period)
    macd.call
  end

  def rate_of_change(period = 5)
    closes = self.closes
    return nil if closes.size < period + 1

    # ((current_close - close_n_periods_ago) / close_n_periods_ago) * 100
    roc_series = []
    closes.each_with_index do |price, idx|
      if idx < period
        roc_series << nil # not enough data for these initial points
      else
        previous_price = closes[idx - period]
        roc_series << (((price - previous_price) / previous_price.to_f) * 100.0)
      end
    end
    roc_series
  end

  def supertrend_signal
    trend_line = Indicators::Supertrend.new(series: self).call
    return nil if trend_line.empty?

    latest_close = closes.last
    latest_trend = trend_line.last

    return :long_entry if latest_close > latest_trend

    :short_entry if latest_close < latest_trend
  end

  def inside_bar?(i)
    return false if i < 1

    curr = @candles[i]
    prev = @candles[i - 1]
    curr.high < prev.high && curr.low > prev.low
  end

  def bollinger_bands(period: 20)
    return nil if candles.size < period

    bb = RubyTechnicalAnalysis::BollingerBands.new(
      series: closes,
      period: period
    ).call

    { upper: bb[0], lower: bb[1], middle: bb[2] }
  end

  def donchian_channel(period: 20)
    return nil if candles.size < period

    dc = candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        value: c.close
      }
    end
    TechnicalAnalysis::Dc.calculate(dc, period: period)
  end
end

# File: app/models/concerns/candle_extension.rb
# Extend Instrument with candle series integration
module CandleExtension
  extend ActiveSupport::Concern

  included do
    def candles(interval: '5')
      @ohlc_cache ||= {}
      return @ohlc_cache[interval] if @ohlc_cache[interval] && !ohlc_stale?(interval)

      raw_data = intraday_ohlc(interval: interval)
      return nil if raw_data.blank?

      @ohlc_cache[interval] = CandleSeries.new(symbol: symbol_name, interval: interval).tap do |series|
        series.load_from_raw(raw_data)
      end
    end

    def ohlc_stale?(interval)
      return true unless @last_ohlc_fetched

      Time.current - (@last_ohlc_fetched[interval] ||= 1.hour.ago) > 5.minutes
    ensure
      @last_ohlc_fetched ||= {}
      @last_ohlc_fetched[interval] = Time.current
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end

    def rsi(period = 14, interval: '5')
      cs = candles(interval: interval)
      cs&.rsi(period)
    end

    def macd(fast_period = 12, slow_period = 26, signal_period = 9, interval: '5')
      cs = candles(interval: interval)
      macd_result = cs&.macd(fast_period, slow_period, signal_period)
      return nil unless macd_result

      {
        macd: macd_result[0],
        signal: macd_result[1],
        histogram: macd_result[2]
      }
    end

    def adx(period = 14, interval: '5')
      cs = candles(interval: interval)
      closes = cs&.closes
      highs  = cs&.highs
      lows   = cs&.lows
      return nil unless closes && highs && lows

      hlc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end

      ta_adx = TechnicalAnalysis::Adx.calculate(hlc, period: period).first
      ta_adx&.adx
    end

    def supertrend_signal(interval: '5')
      cs = candles(interval: interval)
      cs&.supertrend_signal
    end

    def liquidity_grab_up?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_up?
    end

    def liquidity_grab_down?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_down?
    end

    def bollinger_bands(period: 20, interval: '5')
      cs = candles(interval: interval)
      return nil unless cs

      cs.bollinger_bands(period: period)
    end

    def donchian_channel(period: 20, interval: '5')
      cs = candles(interval: interval)

      dc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          value: c.close
        }
      end
      TechnicalAnalysis::Dc.calculate(dc, period: period)
    end

    def obv(interval: '5')
      dcv = candles(interval: interval).candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          close: c.close,
          volume: c.volume || 0
        }
      end

      TechnicalAnalysis::Obv.calculate(dcv)
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end
  end
end


# File: app/models/concerns/instrument_helpers.rb
module InstrumentHelpers
  extend ActiveSupport::Concern
  include CandleExtension

  included do
    # Enums common to Instrument and Derivative
    enum :exchange, { nse: 'NSE', bse: 'BSE', mcx: 'MCX' }
    enum :segment, { index: 'I', equity: 'E', currency: 'C', derivatives: 'D', commodity: 'M' }, prefix: true
    enum :instrument_code, {
      index: 'INDEX',
      futures_index: 'FUTIDX',
      options_index: 'OPTIDX',
      equity: 'EQUITY',
      futures_stock: 'FUTSTK',
      options_stock: 'OPTSTK',
      futures_currency: 'FUTCUR',
      options_currency: 'OPTCUR',
      futures_commodity: 'FUTCOM',
      options_commodity: 'OPTFUT'
    }, prefix: true

    scope :nse, -> { where(exchange: 'NSE') }
    scope :bse, -> { where(exchange: 'BSE') }

    # Validations for enums can also go here, if common
  end

  # Shared instance methods for market data fetching and helpers
  def ltp
    fetch_ltp_from_api
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def quote_ltp
    quote = quotes.order(tick_time: :desc).first
    return nil unless quote

    quote.ltp.to_f
  rescue StandardError => e
    Rails.logger.error("Failed to fetch latest quote LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def fetch_ltp_from_api
    response = DhanHQ::Models::MarketFeed.ltp(exch_segment_enum)
    response.dig('data', exchange_segment, security_id.to_s, 'last_price') if response['status'] == 'success'
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP from API for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def subscribe_params
    { ExchangeSegment: exchange_segment, SecurityId: security_id.to_s }
  end

  def ws_get
    Live::TickCache.get(exchange_segment, security_id.to_s)
  end

  def ws_ltp
    ws_get&.dig(:ltp)
  end

  def ohlc
    response = DhanHQ::Models::MarketFeed.ohlc(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def historical_ohlc(from_date: nil, to_date: nil, oi: false)
    DhanHQ::Models::HistoricalData.daily(
      securityId: security_id,
      exchangeSegment: exchange_segment,
      instrument: instrument_type,
      oi: oi,
      fromDate: from_date || (Time.zone.today - 365).to_s,
      toDate: to_date || (Time.zone.today - 1).to_s,
      expiryCode: 0
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Historical OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def intraday_ohlc(interval: '5', oi: false, from_date: nil, to_date: nil, days: 90)
    to_date ||= MarketCalendar.today_or_last_trading_day.to_s
    from_date ||= (Date.parse(to_date) - days).to_s # fetch last 5 sessions by default

    DhanHQ::Models::HistoricalData.intraday(
      security_id: security_id,
      exchange_segment: exchange_segment,
      instrument: instrument_type,
      interval: interval,
      oi: oi,
      from_date: from_date || (Time.zone.today - days).to_s,
      to_date: to_date || (Time.zone.today - 1).to_s
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Intraday OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def depth
    response = DhanHQ::Models::MarketFeed.quote(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  # Helper method: dynamic exchange_segment string for API calls
  def exchange_segment
    case [exchange.to_sym, segment.to_sym]
    when %i[nse index], %i[bse index] then 'IDX_I'
    when %i[nse equity] then 'NSE_EQ'
    when %i[bse equity] then 'BSE_EQ'
    when %i[nse derivatives] then 'NSE_FNO'
    when %i[bse derivatives] then 'BSE_FNO'
    when %i[nse currency] then 'NSE_CURRENCY'
    when %i[bse currency] then 'BSE_CURRENCY'
    when %i[mcx commodity] then 'MCX_COMM'
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  private

  def exch_segment_enum
    { exchange_segment => [security_id.to_i] }
  end

  def numeric_value?(value)
    value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
  end
end

# File: app/models/concerns/instrument_type_mapping.rb
# frozen_string_literal: true

module InstrumentTypeMapping
  # ------------------------------------------------------------------
  # Parent â†’ child mapping straight from Dhan CSV spec
  # ------------------------------------------------------------------
  PARENT_TO_CHILDREN = {
    'INDEX' => %w[FUTIDX OPTIDX],
    'EQUITY' => %w[FUTSTK OPTSTK],
    # Commodity & Currency donâ€™t have their own high-level codes in CSV,
    # so we treat the futures variant itself as â€œparentâ€.
    'FUTCOM' => %w[OPTFUT],
    'FUTCUR' => %w[OPTCUR]
  }.freeze

  # ------------------------------------------------------------------
  # Child â†’ parent lookup (built from the hash above)
  # ------------------------------------------------------------------
  CHILD_TO_PARENT =
    PARENT_TO_CHILDREN.flat_map { |parent, kids| kids.map { |kid| [kid, parent] } }
                      .to_h
                      .freeze

  # --------------------------------------------------
  # Public helpers
  # --------------------------------------------------

  # Given *any* code, return its underlying parent.
  #   underlying_for("FUTIDX")  => "INDEX"
  #   underlying_for("INDEX")   => "INDEX"
  def self.underlying_for(code)
    CHILD_TO_PARENT[code] || code
  end

  # Given an underlying parent, return all derivative codes
  #   derivative_codes_for("INDEX") => ["FUTIDX","OPTIDX"]
  def self.derivative_codes_for(parent_code)
    PARENT_TO_CHILDREN[parent_code] || []
  end

  # Convenience lists
  def self.all_parents  = PARENT_TO_CHILDREN.keys
  def self.all_children = CHILD_TO_PARENT.keys
end


# File: app/models/derivative.rb
class Derivative < ApplicationRecord
  include InstrumentHelpers

  belongs_to :instrument

  scope :options, -> { where.not(option_type: [nil, '']) }
  scope :futures, -> { where(option_type: [nil, '']) }
end


# File: app/models/holding.rb
class Holding < ApplicationRecord
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  include InstrumentHelpers

  has_many :derivatives, dependent: :destroy

  accepts_nested_attributes_for :derivatives, allow_destroy: true

  # API Methods
  def fetch_option_chain(expiry = nil)
    expiry ||= expiry_list.first
    data = DhanHQ::Models::OptionChain.fetch(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment,
      expiry: expiry
    )
    return nil unless data

    filtered_data = filter_option_chain_data(data)

    { last_price: data['last_price'], oc: filtered_data }
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{security_id}: #{e.message}")
    nil
  end

  def filter_option_chain_data(data)
    data['oc'].select do |_strike, option_data|
      call_data = option_data['ce']
      put_data = option_data['pe']

      has_call_values = call_data && call_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end
      has_put_values = put_data && put_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end

      has_call_values || has_put_values
    end
  end

  def expiry_list
    DhanHQ::Models::OptionChain.fetch_expiry_list(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment
    )
  end
end


# File: app/models/position.rb
class Position < ApplicationRecord
  belongs_to :tradable, polymorphic: true, optional: true

  enum :state, { open: 'OPEN', closed: 'CLOSED' }, prefix: :state

  # convenience helpers
  def instrument? = tradable_type == 'Instrument'
  def derivative? = tradable_type == 'Derivative'

  def security_id = self[:security_id] || tradable&.security_id
  def exchange_segment = self[:exchange_segment] || tradable&.exchange_segment
end


# File: app/models/scalp_session.rb
class ScalpSession < ApplicationRecord
  enum :status, { idle: 'idle', running: 'running', stopped: 'stopped', killed: 'killed' }

  validates :trade_date, presence: true
  validates :capital, :max_day_loss, :realized_pnl, :equity_peak, numericality: true

  def equity
    capital + realized_pnl
  end
end


# File: app/models/setting.rb
class Setting < ApplicationRecord
  validates :key, presence: true, uniqueness: true

  # Cached read
  def self.fetch(key, default = nil, ttl: 30)
    Rails.cache.fetch("setting:#{key}", expires_in: ttl.seconds) do
      find_by(key:)&.value || default
    end
  end

  # Write + cache bust
  def self.put(key, value)
    rec = find_or_initialize_by(key:)
    rec.value = value.to_s
    rec.save!
    Rails.cache.delete("setting:#{key}")
    value
  end

  # Typed helpers (quality of life)
  def self.fetch_i(key, default = 0) = fetch(key, default).to_i
  def self.fetch_f(key, default = 0.0) = fetch(key, default).to_f

  def self.fetch_bool(key, default = false) # rubocop:disable Style/OptionalBooleanParameter,Naming/PredicateMethod
    raw = fetch(key, default)
    return !!raw if [true, false].include?(raw)

    %w[1 true yes on].include?(raw.to_s.strip.downcase)
  end
end

# File: app/services/algo_runner.rb
class AlgoRunner
  def self.execute_all
    Instrument.watchlist.find_each do |inst|
      result = Strategies::BasicTrendStrategy.call(inst)
      case result
      when :buy_ce
        Execution::OrderExecutor.buy_option_ce(inst)
      end
    end
  end
end

# File: app/services/analysis/options_behaviour_analyzer.rb
module Analysis
  class OptionsBehaviourAnalyzer < ApplicationService
    def initialize(option_chain:, expiry:, underlying_spot:, symbol:, historical: [])
      @chain = option_chain.with_indifferent_access
      @expiry = expiry
      @spot = underlying_spot
      @symbol = symbol
      @historical = historical
    end

    def call
      atm = determine_atm
      return nil unless atm

      analysis = {
        symbol: @symbol,
        expiry: @expiry,
        spot: @spot,
        atm: atm,
        ce: extract_behaviour_data(atm, :ce),
        pe: extract_behaviour_data(atm, :pe),
        time: Time.zone.now
      }

      notify("ðŸ§  Behaviour Data Prepared for #{@symbol}\n\n#{analysis.inspect.truncate(1200)}", tag: 'OPTIONS_BEHAVIOUR')

      analysis
    end

    private

    def determine_atm
      @chain[:oc].keys.map(&:to_f).min_by { |s| (@spot - s).abs }
    end

    def extract_behaviour_data(strike, side)
      data = @chain[:oc][format('%.6f', strike)][side.to_s]
      return {} unless data

      {
        last_price: data['last_price'],
        iv: data['implied_volatility'],
        delta: data.dig('greeks', 'delta'),
        gamma: data.dig('greeks', 'gamma'),
        theta: data.dig('greeks', 'theta'),
        vega: data.dig('greeks', 'vega'),
        oi: data['oi'],
        volume: data['volume'],
        price_change: data['last_price'].to_f - data['previous_close_price'].to_f,
        oi_change: data['oi'].to_i - data['previous_oi'].to_i
      }
    end
  end
end

# File: app/services/application_service.rb
# frozen_string_literal: true

class ApplicationService
  def self.call(...)
    new(...).call
  end

  private

  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
  # ðŸ“£ Telegram Integration
  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

  def notify_step(step, message = nil)
    notify("ðŸ”¹ Step: #{step}\n#{message || '...'}", tag: step.to_s.upcase)
  end

  def notify_success(message = 'âœ… Step completed successfully')
    notify(message, tag: 'SUCCESS')
  end

  def notify_failure(error, step = nil)
    notify("âŒ Failure#{" at #{step}" if step}: #{error.class} â€“ #{error.message}", tag: 'FAILURE')
  end

  def notify(message, tag: nil)
    context = "[#{self.class.name}]"
    final_message = tag.present? ? "#{context} [#{tag}] \n\n #{message}" : "#{context} #{message}"
    TelegramNotifier.send_message(final_message)
  rescue StandardError => e
    log_error("Telegram Notify Failed: #{e.class} - #{e.message}")
  end

  def typing_ping
    TelegramNotifier.send_chat_action(chat_id: nil, action: 'typing')
  rescue StandardError => e
    log_error("Telegram Typing Action Failed: #{e.class} - #{e.message}")
  end

  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
  # ðŸ§¾ Logging Helpers (auto-prefix with class name)
  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

  %i[info warn error debug].each do |lvl|
    define_method("log_#{lvl}") do |msg|
      Rails.logger.send(lvl, "[#{self.class.name}] #{msg}")
    end
  end
end

# File: app/services/bars/fetch_loop.rb
# frozen_string_literal: true

module Bars
  class FetchLoop
    class << self
      def start(symbols:, timeframe: '1m', &on_series)
        stop
        @running = true
        @thread = Thread.new do
          while @running
            begin
              tick = Time.current
              symbols.each do |sym|
                inst = Instrument.segment_index.find_by(symbol_name: sym) || Instrument.segment_equity.find_by(display_name: sym)
                next unless inst

                raw = inst.intraday_ohlc(interval: interval_for(timeframe), days: 20)
                next if raw.blank?

                series = CandleSeries.new(symbol: inst.symbol_name, interval: interval_for(timeframe))
                series.load_from_raw(raw)
                on_series&.call(sym, series)
              end
            rescue StandardError => e
              Rails.logger.error("[Bars::FetchLoop] #{e.class}: #{e.message}")
            ensure
              sleep sleep_to_next_bar(timeframe, from: tick)
            end
          end
        end
      end

      def stop
        @running = false
        @thread&.kill
        @thread = nil
      end

      private

      def interval_for(tf)
        case tf.to_s
        when '1m' then '1'
        when '3m' then '3'
        when '5m' then '5'
        when '15m' then '15'
        else '1'
        end
      end

      def sleep_to_next_bar(tf, from:)
        secs = case tf.to_s
               when '1m'  then 60
               when '3m'  then 180
               when '5m'  then 300
               when '15m' then 900
               else 60
               end
        drift  = (Time.current - from).to_f
        remain = secs - (from.to_i % secs)
        [remain + 2 - drift, 5].max
      end
    end
  end
end


# File: app/services/broker/reconcile_light.rb
# app/services/broker/reconcile_light.rb
module Broker
  class ReconcileLight < ApplicationService
    def call
      reconcile_positions
      reconcile_orders # optional; super orders list is useful
    end

    def reconcile_positions
      broker = DhanHQ::Models::Position.all # GET /v2/positions
      seen = {}
      broker.each do |p|
        seg = p.exchange_segment; sid = p.security_id; prod = p.product_type
        k = State::PositionCache.key(seg:, sid:, prod:)
        seen[k] = true

        State::PositionCache.upsert!(
          seg:, sid:, prod:,
          attrs: {
            trading_symbol: p.trading_symbol,
            net_qty:        p.net_qty.to_i,
            buy_avg:        p.buy_avg.to_f,
            sell_avg:       p.sell_avg.to_f,
            realized:       p.realized_profit.to_f,
            unrealized:     p.unrealized_profit.to_f,
            external:       external?(k) # mark external if not in local orders
          }
        )
      end

      # remove closed entries
      State::PositionCache.fetch_all.keys.each do |k|
        State::PositionCache.delete!(**split(k)) unless seen[k]
      end
    end

    def reconcile_orders
      # optional: only when you need status or leg details
      supers = DhanHQ::Models::SuperOrder.all # GET /v2/super/orders
      supers.each do |o|
        cref = o["correlationId"]
        next unless cref
        State::OrderCache.put!(cref, {
          client_ref: cref,
          broker_order_id: o["orderId"],
          status: o["orderStatus"],
          quantity: o["quantity"].to_i,
          filled_qty: o["filledQty"].to_i,
          remaining_quantity: o["remainingQuantity"].to_i,
          target_price: o.dig("legDetails")&.find{_1["legName"]=="TARGET_LEG"}&.[]("price"),
          stop_loss_price: o.dig("legDetails")&.find{_1["legName"]=="STOP_LOSS_LEG"}&.[]("price"),
          trailing_jump: o.dig("legDetails")&.find{_1["legName"]=="STOP_LOSS_LEG"}&.[]("trailingJump")
        }.compact)
      end
    end

    def split(k)
      seg, sid, prod = k.split(":")
      { seg:, sid: sid.to_i, prod: }
    end

    def external?(k)
      # If no local order references this pos key recently, consider it external
      State::OrderCache.fetch_all.values.none? { |o| o[:pos_key] == k }
    end
  end
end


# File: app/services/derivatives/picker.rb
# frozen_string_literal: true

# app/services/derivatives/picker.rb
#
# Orchestrates "what to trade" for AutoPilot:
#  - fetch nearest-expiry option chain for an underlying
#  - compute iv_rank (0..1) for current chain
#  - call Option::ChainAnalyzer (your advanced scorer) to gate & rank strikes
#  - resolve the chosen strike into a tradable Derivative (security_id, lot_size)
#
# Returns Result struct or nil.
#
# Usage:
#   pick = Derivatives::Picker.call(
#     instrument: nifty,                # AR Instrument
#     side: :ce,                        # :ce or :pe (bullish=ce / bearish=pe)
#     strategy_type: 'intraday',        # 'intraday' or 'swing'
#     expiry: nil,                      # default nearest expiry
#     signal_strength: 1.0              # optional multiplier into analyzer
#   )
#   if pick
#     pick.derivative   # => AR Derivative (has security_id, lot_size)
#     pick.selected     # => Hash from analyzer (strike_price, last_price, iv, greeksâ€¦)
#     pick.ranked       # => Top-N ranked array from analyzer
#     pick.side         # => :ce / :pe
#     pick.expiry       # => Date
#   end
#
module Derivatives
  class Picker < ApplicationService
    Result = Struct.new(:selected, :ranked, :derivative, :expiry, :side, :iv_rank, keyword_init: true)

    def initialize(instrument:, side:, strategy_type: 'intraday', expiry: nil, signal_strength: 1.0)
      @instrument      = instrument
      @side            = side.to_s.downcase.to_sym # :ce or :pe
      @strategy_type   = strategy_type.to_s
      @signal_strength = signal_strength.to_f
      @expiry          = expiry || safe_nearest_expiry_for(instrument)
    end

    def call
      return nil unless @instrument && %i[ce pe].include?(@side) && @expiry

      chain = fetch_chain(@expiry)
      return nil unless chain && chain[:oc].present?

      iv_rank = iv_rank_for(chain)

      analyzer = Option::ChainAnalyzer.new(
        chain,
        expiry: @expiry,
        underlying_spot: (chain[:last_price].presence || ltp(@instrument)).to_f,
        iv_rank: iv_rank,
        historical_data: historical_data
      )
      res = analyzer.analyze(signal_type: @side, strategy_type: @strategy_type, signal_strength: @signal_strength)
      return nil unless res[:proceed] && res[:selected]

      drv = resolve_derivative(res[:selected], @expiry, @side)
      return nil unless drv

      Result.new(
        selected: res[:selected],
        ranked: res[:ranked],
        derivative: drv,
        expiry: @expiry,
        side: @side,
        iv_rank: iv_rank
      )
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] #{e.class} â€“ #{e.message}")
      nil
    end

    # ------------------------------------------------------------------------
    private

    def fetch_chain(expiry)
      @instrument.fetch_option_chain(expiry)
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] chain fetch failed for #{expiry}: #{e.message}")
      nil
    end

    def safe_nearest_expiry_for(inst)
      list = Array(inst.expiry_list)
      list.first if list.any?
    rescue StandardError
      nil
    end

    def ltp(inst)
      Live::TickCache.ltp(inst.exchange_segment, inst.security_id) || inst.ltp
    rescue StandardError
      nil
    end

    # Normalizes current IV within chain range â†’ rank âˆˆ [0,1].
    def iv_rank_for(chain)
      oc = chain[:oc] || {}
      spot = (chain[:last_price] || 0).to_f
      return 0.5 if oc.empty? || spot <= 0

      strikes = oc.keys.map(&:to_f)
      atm     = strikes.min_by { |s| (s - spot).abs }
      return 0.5 unless atm

      atm_k = format('%.6f', atm)
      ce_iv = oc.dig(atm_k, 'ce', 'implied_volatility').to_f
      pe_iv = oc.dig(atm_k, 'pe', 'implied_volatility').to_f
      current = [ce_iv, pe_iv].select(&:positive?).then { |a| a.empty? ? 0 : a.sum / a.size }

      all = oc.values.flat_map { |row| %w[ce pe].map { |k| row.dig(k, 'implied_volatility').to_f } }.reject(&:zero?)
      return 0.5 if all.empty? || all.max == all.min

      ((current - all.min) / (all.max - all.min)).clamp(0.0, 1.0).round(3)
    rescue StandardError
      0.5
    end

    def historical_data
      if @strategy_type == 'intraday'
        intraday_candles
      else
        daily_candles
      end
    end

    def daily_candles
      Dhanhq::API::Historical.daily(
        securityId: @instrument.security_id,
        exchangeSegment: @instrument.exchange_segment,
        instrument: @instrument.instrument_type,
        fromDate: 45.days.ago.to_date,
        toDate: Date.yesterday
      )
    rescue StandardError
      []
    end

    def intraday_candles
      Dhanhq::API::Historical.intraday(
        securityId: @instrument.security_id,
        exchangeSegment: @instrument.exchange_segment,
        instrument: @instrument.instrument_type,
        interval: '5',
        fromDate: 5.days.ago.to_date.iso8601,
        toDate: Time.zone.today.iso8601
      )
    rescue StandardError
      []
    end

    def resolve_derivative(selected, expiry, side)
      @instrument.derivatives.find_by(
        strike_price: selected[:strike_price],
        expiry_date: expiry,
        option_type: side.to_s.upcase # 'CE' / 'PE'
      )
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] derivative lookup failed: #{e.message}")
      nil
    end
  end
end


# File: app/services/execution/order_executor.rb
module Execution
  class OrderExecutor
    def self.buy_option_ce(instrument)
      # Derive CE option symbol from spot instrument
      derivative = DerivativePicker.pick_ce(instrument)

      order = DhanHQ::Models::Order.new(
        transaction_type: 'BUY',
        exchange_segment: 'NSE_FNO',
        product_type: 'INTRADAY',
        order_type: 'MARKET',
        validity: 'DAY',
        security_id: derivative.security_id,
        quantity: derivative.lot_size
      )

      order.save
    end
  end
end

# File: app/services/execution/position_guard.rb
module Execution
  class PositionGuard
    TICK_INTERVAL_MS = 200 # safety if you rate-limit checks

    PositionState = Struct.new(
      :security_id, :segment, :entry_price, :peak_price, :entered_at,
      :trailing_mode, :underlying_symbol, :last_underlying_high_ts, :last_underlying_high
    )

    class << self
      def start(budget)
        @budget = budget
        @states = {}
        @mutex  = Mutex.new
        @running = true
        boot_ws_handlers
      end

      def stop
        @running = false
      end

      def register_intent(intent)
        state = PositionState.new(
          intent.security_id,
          intent.exchange_segment,
          BigDecimal(intent.entry_price.to_s),
          BigDecimal(intent.entry_price.to_s),
          Time.current,
          false,
          intent.underlying_symbol,
          Time.current,
          nil
        )
        @mutex.synchronize { @states[key(intent)] = state }
      end

      private

      def key(intent_or_state)
        "#{intent_or_state.segment}:#{intent_or_state.security_id}"
      end

      def boot_ws_handlers
        # Hook into your WS tick stream
        DhanHQ::WS::Bus.on_tick do |tick|
          next unless @running

          handle_tick(tick)
        end
      end

      def handle_tick(tick)
        k = "#{tick.segment}:#{tick.security_id}"
        state = @states[k]
        return unless state

        ltp = BigDecimal(tick.ltp.to_s)
        return if ltp <= 0

        # Peak tracking
        state.peak_price = [state.peak_price, ltp].max

        # Flip to trailing mode once profit exceeds max(1%, â‚¹1000)
        profit_pct = (ltp - state.entry_price) / state.entry_price
        if !state.trailing_mode && (profit_pct >= 0.01 || (ltp - state.entry_price) * lot_size_for(state) >= @budget.profit_trigger_rupees)
          state.trailing_mode = true
        end

        # Hard SL: 10% from entry
        if ltp <= state.entry_price * BigDecimal('0.90')
          exit_and_finalize!(state, reason: :hard_sl)
          return
        end

        # Time stop: 3 minutes and not green
        if Time.current - state.entered_at >= 3.minutes && ltp <= state.entry_price
          exit_and_finalize!(state, reason: :time_stop)
          return
        end

        # Trailing exit: 1% drop from peak once trailing_mode
        return unless state.trailing_mode && ltp <= state.peak_price * BigDecimal('0.99')

        exit_and_finalize!(state, reason: :trail_hit)
        nil

        # Optional: consolidation on underlying (update via separate underlying feed)
        # if no new underlying high for 2+ bars, consider exit
        # Pseudocode placeholders:
        # if underlying_consolidating?(state.underlying_symbol)
        #   exit_and_finalize!(state, reason: :underlying_consolidation)
        # end
      end

      def lot_size_for(state)
        # Look up derivative by security_id if needed; fallback 1
        Derivative.find_by(security_id: state.security_id)&.lot_size.to_i.nonzero? || 1
      end

      def exit_and_finalize!(state, reason:)
        # If super order placed â†’ modify/cancel bracket; else market exit
        Orders::Manager.exit_position!(security_id: state.security_id, segment: state.segment, reason: reason)
        # Compute realized_pnl from broker or internal calc
        realized = Orders::Analyzer.realized_pnl_for(state.security_id, state.segment) # returns decimal â‚¹
        @budget.on_trade_closed!(realized_pnl: realized)
        @mutex.synchronize { @states.delete("#{state.segment}:#{state.security_id}") }
        CloseStrikesManager.unsubscribe_if_unused(state.security_id, state.segment)
      rescue StandardError => e
        Rails.logger.error("[PositionGuard] exit failed #{state.inspect} #{e.class}: #{e.message}")
      end
    end
  end
end

# File: app/services/exits/alignment_guard.rb
# app/services/exits/alignment_guard.rb
class Exits::AlignmentGuard < ApplicationService
  def initialize(order:, underlying_symbol:)
    @order = order
    @symbol = underlying_symbol
  end

  def call
    inst = Instrument.segment_index.find_by(symbol_name: @symbol) || Instrument.segment_equity.find_by(display_name: @symbol)
    return true unless inst

    sig = inst.supertrend_signal(interval: '5') # :long_entry / :short_entry
    return true unless sig

    long = (@order.side.to_s == 'buy') # we buy premium for CE/PE
    # If CE â†’ need long_entry; if PE â†’ need short_entry; otherwise suggest exit
    return (sig == :long_entry) if @order.cp == 'CE'
    return (sig == :short_entry) if @order.cp == 'PE'

    true
  end
end


# File: app/services/exits/micro_tp.rb
# app/services/exits/micro_tp.rb
# Tightens TP and arms BE when live conditions indicate chop after entry.
class Exits::MicroTP < ApplicationService
  # order: Order with super_ref, tp_value, trail_sl_value, entry_price
  # ltp:   current premium
  # entry_ts: Time the position was opened
  # side: :buy_ce or :buy_pe (profit when premium rises for both)
  def initialize(order:, ltp:, entry_ts:, side:)
    @order     = order
    @ltp       = ltp.to_f
    @entry_ts  = entry_ts || Time.now
    @side      = side
    @entry_pr  = order.entry_price.to_f
    @r         = (@entry_pr * 0.25) # 25% SL baseline â†’ 1R
  end

  def call
    return unless valid_order?

    mfe_r   = [(@ltp - @entry_pr) / (@r.nonzero? || 1.0), 0].max
    stalled = stalled_seconds >= 180 # â‰¥ 3 minutes inside deadband
    spreadp = spread_pct || 0.0

    if chop_live?(mfe_r:, stalled:, spreadp:)
      tighten_tp!
      arm_break_even!
    end

    time_stop!
  rescue StandardError => e
    Rails.logger.warn("[MicroTP] #{e.class} #{e.message}")
  end

  private

  def valid_order?
    @order&.super_ref.present? && @entry_pr.positive?
  end

  def chop_live?(mfe_r:, stalled:, spreadp:)
    # < 0.5R after 5 minutes OR stalled 3m OR spread% > 0.8
    return true if (Time.now - @entry_ts) > 300 && mfe_r < 0.5
    return true if stalled
    return true if spreadp > 0.8

    false
  end

  def tighten_tp!
    # Target: entry + 0.30R from entry premium (or keep current if tighter)
    target = PriceMath.round_tick(@entry_pr + (@r * 0.30))
    cur    = @order.tp_value.to_f
    return if cur.positive? && target >= cur # only tighten (lower TP level)

    Orders::SuperModifier.call(order: @order, new_tp_value: target)
  end

  def arm_break_even!
    # Raise trailing SL to slightly below entry (e.g., entry - 0.10R)
    be = PriceMath.round_tick(@entry_pr - (@r * 0.10))
    cur = @order.trail_sl_value.to_f
    return if cur.positive? && be <= cur # only raise/tighten trail

    Orders::SuperModifier.call(order: @order, new_trail_sl_value: be)
  end

  def time_stop!
    # Hard time stop at 8 minutes with no TP hit
    return unless (Time.now - @entry_ts) > 480

    begin
      DhanHQ::SuperOrders.close(super_order_id: @order.super_ref)
    rescue StandardError
      nil
    end
  end

  # ---- stall & spread helpers ----

  # Tracks last "meaningful move" (> 0.1R) in Rails.cache per order
  def stalled_seconds
    key = "stall:#{@order.super_ref}"
    last = Rails.cache.fetch(key) do
      { ltp: @ltp, ts: Time.now }
    end

    if (@ltp - last[:ltp]).abs >= (@r * 0.10)
      Rails.cache.write(key, { ltp: @ltp, ts: Time.now }, expires_in: 1.hour)
      0
    else
      (Time.now - (last[:ts] || Time.now)).to_i
    end
  end

  def spread_pct
    # Try to read bid/ask via your quote source; fallback to modest value
    quote = safe { Live::Quote.get(@order.instrument.exchange_segment, @order.instrument.security_id) } ||
            safe { DhanHQ::MarketData.quote(@order.instrument.security_id) }
    return 0.4 unless quote

    bid = quote[:bid].to_f
    ask = quote[:ask].to_f
    mid = [(bid + ask) / 2.0, @ltp].compact.max
    return 0.4 if mid <= 0 || ask <= 0 || bid <= 0

    (((ask - bid).abs / mid) * 100.0).round(2)
  rescue StandardError
    0.4
  end

  def safe(&)
    yield
  rescue StandardError
    nil
  end
end


# File: app/services/indicators/breaker_block.rb
module Indicators
  class BreakerBlock
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def identify
      breakers = []

      @candles.each_with_index do |candle, i|
        next if i < 5

        prev = @candles[i - 1]
        before_prev = @candles[i - 2]

        # 1ï¸âƒ£ Detect bullish breaker (failed bullish OB -> turns bearish)
        if bullish_ob_fail?(before_prev, prev, candle)
          breakers << {
            type: :bearish_breaker,
            breaker_zone: { high: before_prev.high, low: before_prev.low },
            broken_at: candle.timestamp,
            retest_pending: true
          }
        end

        # 2ï¸âƒ£ Detect bearish breaker (failed bearish OB -> turns bullish)
        next unless bearish_ob_fail?(before_prev, prev, candle)

        breakers << {
          type: :bullish_breaker,
          breaker_zone: { high: before_prev.high, low: before_prev.low },
          broken_at: candle.timestamp,
          retest_pending: true
        }
      end

      breakers
    end

    private

    def bullish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bullish? &&
        next_candle.low < ob.low &&         # OB invalidated
        breaker_candle.close > ob.high      # Breaker confirmation
    end

    def bearish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bearish? &&
        next_candle.high > ob.high &&       # OB invalidated
        breaker_candle.close < ob.low       # Breaker confirmation
    end
  end
end

# File: app/services/indicators/calculator.rb
module Indicators
  class Calculator
    def initialize(series)
      @series = series
    end

    def rsi(period = 14)
      RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: @series.closes, period:).call
    end

    def macd
      RubyTechnicalAnalysis::Macd.new(series: @series.closes).call
    end

    def adx(period = 14)
      hlc = @series.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end
      TechnicalAnalysis::Adx.calculate(hlc, period:).last.adx
    end

    def bullish_signal?
      rsi < 30 && adx > 20 && @series.closes.last > @series.closes[-2]
    end

    def bearish_signal?
      rsi > 70 && adx > 20 && @series.closes.last < @series.closes[-2]
    end
  end
end

# File: app/services/indicators/fair_value_gap.rb
module Indicators
  class FairValueGap
    def initialize(series)
      @series = series
    end

    def detect
      fvg_zones = []
      @series.each_cons(3).with_index do |(c1, _c2, c3), i|
        if c3.low > c1.high
          fvg_zones << { index: i + 1, from: c1.high, to: c3.low, direction: :up }
        elsif c3.high < c1.low
          fvg_zones << { index: i + 1, from: c3.high, to: c1.low, direction: :down }
        end
      end
      fvg_zones
    end
  end
end


# File: app/services/indicators/holy_grail.rb
# app/services/indicators/holy_grail.rb
# frozen_string_literal: true

require 'ruby_technical_analysis'
require 'technical_analysis'

module Indicators
  class HolyGrail < ApplicationService
    RTA = RubyTechnicalAnalysis
    TA  = TechnicalAnalysis

    EMA_FAST  = 34
    EMA_SLOW  = 100
    RSI_LEN   = 14
    ADX_LEN   = 14
    ATR_LEN   = 20
    MACD_F = 12
    MACD_S = 26
    MACD_SIG = 9

    # ------------------------------------------------------------------
    # Result struct keeps the four â€œgateâ€ keys first,
    # then the raw indicators you already logged elsewhere.
    # ------------------------------------------------------------------
    Result = Struct.new(
      :bias, :adx, :momentum, :proceed?,
      :sma50, :ema200, :rsi14, :atr14, :macd, :trend,
      keyword_init: true
    ) do
      def to_h = members.zip(values).to_h
    end

    # ------- ctor -----------------------------------------------------
    def initialize(candles:)
      @candles = candles # Dhan hash-of-arrays
      raise ArgumentError, "need â‰¥ #{EMA_SLOW} candles" if closes.size < EMA_SLOW
    end

    # ------- main -----------------------------------------------------
    def call
      sma50  = sma(EMA_FAST)
      ema200 = ema(EMA_SLOW)
      rsi14  = rsi(RSI_LEN)
      macd_h = macd_hash
      adx14  = adx(ADX_LEN)
      atr14  = atr(ATR_LEN)

      bias =
        if    sma50 > ema200 then :bullish
        elsif sma50 < ema200 then :bearish
        else
          :neutral
        end

      momentum =
        if macd_h[:macd] > macd_h[:signal] && rsi14 > 50
          :up
        elsif macd_h[:macd] < macd_h[:signal] && rsi14 < 50
          :down
        else
          :flat
        end

      proceed =
        case bias
        when :bullish
          passed = adx14 >= 20.0 && momentum == :up
          Rails.logger.debug { "[HolyGrail] Not proceeding (bias: bullish): adx=#{adx14}, momentum=#{momentum}" } unless passed
          passed
        when :bearish
          passed = adx14 >= 20.0 && momentum == :down
          Rails.logger.debug { "[HolyGrail] Not proceeding (bias: bearish): adx=#{adx14}, momentum=#{momentum}" } unless passed
          passed
        else
          Rails.logger.debug { "[HolyGrail] Not proceeding (bias: #{bias}): neutral bias, adx=#{adx14}, momentum=#{momentum}" }
          false
        end

      latest_time = Time.zone.at(stamps.last)
      Rails.logger.debug { "[HolyGrail] (#{latest_time}) Not proceeding ..." }
      trend =
        if ema200 < closes.last && sma50 > ema200 then :up
        elsif ema200 > closes.last && sma50 < ema200 then :down
        else
          :side
        end

      Result.new(
        bias:, adx: adx14, momentum:, proceed?: proceed,
        sma50:, ema200:, rsi14:, atr14:, macd: macd_h, trend:
      )
    end

    # ------- helpers --------------------------------------------------
    private

    def closes = @candles['close'].map(&:to_f)
    def highs  = @candles['high'].map(&:to_f)
    def lows   = @candles['low'].map(&:to_f)
    def stamps = @candles['timestamp'] || []

    # ---------- rows with :date_time required by technical_analysis ---
    def ohlc_rows
      @ohlc_rows ||= highs.each_index.map do |i|
        {
          date_time: Time.zone.at(stamps[i] || 0), # <- NEW
          high: highs[i],
          low: lows[i],
          close: closes[i]
        }
      end
    end

    # â€” ruby-technical-analysis â€”
    def sma(len) = closes.last(len).sum / len.to_f
    def ema(len) = RTA::MovingAverages.new(series: closes, period: len).ema
    def rsi(len) = RTA::RelativeStrengthIndex.new(series: closes, period: len).call

    def macd_hash
      m, s, h = RTA::Macd.new(series: closes,
                              fast_period: MACD_F,
                              slow_period: MACD_S,
                              signal_period: MACD_SIG).call
      { macd: m, signal: s, hist: h }
    end

    # â€” technical_analysis gem â€”
    def atr(len)
      TA::Atr.calculate(ohlc_rows.last(len * 2), period: len).first.atr
    end

    def adx(len)
      ad = TA::Adx.calculate(ohlc_rows.last(len * 2), period: len)
      ad.first.adx
    end
  end
end


# File: app/services/indicators/intrinio_wrapper.rb
# app/services/indicators/intrinio_wrapper.rb
module Indicators
  class IntrinioWrapper
    SUPPORTED = TechnicalAnalysis::Indicator.names.map(&:to_s)
    attr_reader :data

    def initialize(data)
      @data = data
    end

    # example: RSI
    def rsi(period: 14)
      vals = TechnicalAnalysis::Rsi.calculate(data,
                                              period: period, price_key: :close)
      vals.map(&:value)
    end

    def adx(period: 14)
      vals = TechnicalAnalysis::Adx.calculate(data, period: period, price_key: :close)
      vals.map(&:adx)
    end

    def macd(fast: 12, slow: 26, signal: 9)
      TechnicalAnalysis::Macd.calculate(data,
                                        fast_period: fast, slow_period: slow, signal_period: signal, price_key: :close)
    end

    def obv
      TechnicalAnalysis::Obv.calculate(data, price_key: :close, volume_key: :volume)
    end

    # .. auto-generate other wrappers via meta-programming if you like
    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  rescue TechnicalAnalysis::ValidationError => e
    Rails.logger.warn("[IntrinioWrapper] #{e.class}: #{e.message}")
    []
  end
end


# File: app/services/indicators/order_block.rb
module Indicators
  class OrderBlock
    def initialize(series)
      @series = series
    end

    def bullish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bearish? && next_c.bullish? && next_c.close > prev.high
      end
    end

    def bearish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bullish? && next_c.bearish? && next_c.close < prev.low
      end
    end
  end
end


# File: app/services/indicators/ruby_ta_wrapper.rb
# app/services/indicators/ruby_ta_wrapper.rb
module Indicators
  class RubyTAWrapper
    SUPPORTED = %w[
      rsi macd stochastic_intraday momentum_index chaikin_money_flow
      bollinger_bands pivot_points mass_index qstick rate_of_change
      wilders_smoothing volume_oscillator williams_r price_channel
    ].freeze
    attr_reader :series

    def initialize(series) = @series = series

    # e.g.
    def rsi(period: 14)
      t = RubyTechnicalAnalysis::RelativeStrengthIndex.new(
               series: series.closes, period: period
             )
      t.valid? ? t.call : []
    end

    def macd(fast: 12, slow: 26, signal: 9)
      t = RubyTechnicalAnalysis::MACD.new(series: series.closes,
                                          fast_period: fast, slow_period: slow, signal_period: signal)
      t.valid? ? t.call : []
    end

    # ... same pattern for other SUPPORTED indicators

    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  end
end


# File: app/services/indicators/structure.rb
module Indicators
  class Structure
    def initialize(series:)
      @series = series
    end

    def break_of_structure
      bos_points = []

      @series.candles.each_with_index do |c, i|
        if @series.swing_high?(i) && c.close < c.open
          bos_points << { index: i, type: :bos, direction: :down }
        elsif @series.swing_low?(i) && c.close > c.open
          bos_points << { index: i, type: :bos, direction: :up }
        end
      end
      bos_points
    end
  end
end


# File: app/services/indicators/supertrend.rb
module Indicators
  class Supertrend < ApplicationService
    attr_reader :series, :period, :multiplier, :supertrend_values, :candles

    def initialize(series:, period: 10, multiplier: 3.0)
      @series = series
      @candles = series.candles
      @period = period
      @multiplier = multiplier
      @supertrend_values = []
    end

    def call
      atr = calculate_atr
      return [] if atr.empty?

      supertrend = []
      trend = [] # :bullish or :bearish

      candles.each_with_index do |candle, i|
        next if i < period

        hl2 = (candle.high + candle.low) / 2.0
        upper_band = hl2 + (multiplier * atr[i])
        lower_band = hl2 - (multiplier * atr[i])

        if i == period
          supertrend[i] = upper_band
          trend[i] = :bearish
        else
          prev_close = candles[i - 1].close
          prev_supertrend = supertrend[i - 1]

          if prev_close <= supertrend[i - 1]
            supertrend[i] = [upper_band, prev_supertrend].min
            trend[i] = candle.close <= supertrend[i] ? :bearish : :bullish
          else
            supertrend[i] = [lower_band, prev_supertrend].max
            trend[i] = candle.close >= supertrend[i] ? :bullish : :bearish
          end
        end

        supertrend_values[i] = supertrend[i]
      end

      supertrend_values
    end

    private

    def calculate_atr
      tr = []
      atr = []

      candles.each_with_index do |candle, i|
        if i.zero?
          tr[i] = candle.high - candle.low
        else
          prev_close = candles[i - 1].close
          tr[i] = [
            candle.high - candle.low,
            (candle.high - prev_close).abs,
            (candle.low - prev_close).abs
          ].max
        end
      end

      # Simple Moving Average for ATR
      (0...candles.size).each do |i|
        atr[i] = if i < period
                   nil
                 else
                   tr[(i - period + 1)..i].compact.sum / period
                 end
      end

      atr
    end
  end
end


# File: app/services/instruments_importer.rb
# app/services/instruments_importer.rb
# frozen_string_literal: true

require 'csv'
require 'open-uri'

class InstrumentsImporter
  CSV_URL         = 'https://images.dhan.co/api-data/api-scrip-master-detailed.csv'
  CACHE_PATH      = Rails.root.join('tmp/dhan_scrip_master.csv') # â† NEW
  CACHE_MAX_AGE   = 24.hours # â† NEW
  VALID_EXCHANGES = %w[NSE BSE].freeze
  BATCH_SIZE      = 1_000

  class << self
    # ------------------------------------------------------------
    # Public entry point
    # ------------------------------------------------------------
    def import_from_url
      csv_text = fetch_csv_with_cache # â† NEW (was: URI.open(CSV_URL).read)
      import_from_csv(csv_text)
    end

    # ------------------------------------------------------------
    # Fetch CSV with 24-hour cache
    # ------------------------------------------------------------
    # â† NEW helper
    def fetch_csv_with_cache
      if CACHE_PATH.exist? && Time.current - CACHE_PATH.mtime < CACHE_MAX_AGE
        Rails.logger.info "Using cached CSV (#{CACHE_PATH})"
        return CACHE_PATH.read
      end

      Rails.logger.info 'Downloading fresh CSV from Dhanâ€¦'
      csv_text = URI.open(CSV_URL).read

      CACHE_PATH.dirname.mkpath
      File.write(CACHE_PATH, csv_text)
      Rails.logger.info "Saved CSV to #{CACHE_PATH}"

      csv_text
    rescue StandardError => e
      Rails.logger.warn "CSV download failed: #{e.message}"
      raise e if CACHE_PATH.exist? == false   # donâ€™t swallow if no fallback

      Rails.logger.warn 'Falling back to cached CSV (may be stale)'
      CACHE_PATH.read
    end
    private :fetch_csv_with_cache             # keep helper private

    def import_from_csv(csv_content)
      instruments_rows, derivatives_rows = build_batches(csv_content)
      Rails.logger.debug instruments_rows.size, derivatives_rows.size
      # instruments_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }
      # derivatives_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }

      import_instruments!(instruments_rows)  unless instruments_rows.empty?
      import_derivatives!(derivatives_rows)  unless derivatives_rows.empty?
    end

    private

    # ------------------------------------------------------------
    # 1. Split CSV rows
    # ------------------------------------------------------------
    def build_batches(csv_content)
      instruments = []
      derivatives = []

      CSV.parse(csv_content, headers: true).each do |row|
        next unless VALID_EXCHANGES.include?(row['EXCH_ID'])

        attrs = build_attrs(row)

        if row['SEGMENT'] == 'D'   # Derivative
          derivatives << attrs.slice(*Derivative.column_names.map(&:to_sym))
        else                       # Cash / Index
          instruments << attrs.slice(*Instrument.column_names.map(&:to_sym))
        end
      end

      [instruments, derivatives]
    end

    def build_attrs(row)
      now = Time.zone.now
      {
        security_id: row['SECURITY_ID'],
        exchange: row['EXCH_ID'],
        segment: row['SEGMENT'],
        isin: row['ISIN'],
        instrument_code: row['INSTRUMENT'],
        underlying_security_id: row['UNDERLYING_SECURITY_ID'],
        underlying_symbol: row['UNDERLYING_SYMBOL'],
        symbol_name: row['SYMBOL_NAME'],
        display_name: row['DISPLAY_NAME'],
        instrument_type: row['INSTRUMENT_TYPE'],
        series: row['SERIES'],
        lot_size: row['LOT_SIZE']&.to_i,
        expiry_date: safe_date(row['SM_EXPIRY_DATE']),
        strike_price: row['STRIKE_PRICE']&.to_f,
        option_type: row['OPTION_TYPE'],
        tick_size: row['TICK_SIZE']&.to_f,
        expiry_flag: row['EXPIRY_FLAG'],
        bracket_flag: row['BRACKET_FLAG'],
        cover_flag: row['COVER_FLAG'],
        asm_gsm_flag: row['ASM_GSM_FLAG'],
        asm_gsm_category: row['ASM_GSM_CATEGORY'],
        buy_sell_indicator: row['BUY_SELL_INDICATOR'],
        buy_co_min_margin_per: row['BUY_CO_MIN_MARGIN_PER']&.to_f,
        sell_co_min_margin_per: row['SELL_CO_MIN_MARGIN_PER']&.to_f,
        buy_co_sl_range_max_perc: row['BUY_CO_SL_RANGE_MAX_PERC']&.to_f,
        sell_co_sl_range_max_perc: row['SELL_CO_SL_RANGE_MAX_PERC']&.to_f,
        buy_co_sl_range_min_perc: row['BUY_CO_SL_RANGE_MIN_PERC']&.to_f,
        sell_co_sl_range_min_perc: row['SELL_CO_SL_RANGE_MIN_PERC']&.to_f,
        buy_bo_min_margin_per: row['BUY_BO_MIN_MARGIN_PER']&.to_f,
        sell_bo_min_margin_per: row['SELL_BO_MIN_MARGIN_PER']&.to_f,
        buy_bo_sl_range_max_perc: row['BUY_BO_SL_RANGE_MAX_PERC']&.to_f,
        sell_bo_sl_range_max_perc: row['SELL_BO_SL_RANGE_MAX_PERC']&.to_f,
        buy_bo_sl_range_min_perc: row['BUY_BO_SL_RANGE_MIN_PERC']&.to_f,
        sell_bo_sl_min_range: row['SELL_BO_SL_MIN_RANGE']&.to_f,
        buy_bo_profit_range_max_perc: row['BUY_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        sell_bo_profit_range_max_perc: row['SELL_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        buy_bo_profit_range_min_perc: row['BUY_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        sell_bo_profit_range_min_perc: row['SELL_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        mtf_leverage: row['MTF_LEVERAGE']&.to_f,
        created_at: now,
        updated_at: now
      }
    end

    # ------------------------------------------------------------
    # 3. Upsert instruments
    # ------------------------------------------------------------
    def import_instruments!(rows)
      res = Instrument.import(
        rows,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            display_name isin instrument_code instrument_type
            underlying_symbol lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Instruments: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4. Upsert derivatives
    # ------------------------------------------------------------
    def import_derivatives!(rows)
      with_parent, without_parent = attach_instrument_ids(rows)

      Rails.logger.info "Derivatives w/ parent: #{with_parent.size}"
      Rails.logger.info "Derivatives w/o parent: #{without_parent.size}"

      return if with_parent.empty?

      res = Derivative.import(
        with_parent,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            symbol_name display_name isin instrument_code instrument_type
            underlying_symbol series lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Derivatives: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4a. Attach instrument_id to each derivative row
    # ------------------------------------------------------------
    def attach_instrument_ids(rows)
      enum_to_csv = Instrument.instrument_codes

      # ðŸ”‘ lookup key = [csv_code, UNDERLYING_SYMBOL]
      lookup = Instrument.pluck(
        :id, :instrument_code, :underlying_symbol, :exchange, :segment
      ).each_with_object({}) do |(id, enum_code, sym, _exch, _seg), h|
        next if sym.blank?

        csv_code = enum_to_csv[enum_code] || enum_code # keep CSV code itself
        key      = [csv_code, sym.upcase]
        h[key]   = id
      end

      Rails.logger.debug { "lookup size: #{lookup.size}" }

      with_parent    = []
      without_parent = []
      count = 0
      rows.each do |h|
        count += 1 if h[:underlying_symbol]
        next without_parent << h if h[:underlying_symbol].blank?

        parent_code = InstrumentTypeMapping.underlying_for(h[:instrument_code]) # FUTIDX âžœ INDEX
        key         = [parent_code, h[:underlying_symbol].upcase]

        if (pid = lookup[key])
          h[:instrument_id] = pid
          with_parent << h
        else
          without_parent << h
        end
      end

      [with_parent, without_parent]
    end

    # ------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------
    def safe_date(str)
      Date.parse(str)
    rescue StandardError
      nil
    end

    def map_segment(char)
      { 'I' => 'index', 'E' => 'equity', 'C' => 'currency',
        'D' => 'derivatives', 'M' => 'commodity' }[char] || char.downcase
    end
  end
end

# File: app/services/live/quote.rb
# frozen_string_literal: true

module Live
  class Quote
    # Returns { ltp:, bid:, ask:, ts: } using TickCache first; depth API fallback.
    def self.get(exchange_segment, security_id)
      # 1) WebSocket tick if we have it
      tick = begin
        Live::TickCache.get(exchange_segment, security_id)
      rescue StandardError
        nil
      end
      if tick
        bid = (tick[:best_bid_price] || tick[:bid]).to_f
        ask = (tick[:best_ask_price] || tick[:ask]).to_f
        ltp = (tick[:ltp] || tick[:last_price]).to_f
        return { ltp: ltp, bid: bid, ask: ask, ts: Time.zone.now } if ltp.positive?
      end

      # 2) REST quote fallback
      depth = begin
        DhanHQ::Models::MarketFeed.depth(exchange_segment: exchange_segment, security_id: security_id)
      rescue StandardError
        nil
      end
      if depth
        best_bid = Array(depth[:bids]).first&.dig(:price).to_f
        best_ask = Array(depth[:asks]).first&.dig(:price).to_f
        ltp      = depth[:last_traded_price].to_f.nonzero? || depth[:ltp].to_f
        return { ltp: ltp, bid: best_bid, ask: best_ask, ts: Time.zone.now }
      end

      # 3) as a last resort â€” plain LTP
      ltp = begin
        Dhanhq::API::Quote.ltp(security_id)
      rescue StandardError
        nil
      end
      return { ltp: ltp.to_f, bid: nil, ask: nil, ts: Time.zone.now } if ltp

      nil
    end
  end
end


# File: app/services/live/tick_cache.rb
# frozen_string_literal: true

require 'concurrent'

module Live
  class TickCache
    MAP = Concurrent::Map.new

    def self.put(t)
      MAP["#{t[:segment]}:#{t[:security_id]}"] = t
    end

    def self.get(segment, security_id)
      MAP["#{segment}:#{security_id}"]
    end

    def self.ltp(segment, security_id)
      MAP["#{segment}:#{security_id}"]&.dig(:ltp)
    end

    def self.clear
      MAP.clear
    end
  end
end


# File: app/services/live/ws_hub.rb
# frozen_string_literal: true

require 'singleton'
require 'concurrent'

module Live
  class WsHub
    include Singleton

    def initialize
      @running  = Concurrent::AtomicBoolean.new(false)
      @client   = nil
      @subs     = Concurrent::Set.new # "SEG:SID"
      @handlers = Concurrent::Array.new
    end

    def start!(mode: :quote)
      return self if @running.true?

      @client = DhanHQ::WS::Client.new(mode: mode).start
      @client.on(:tick) { |t| handle_tick(t) }
      @running.make_true
      self
    end

    def stop!
      return self unless @running.true?

      @running.make_false
      @client&.disconnect! # graceful + no reconnect
      @client = nil
      self
    end

    # Subscribe single instrument (idempotent)
    def subscribe(seg:, sid:)
      key = k(seg, sid)
      return self if @subs.include?(key)

      @subs.add(key)
      @client&.subscribe_one(segment: seg, security_id: sid)
      self
    end

    # Unsubscribe (if you want to shrink the stream)
    def unsubscribe(seg:, sid:)
      key = k(seg, sid)
      return self unless @subs.include?(key)

      @subs.delete(key)
      @client&.unsubscribe_one(segment: seg, security_id: sid)
      self
    end

    # Convenient multi-subscribe
    def subscribe_many(list)
      list.each { |h| subscribe(seg: h[:segment] || h['segment'], sid: h[:security_id] || h['security_id']) }
      self
    end

    # Register per-app tick listener (non-blocking please)
    def on_tick(&blk)
      @handlers << blk
      self
    end

    # Subscribe all currently-open positions (call on boot if desired)
    def subscribe_from_open_positions!
      Position.where(status: %w[OPEN ACTIVE LIVE]).pluck(:exchange_segment, :security_id).each do |seg, sid|
        subscribe(seg: seg, sid: sid.to_s)
      end
      self
    end

    private

    def handle_tick(t)
      TickCache.put(t) # global last-known tick
      begin
        ActiveSupport::Notifications.instrument('tick.dhanhq', tick: t)
      rescue StandardError
        nil
      end
      # Local handlers
      @handlers.each do |h|
        h.call(t)
      rescue StandardError
        nil
      end
    end

    def k(seg, sid) = "#{seg}:#{sid}"
  end
end


# File: app/services/market_calendar.rb
module MarketCalendar
  MARKET_HOLIDAYS = [
    # Add static or API-fetched holiday dates here
    Date.new(2025, 8, 15)
    # ...
  ]

  def self.trading_day?(date)
    weekday = date.on_weekday?
    !MARKET_HOLIDAYS.include?(date) && weekday
  end

  def self.last_trading_day(from: Time.zone.today)
    date = from
    date -= 1 until trading_day?(date)
    date
  end

  def self.today_or_last_trading_day
    trading_day?(Time.zone.today) ? Time.zone.today : last_trading_day
  end
end


# File: app/services/mtf/fvg.rb
# frozen_string_literal: true

module Mtf
  class Fvg
    Gap = Struct.new(:dir, :i, :hi, :lo, keyword_init: true) # dir :up/:down, i = middle bar index

    # Classic 3-candle Fvg:
    #  up: low[i+1] > high[i-1]
    # down: high[i+1] < low[i-1]
    def self.scan(series, lookback: 30)
      out = []
      bars = series.candles
      return out if bars.size < 3

      start = [0, bars.size - lookback - 1].max
      (start...(bars.size - 1)).each do |i|
        prev = begin
          bars[i - 1]
        rescue StandardError
          nil
        end
        nxt = begin
          bars[i + 1]
        rescue StandardError
          nil
        end
        next unless prev && nxt

        if nxt.low > prev.high
          out << Gap.new(dir: :up, i: i, hi: prev.high, lo: nxt.low)
        elsif nxt.high < prev.low
          out << Gap.new(dir: :down, i: i, hi: nxt.high, lo: prev.low)
        end
      end
      out
    end

    def self.price_in_gap?(gap, price)
      return false unless gap

      price > gap.hi && price < gap.lo
    end
  end
end


# File: app/services/mtf/liquidity.rb
# frozen_string_literal: true

module Mtf
  class Liquidity
    Pool = Struct.new(:kind, :i1, :i2, :level, keyword_init: true) # :eq_highs/:eq_lows

    def self.equal_highs(series, tol_pct: 0.0005, lookback: 40)
      scan(series, :high, :eq_highs, tol_pct: tol_pct, lookback: lookback)
    end

    def self.equal_lows(series, tol_pct: 0.0005, lookback: 40)
      scan(series, :low, :eq_lows, tol_pct: tol_pct, lookback: lookback)
    end

    def self.scan(series, field, kind, tol_pct:, lookback:)
      bars = series.candles.last(lookback)
      out  = []
      (0...(bars.size - 1)).each do |i|
        a = bars[i].public_send(field)
        b = bars[i + 1].public_send(field)
        next if [a, b].any?(&:nil?)

        tol = [a, b].max * tol_pct
        out << Pool.new(kind: kind, i1: i, i2: i + 1, level: (a + b) / 2.0) if (a - b).abs <= tol
      end
      out
    end
  end
end

# File: app/services/mtf/order_block.rb
# frozen_string_literal: true

module Mtf
  class OrderBlock
    Zone = Struct.new(:kind, :index, :open, :high, :low, :close, keyword_init: true) # kind: :demand/:supply

    # last down candle before up-BOS â†’ demand; last up candle before down-BOS â†’ supply
    def self.last_before_bos(series, bos_sig)
      return nil unless bos_sig&.kind == :BOS

      bars = series.candles
      i    = bars.size - 2

      if bos_sig.dir == :up
        # find last bearish candle before BOS index
        while i >= 1 && i > bos_sig.at_index - 20
          c = bars[i]
          return Zone.new(kind: :demand, index: i, open: c.open, high: c.high, low: c.low, close: c.close) if c.close < c.open

          i -= 1
        end
      else
        while i >= 1 && i > bos_sig.at_index - 20
          c = bars[i]
          return Zone.new(kind: :supply, index: i, open: c.open, high: c.high, low: c.low, close: c.close) if c.close > c.open

          i -= 1
        end
      end
      nil
    end

    # price-in-zone test (allow wick tolerance)
    def self.price_touches?(zone, price, pad_pct: 0.0005)
      return false unless zone

      lo = [zone.low, zone.open, zone.close].min
      hi = [zone.high, zone.open, zone.close].max
      pad = (hi - lo) * pad_pct
      (price >= lo - pad) && (price <= hi + pad)
    end
  end
end


# File: app/services/mtf/resampler.rb
# frozen_string_literal: true

module Mtf
  class Resampler
    Bucket = Struct.new(:ts, :o, :h, :l, :c, :vol, keyword_init: true)

    # series: CandleSeries on 1m/3m/5m; minutes: 15 / 60 / 240
    def self.to(series, minutes:)
      raise 'series empty' if series.candles.empty?

      step   = minutes * 60
      out    = []
      bucket = nil

      series.candles.each do |bar|
        t = bar.timestamp.to_i
        bt = t - (t % step) # bucket start

        if bucket.nil? || bucket.ts != bt
          out << bucket_to_candle(bucket) if bucket
          bucket = Bucket.new(ts: bt, o: bar.open, h: bar.high, l: bar.low, c: bar.close, vol: bar.volume.to_i)
        else
          bucket.h = [bucket.h, bar.high].max
          bucket.l   = [bucket.l, bar.low].min
          bucket.c   = bar.close
          bucket.vol = bucket.vol.to_i + bar.volume.to_i
        end
      end

      out << bucket_to_candle(bucket) if bucket

      CandleSeries.new(symbol: series.symbol, interval: minutes.to_s).tap do |cs|
        out.each { |c| cs.add_candle(c) }
      end
    end

    def self.bucket_to_candle(b)
      Candle.new(
        ts: Time.at(b.ts).in_time_zone,
        open: b.o,
        high: b.h,
        low: b.l,
        close: b.c,
        volume: b.vol.to_i
      )
    end
  end
end


# File: app/services/mtf/series_loader.rb
# frozen_string_literal: true

module Mtf
  class SeriesLoader
    Result = Struct.new(:m5, :m15, :h1, :h4, keyword_init: true)

    # instrument: your Instrument record
    # base_interval: '5' (weâ€™ll resample to 15/60/240)
    def self.load(instrument:, base_interval: '5')
      raw = instrument.intraday_ohlc(interval: base_interval)
      return nil if raw.blank?

      m5 = CandleSeries.new(symbol: instrument.symbol_name, interval: base_interval)
      m5.load_from_raw(raw)

      m15 = Mtf::Resampler.to(m5, minutes: 15)
      h1  = Mtf::Resampler.to(m5, minutes: 60)
      h4  = Mtf::Resampler.to(m5, minutes: 240)

      Result.new(m5: m5, m15: m15, h1: h1, h4: h4)
    end
  end
end


# File: app/services/mtf/structure.rb
# frozen_string_literal: true

module Mtf
  class Structure
    Sig = Struct.new(:kind, :at_index, :price, :dir, keyword_init: true) # kind: :BOS/:CHOCH, dir: :up/:down

    # returns :up (HH/HL) | :down (LH/LL) | :range
    def self.trend(series, lookback: 5)
      highs = series.highs.last(lookback + 3)
      lows  = series.lows.last(lookback + 3)

      return :range if highs.size < 4

      higher_highs = highs.each_cons(2).all? { |a, b| b >= a }
      higher_lows  = lows.each_cons(2).all?  { |a, b| b >= a }
      lower_highs  = highs.each_cons(2).all? { |a, b| b <= a }
      lower_lows   = lows.each_cons(2).all?  { |a, b| b <= a }

      return :up   if higher_highs && higher_lows
      return :down if lower_highs && lower_lows

      :range
    end

    # BOS = current close breaks last swing extreme in trend direction
    def self.bos(series, dir:)
      idx = series.candles.size - 1
      return nil if idx < 3

      last_close = series.candles.last.close
      swings_h   = swing_highs(series, lookback: 2).last(5)
      swings_l   = swing_lows(series,  lookback: 2).last(5)

      if dir == :up && swings_h.last && last_close > swings_h.last[:price]
        return Sig.new(kind: :BOS, at_index: idx, price: last_close, dir: :up)
      elsif dir == :down && swings_l.last && last_close < swings_l.last[:price]
        return Sig.new(kind: :BOS, at_index: idx, price: last_close, dir: :down)
      end

      nil
    end

    # CHOCH = break opposite to prior trend (simple)
    def self.choch(series, prior_dir:)
      idx = series.candles.size - 1
      last_close = series.candles.last.close
      swings_h   = swing_highs(series, lookback: 2).last(5)
      swings_l   = swing_lows(series,  lookback: 2).last(5)

      if prior_dir == :up && swings_l.last && last_close < swings_l.last[:price]
        return Sig.new(kind: :CHOCH, at_index: idx, price: last_close, dir: :down)
      elsif prior_dir == :down && swings_h.last && last_close > swings_h.last[:price]
        return Sig.new(kind: :CHOCH, at_index: idx, price: last_close, dir: :up)
      end

      nil
    end

    def self.swing_highs(series, lookback: 2)
      out = []
      series.candles.each_with_index do |c, i|
        next unless series.swing_high?(i, lookback)

        out << { i: i, price: c.high }
      end
      out
    end

    def self.swing_lows(series, lookback: 2)
      out = []
      series.candles.each_with_index do |c, i|
        next unless series.swing_low?(i, lookback)

        out << { i: i, price: c.low }
      end
      out
    end
  end
end


# File: app/services/openai/behaviour_explainer.rb
module Openai
  class BehaviourExplainer < ApplicationService
    def initialize(analysis_hash)
      @data = analysis_hash
    end

    def call
      prompt = build_prompt
      typing_ping
      completion = OpenAI::Client.new.chat(
        parameters: {
          model: 'gpt-4',
          messages: [
            { role: 'system', content: 'You are an options trading expert' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7
        }
      )
      result = completion.dig('choices', 0, 'message', 'content')
      notify("ðŸ“˜ AI Options Insight for #{@data[:symbol]}:\n\n#{result}", tag: 'AI_EXPLAIN')
      result
    rescue StandardError => e
      notify_failure(e, :openai)
      nil
    end

    def build_prompt
      <<~PROMPT
        Given the following ATM options data for #{@data[:symbol]} (#{@data[:expiry]}), analyze the market sentiment and expected move direction:

        CE:
        â€¢ Price: #{@data[:ce][:last_price]}
        â€¢ IV: #{@data[:ce][:iv]}
        â€¢ Î”: #{@data[:ce][:delta]}
        â€¢ Î¸: #{@data[:ce][:theta]}
        â€¢ OI: #{@data[:ce][:oi]}
        â€¢ Price Change: #{@data[:ce][:price_change]}

        PE:
        â€¢ Price: #{@data[:pe][:last_price]}
        â€¢ IV: #{@data[:pe][:iv]}
        â€¢ Î”: #{@data[:pe][:delta]}
        â€¢ Î¸: #{@data[:pe][:theta]}
        â€¢ OI: #{@data[:pe][:oi]}
        â€¢ Price Change: #{@data[:pe][:price_change]}

        Spot: #{@data[:spot]}
        ATM: #{@data[:atm]}

        Respond with:
        - Sentiment: Bullish / Bearish / Neutral
        - Reasoning
        - Suggested next move for CE or PE buying (if any)
      PROMPT
    end
  end
end

# File: app/services/option/chain_analyzer.rb
# frozen_string_literal: true

module Option
  class ChainAnalyzer
    IV_RANK_MIN        = 0.00
    IV_RANK_MAX        = 0.80
    THETA_AVOID_HOUR   = 14.5 # 2:30 PM
    TOP_RANKED_LIMIT   = 10

    attr_reader :option_chain, :expiry, :underlying_spot, :historical_data, :iv_rank, :ta

    def initialize(option_chain, expiry:, underlying_spot:, iv_rank:, historical_data: [])
      @option_chain     = option_chain.with_indifferent_access
      @expiry           = Date.parse(expiry.to_s)
      @underlying_spot  = underlying_spot.to_f
      @iv_rank          = iv_rank.to_f
      @historical_data  = historical_data || []
      @ta = (Indicators::HolyGrail.call(candles: historical_data) if historical_data.present?)

      Rails.logger.debug { "[Option::ChainAnalyzer] Analyzing Options for #{expiry}" }
      raise ArgumentError, 'Option Chain is missing or empty!' if @option_chain[:oc].blank?
    end

    # Main entry
    def analyze(signal_type:, strategy_type:, signal_strength: 1.0)
      result = {
        proceed: true,
        reason: nil,
        signal_type: signal_type, # :ce / :pe
        trend: nil,
        momentum: nil,
        adx: nil,
        selected: nil,
        ranked: [],
        ta_snapshot: ta ? ta.to_h : {}
      }

      # 1) Core sanity gates
      if iv_rank_outside_range?
        result[:proceed] = false
        result[:reason]  = 'IV rank outside range'
      elsif discourage_late_entry_due_to_theta?
        result[:proceed] = false
        result[:reason]  = 'Late entry, theta risk'
      end

      # 2) Bias / momentum / ADX (HolyGrail if available)
      result[:trend]    = ta ? ta.bias.to_sym     : intraday_trend
      result[:momentum] = ta ? ta.momentum.to_sym : :flat
      result[:adx]      = ta&.adx
      adx_ok            = ta ? ta.adx.to_f >= 25 : true

      if result[:proceed] && !(trend_confirms?(result[:trend], signal_type) && adx_ok && result[:momentum] != :flat)
        result[:proceed] = false
        result[:reason]  = 'trend/momentum filter'
      end

      # 3) Candidate strikes â†’ score â†’ rank
      if result[:proceed]
        filtered = gather_filtered_strikes(signal_type)
        if filtered.empty?
          result[:proceed] = false
          result[:reason]  = 'No tradable strikes found'
        else
          m_boost = (result[:momentum] == :strong ? 1.15 : 1.0)
          ranked  = filtered.map do |opt|
            score = score_for(opt, strategy_type, signal_type, signal_strength) * m_boost
            opt.merge(score: score)
          end.sort_by { |o| -o[:score] }

          result[:ranked]   = ranked.first(TOP_RANKED_LIMIT)
          result[:selected] = result[:ranked].first
        end
      end

      result
    end

    # Public helper
    def current_trend = intraday_trend
    alias trend current_trend

    private

    def iv_rank_outside_range?
      @iv_rank < IV_RANK_MIN || @iv_rank > IV_RANK_MAX
    end

    def gather_filtered_strikes(signal_type)
      side = signal_type.to_sym # :ce / :pe

      @option_chain[:oc].filter_map do |strike_str, row|
        opt = row[side.to_s]
        next unless opt

        # Must have price + IV
        next if opt['implied_volatility'].to_f.zero? || opt['last_price'].to_f.zero?

        strike_price = strike_str.to_f
        delta_abs    = opt.dig('greeks', 'delta').to_f.abs

        # Min Î” gates (timeâ€‘ofâ€‘day)
        next if delta_abs < min_delta_now

        # Adaptive ATM window
        next unless within_atm_range?(strike_price)

        build_strike_data(strike_price, opt)
      end
    end

    # Dynamic Î” thresholds
    def min_delta_now
      h = Time.zone.now.hour
      return 0.45 if h >= 14
      return 0.35 if h >= 13
      return 0.30 if h >= 11

      0.25
    end

    # Adaptive ATM window by IV rank
    def atm_range_pct
      case iv_rank
      when 0.0..0.2 then 0.01
      when 0.2..0.5 then 0.015
      else               0.025
      end
    end

    def within_atm_range?(strike)
      band = atm_range_pct
      lo   = @underlying_spot * (1 - band)
      hi   = @underlying_spot * (1 + band)
      strike.between?(lo, hi)
    end

    def build_strike_data(strike_price, opt)
      {
        strike_price: strike_price,
        last_price: opt['last_price'].to_f,
        iv: opt['implied_volatility'].to_f,
        oi: opt['oi'].to_i,
        volume: opt['volume'].to_i,
        greeks: {
          delta: opt.dig('greeks', 'delta').to_f,
          gamma: opt.dig('greeks', 'gamma').to_f,
          theta: opt.dig('greeks', 'theta').to_f,
          vega: opt.dig('greeks', 'vega').to_f
        },
        previous_close_price: opt['previous_close_price'].to_f,
        previous_oi: opt['previous_oi'].to_i,
        previous_volume: opt['previous_volume'].to_i,
        price_change: opt['last_price'].to_f - opt['previous_close_price'].to_f,
        oi_change: opt['oi'].to_i - opt['previous_oi'].to_i,
        volume_change: opt['volume'].to_i - opt['previous_volume'].to_i,
        bid_ask_spread: (opt['top_ask_price'].to_f - opt['top_bid_price'].to_f).abs
      }
    end

    def score_for(opt, strategy, signal_type, signal_strength)
      spread          = opt[:bid_ask_spread] <= 0 ? 0.1 : opt[:bid_ask_spread]
      last_price      = opt[:last_price].to_f
      relative_spread = spread / (last_price.nonzero? || 1.0)

      oi        = [opt[:oi], 1].max
      volume    = [opt[:volume], 1].max
      delta     = opt[:greeks][:delta].abs
      gamma     = opt[:greeks][:gamma]
      theta     = opt[:greeks][:theta]
      vega      = opt[:greeks][:vega]
      price_chg = opt[:price_change]
      oi_chg    = opt[:oi_change]
      vol_chg   = opt[:volume_change]

      # weights: intraday vs swing
      lw, mw, = (strategy.to_s == 'intraday' ? [0.35, 0.35, 0.3] : [0.25, 0.25, 0.5])

      # Liquidity (penalize wide spreads)
      liquidity_score = ((oi * volume) + vol_chg.abs) / (relative_spread.nonzero? || 0.01)

      # Flow/momentum
      momentum_score  = (oi_chg / 1000.0)
      momentum_score += price_chg.positive? ? price_chg : price_chg.abs if delta >= 0 && price_chg.positive?

      # Theta pressure â†‘ near expiry
      days_left     = (@expiry - Time.zone.today).to_i
      theta_penalty = theta.abs * (days_left < 3 ? 2.0 : 1.0)
      greeks_score  = (delta * 100) + (gamma * 10) + (vega * 2) - (theta_penalty * 3)

      # Price efficiency
      efficiency = last_price.zero? ? 0.0 : (price_chg / last_price)
      efficiency_score = efficiency * 30

      total = (liquidity_score * lw) +
              (momentum_score  * mw) +
              (greeks_score    * theta_weight) +
              efficiency_score

      # Skew checks
      z = local_iv_zscore(opt[:iv], opt[:strike_price])
      total *= 0.90 if z > 1.5

      tilt = skew_tilt
      total *= 1.10 if (signal_type == :ce && tilt == :call) || (signal_type == :pe && tilt == :put)

      # Historical IV sanity
      hist_vol = historical_volatility
      if hist_vol.positive?
        iv_ratio = opt[:iv] / hist_vol
        total *= 0.9 if iv_ratio > 1.5
      end

      total * signal_strength
    end

    def theta_weight
      Time.zone.now.hour >= 13 ? 4.0 : 3.0
    end

    def local_iv_zscore(strike_iv, strike)
      neighbours = @option_chain[:oc].keys.map(&:to_f).select { |s| (s - strike).abs <= 300 }
      ivs = neighbours.filter_map do |s|
        node = @option_chain[:oc][format('%.6f', s)]
        (node && node['ce'] && node['ce']['implied_volatility']).to_f
      end
      return 0 if ivs.empty?

      mean = ivs.sum / ivs.size
      var  = ivs.sum { |v| (v - mean)**2 } / ivs.size
      std  = Math.sqrt(var)
      std.zero? ? 0 : (strike_iv - mean) / std
    end

    def skew_tilt
      ce_ivs = collect_side_ivs(:ce)
      pe_ivs = collect_side_ivs(:pe)
      avg_ce = ce_ivs.any? ? ce_ivs.sum / ce_ivs.size.to_f : nil
      avg_pe = pe_ivs.any? ? pe_ivs.sum / pe_ivs.size.to_f : nil

      return :call if avg_ce && avg_pe && avg_ce > avg_pe * 1.1
      return :put  if avg_pe && avg_ce && avg_pe > avg_ce * 1.1

      :neutral
    end

    def collect_side_ivs(side)
      @option_chain[:oc].values.filter_map do |row|
        v = row.dig(side.to_s, 'implied_volatility')
        v.to_f if v && v.to_f > 0
      end
    end

    # simple HV (annualized %)
    def historical_volatility
      return 0 if @historical_data.blank?

      closes = @historical_data['close'] || []
      return 0 if closes.size < 10

      rets = []
      closes.each_cons(2) do |a, b|
        rets << Math.log(b.to_f / a.to_f)
      rescue StandardError
        rets << 0
      end
      mean = rets.sum / (rets.size.nonzero? || 1)
      var  = rets.sum { |r| (r - mean)**2 } / (rets.size.nonzero? || 1)
      Math.sqrt(var) * Math.sqrt(252) * 100.0
    end

    # Flow bias from CE vs PE change around ATM
    def intraday_trend
      atm = determine_atm_strike
      return :neutral unless atm

      window  = 3
      sums    = { ce: 0.0, pe: 0.0 }
      strikes = @option_chain[:oc].keys.map(&:to_f)
      strikes.select { |s| (s - atm).abs <= (window * 100) }.each do |s|
        key = format('%.6f', s)
        %i[ce pe].each do |side|
          opt = @option_chain[:oc].dig(key, side.to_s)
          next unless opt

          change = opt['last_price'].to_f - opt['previous_close_price'].to_f
          sums[side] += change
        end
      end
      diff = sums[:ce] - sums[:pe]
      return :bullish if diff.positive?
      return :bearish if diff.negative?

      :neutral
    end

    def trend_confirms?(trend, signal_type)
      return true if trend == :neutral

      (trend == :bullish && signal_type == :ce) || (trend == :bearish && signal_type == :pe)
    end

    def discourage_late_entry_due_to_theta?
      now           = Time.zone.now
      expiry_today  = (@expiry == now.to_date)
      current_hours = now.hour + (now.min / 60.0)
      expiry_today && current_hours > THETA_AVOID_HOUR
    end

    def determine_atm_strike
      strikes = @option_chain[:oc].keys.map(&:to_f)
      return nil if strikes.empty?

      strikes.min_by { |s| (s - @underlying_spot).abs }
    end
  end
end


# File: app/services/options/chain_analyzer.rb
# frozen_string_literal: true

module Options
  # Facade for legacy callers. Picks ATMÂ± range via Option::ChainAnalyzer and
  # returns a single best row with derivative details (security_id, lot_size, â€¦)
  class ChainAnalyzer < ApplicationService
    def initialize(underlying:, side:, config: {})
      @ul     = underlying
      @side   = side.to_s.downcase.to_sym # :ce / :pe
      @config = {
        strategy_type: 'intraday'
      }.merge(config || {})
    end

    def call
      expiry = nearest_expiry(@ul)
      return nil unless expiry

      chain = safe_fetch_option_chain(@ul, expiry)
      return nil if chain.blank? || chain[:oc].blank?

      iv_rank = compute_iv_rank(chain)
      spot    = chain[:last_price].to_f.nonzero? || @ul.ws_ltp || @ul.ltp
      hist    = intraday_candles(@ul)

      # Use the advanced analyzer
      analyzer = Option::ChainAnalyzer.new(
        chain,
        expiry: expiry,
        underlying_spot: spot.to_f,
        iv_rank: iv_rank,
        historical_data: hist
      )

      result = analyzer.analyze(signal_type: @side, strategy_type: @config[:strategy_type])

      return nil unless result[:proceed] && (sel = result[:selected])

      # Enrich with derivative info (security_id, lot, segment) and bid/ask
      leg = to_legacy_row(@ul, chain, sel, expiry, @side)
      return nil unless leg

      # Final light guard (keeps your old expectations: nonâ€‘zero price, etc.)
      return nil if leg[:ltp].to_f <= 0

      leg
    rescue StandardError => e
      Rails.logger.error("[Options::ChainAnalyzer] #{e.class} #{e.message}")
      nil
    end

    private

    def nearest_expiry(inst)
      Array(inst.expiry_list).first
    rescue StandardError
      nil
    end

    def safe_fetch_option_chain(inst, expiry)
      inst.fetch_option_chain(expiry)
    rescue StandardError => e
      Rails.logger.error("[Options::ChainAnalyzer] option-chain fetch failed (#{expiry}): #{e.message}")
      nil
    end

    # Same formula you used inside AlertProcessors::Index#iv_rank_for
    def compute_iv_rank(chain)
      atm = determine_atm_strike(chain)
      return 0.5 unless atm

      key   = format('%.6f', atm)
      ce_iv = chain[:oc].dig(key, 'ce', 'implied_volatility').to_f
      pe_iv = chain[:oc].dig(key, 'pe', 'implied_volatility').to_f
      cur   = [ce_iv, pe_iv].select(&:positive?).then { |arr| arr.empty? ? 0.0 : (arr.sum / arr.size) }

      ivs = chain[:oc].values.flat_map { |row| %w[ce pe].map { |k| row.dig(k, 'implied_volatility').to_f } }.reject(&:zero?)
      return 0.5 if ivs.empty? || ivs.max == ivs.min

      ((cur - ivs.min) / (ivs.max - ivs.min)).clamp(0, 1).round(2)
    rescue StandardError
      0.5
    end

    def determine_atm_strike(chain)
      spot = chain[:last_price].to_f
      chain[:oc].keys.map(&:to_f).min_by { |s| (s - spot).abs }
    rescue StandardError
      nil
    end

    def intraday_candles(inst)
      DhanHQ::Models::HistoricalData.intraday(
        security_id: inst.security_id,
        exchange_segment: inst.exchange_segment,
        instrument: inst.instrument_type,
        interval: '5',
        from_date: 5.days.ago.to_date.to_s,
        to_date: Time.zone.today.to_s
      )
    rescue StandardError
      []
    end

    def to_legacy_row(inst, chain, sel, expiry, side)
      strike_f = sel[:strike_price].to_f
      strike_key = format('%.6f', strike_f)
      side_s     = side.to_s

      node       = chain[:oc][strike_key]
      side_node  = node && node[side_s]
      return nil unless side_node

      # Map to DB derivative
      derivative = inst.derivatives.find_by(
        strike_price: strike_f,
        expiry_date: expiry,
        option_type: side.to_s.upcase
      )
      return nil unless derivative

      bid = side_node['top_bid_price'].to_f
      ask = side_node['top_ask_price'].to_f
      mid = [(bid + ask) / 2.0, sel[:last_price].to_f].compact.max
      spread = ask.positive? && bid.positive? ? (ask - bid).abs : nil
      spread_pct = mid.positive? && spread ? ((spread / mid) * 100.0) : nil

      {
        # legacy shape expected by Strategy loop
        security_id: derivative.security_id,
        symbol: derivative.symbol_name || inst.symbol_name,
        cp: side.to_s.upcase.to_sym, # :CE / :PE
        strike: strike_f,
        ltp: sel[:last_price].to_f,
        bid: bid,
        ask: ask,
        spread_pct: (spread_pct && spread_pct.round(3)) || 999.0,
        volume: sel[:volume].to_i,
        oi: sel[:oi].to_i,
        iv: sel[:iv].to_f,
        lot_size: derivative.lot_size || inst.lot_size,
        exchange_segment: derivative.exchange_segment
      }
    end
  end
end


# File: app/services/orders/analyzer.rb
module Orders
  class Analyzer < ApplicationService
    def self.realized_pnl_for(security_id, segment)
      pos = State::PositionCache.get(seg: segment, sid: security_id, prod: 'INTRADAY')
      return 0.0 unless pos

      Pnl::LiveCalculator.for_position(pos)[:unrealized].to_f # close enough until broker confirms
    rescue StandardError
      0.0
    end
  end
end


# File: app/services/orders/closer.rb
# frozen_string_literal: true

module Orders
  class Closer < ApplicationService
    # Accept either a cached order hash or a client_ref
    def initialize(order: nil, client_ref: nil)
      @order_hash = order || (client_ref && State::OrderCache.get(client_ref))
    end

    def call
      return unless @order_hash&.dig(:broker_order_id)

      DhanHQ::Models::SuperOrder.new(order_id: @order_hash[:broker_order_id]).cancel('ENTRY_LEG')
    rescue StandardError => e
      Rails.logger.warn("[Orders::Closer] cancel failed: #{e.class} #{e.message}")
      false
    end
  end
end

# File: app/services/orders/executor.rb
# frozen_string_literal: true

module Orders
  class Executor < ApplicationService
    # instrument: Instrument/Derivative
    # side: "BUY"/"SELL"
    # qty: lots/contracts
    # entry_type: :market / :limit
    # risk_params: { sl_value:, tp_value:, trail_sl_value:, trail_sl_jump: }
    # client_ref: unique idempotency key
    def initialize(instrument:, side:, qty:, entry_type:, risk_params:, client_ref:, entry_price: nil)
      @instrument  = instrument
      @side        = side.to_s.upcase
      @qty         = qty.to_i
      @entry_type  = entry_type.to_sym
      @risk_params = risk_params || {}
      @client_ref  = client_ref
      @entry_price = entry_price
    end

    def call
      guard = Risk::Guard.new
      raise 'Trading disabled' unless guard.trading_enabled?

      PgLocks.with_lock("super:#{@instrument.id}") do
        # 1) Idempotency via cache
        if (existing = State::OrderCache.get(@client_ref))
          return existing
        end

        # 2) Build payload
        params = Orders::SuperParamsBuilder.call(
          instrument: @instrument,
          side: @side,
          qty: @qty,
          entry_type: @entry_type,
          entry_price: @entry_price,
          sl_value: @risk_params[:sl_value],
          tp_value: @risk_params[:tp_value],
          trail_sl_jump: @risk_params[:trail_sl_value],
          client_ref: @client_ref
        )

        pp params
        # 3) Place Super Order (returns model with order_id/order_status)
        so = DhanHQ::Models::SuperOrder.create(params)
        raise 'SuperOrder.create failed' unless so&.order_id

        # 4) Cache order snapshot
        order_hash = {
          client_ref: @client_ref,
          broker_order_id: so.order_id,
          status: so.order_status || 'PENDING',
          side: @side,
          qty: @qty,
          entry_type: @entry_type,
          entry_price: params[:price], # avg price may not be immediate
          stop_loss_price: params[:stop_loss_price],
          target_price: params[:target_price],
          trailing_value: params[:trailing_value],
          trailing_jump: params[:trailing_jump],
          exchange_segment: @instrument.exchange_segment,
          security_id: @instrument.security_id,
          pos_key: State::PositionCache.key(seg: @instrument.exchange_segment,
                                            sid: @instrument.security_id,
                                            prod: 'INTRADAY'),
          ts: Time.zone.now
        }.compact
        State::OrderCache.put!(@client_ref, order_hash)

        # 5) Bump PositionCache (optimistic)
        bump_position_cache!(order_hash)

        order_hash
      end
    end

    private

    def bump_position_cache!(o)
      seg = o[:exchange_segment]
      sid = o[:security_id]
      prod = 'INTRADAY'
      cur = State::PositionCache.get(seg:, sid:, prod:) || {}
      net = cur[:net_qty].to_i + (@side == 'BUY' ? @qty : -@qty)

      State::PositionCache.upsert!(
        seg:, sid:, prod:,
        attrs: cur.merge(
          seg: seg, sid: sid, prod: prod,
          net_qty: net,
          buy_avg: cur[:buy_avg], # leave to broker reconcile
          sell_avg: cur[:sell_avg],
          updated_by: 'Orders::Executor'
        )
      )
    end
  end
end

# File: app/services/orders/manager.rb
# app/services/orders/manager.rb
# frozen_string_literal: true

module Orders
  class Manager < ApplicationService
    # Try to flatten using SuperOrder; fallback to plain MARKET opposite leg
    def self.exit_position!(security_id:, segment:, reason:)
      # 1) If we have a cached super order for this instrument, cancel it.
      order = State::OrderCache.fetch_all.values.find do |o|
        o[:security_id].to_i == security_id.to_i && o[:exchange_segment].to_s == segment.to_s
      end

      if order&.dig(:broker_order_id)
        begin
          ok = DhanHQ::Models::SuperOrder.new(order_id: order[:broker_order_id]).cancel('ENTRY_LEG')
          Rails.logger.info("[Orders::Manager] cancel super #{segment}:#{security_id} => #{ok} (#{reason})")
          return true if ok
        rescue StandardError => e
          Rails.logger.warn("[Orders::Manager] super cancel failed: #{e.class} #{e.message}")
        end
      end

      # 2) Fallback: plain opposite market order
      begin
        side = (infer_side_from_pos(segment:, security_id:) == 'LONG' ? 'SELL' : 'BUY')
        lot  = Derivative.find_by(security_id: security_id)&.lot_size || 1

        DhanHQ::Models::Order.create!(
          transaction_type: side,
          exchange_segment: segment,
          product_type: 'INTRADAY',
          order_type: 'MARKET',
          validity: 'DAY',
          security_id: security_id,
          quantity: lot
        )
        Rails.logger.info("[Orders::Manager] market flatten #{segment}:#{security_id} (#{reason})")
        true
      rescue StandardError => e
        Rails.logger.error("[Orders::Manager] fallback exit failed #{segment}:#{security_id} â€“ #{e.class}: #{e.message}")
        false
      end
    end

    def self.infer_side_from_pos(segment:, security_id:)
      pos = State::PositionCache.get(seg: segment, sid: security_id, prod: 'INTRADAY') || {}
      qty = pos[:net_qty].to_i
      qty >= 0 ? 'LONG' : 'SHORT'
    end
  end
end

# File: app/services/orders/super_modifier.rb
# frozen_string_literal: true

module Orders
  class SuperModifier < ApplicationService
    # Accept either a cached order hash or a client_ref
    def initialize(order: nil, client_ref: nil, new_sl_value: nil, new_tp_value: nil, new_trail_sl_value: nil)
      @order_hash = order || (client_ref && State::OrderCache.get(client_ref))
      @client_ref = client_ref || @order_hash&.dig(:client_ref)
      @new_sl     = new_sl_value && PriceMath.round_tick(new_sl_value)
      @new_tp     = new_tp_value && PriceMath.round_tick(new_tp_value)
      @new_trail  = new_trail_sl_value && PriceMath.round_tick(new_trail_sl_value)
    end

    def call
      return unless @order_hash && @order_hash[:broker_order_id]

      payload = {}

      cur_sl    = @order_hash[:stop_loss_price]&.to_f
      cur_tp    = @order_hash[:target_price]&.to_f
      cur_trail = @order_hash[:trailing_value]&.to_f

      payload[:stop_loss_price] = @new_sl   if @new_sl   && cur_sl   && @new_sl >= cur_sl   # tighten only
      payload[:target_price]    = @new_tp   if @new_tp   && cur_tp   && @new_tp <= cur_tp   # nearer only
      payload[:trailing_value]  = @new_trail if @new_trail && (cur_trail.nil? || @new_trail >= cur_trail)

      return if payload.empty?

      ok = DhanHQ::Models::SuperOrder.new(order_id: @order_hash[:broker_order_id]).modify(payload)

      if ok
        # refresh cache
        merged = @order_hash.merge(
          stop_loss_price: payload[:stop_loss_price] || cur_sl,
          target_price: payload[:target_price] || cur_tp,
          trailing_value: payload[:trailing_value] || cur_trail,
          status: 'MODIFIED',
          ts: Time.zone.now
        )
        State::OrderCache.put!(@client_ref, merged)
      end
      ok
    end
  end
end

# File: app/services/orders/super_params_builder.rb
# frozen_string_literal: true

module Orders
  class SuperParamsBuilder
    # Build request body for POST /v2/super/orders
    #
    # Arguments:
    #   instrument:    Instrument/Derivative with #security_id and #exchange_segment
    #   side:          :buy / :sell (or "BUY"/"SELL")
    #   qty:           Integer quantity (lots/shares as per instrument)
    #   entry_type:    :market / :limit
    #   sl_value:      Absolute stop-loss price (premium/price), required
    #   tp_value:      Absolute target price, required
    #   client_ref:    Your idempotency key -> mapped to correlationId
    #
    # Optional:
    #   entry_price:     Limit price (required when entry_type == :limit)
    #   trail_sl_jump:   Trailing jump (absolute price jump)
    #   product_type:    'INTRADAY' | 'CNC' | 'MARGIN' | 'MTF' (default: 'INTRADAY')
    #   validity:        'DAY' (default)
    #   dhan_client_id:  If your gem/config doesnâ€™t inject it, pass here
    #
    # Returns: Hash with Dhan-compliant keys/casing
    def self.call(
      instrument:,
      side:,
      qty:,
      entry_type:,
      sl_value:,
      tp_value:,
      client_ref:,
      entry_price: nil,
      trail_sl_jump: nil,
      product_type: 'INTRADAY',
      validity: 'DAY',
      dhan_client_id: nil
    )
      # ------------ validations ------------
      raise ArgumentError, 'qty must be positive'            if qty.to_i <= 0
      raise ArgumentError, 'sl_value must be present'        if sl_value.nil?
      raise ArgumentError, 'tp_value must be present'        if tp_value.nil?

      ord_type = entry_type.to_s.upcase # "MARKET" | "LIMIT"
      price    = if ord_type == 'LIMIT'
                   PriceMath.round_tick(entry_price).tap do |p|
                     raise ArgumentError, 'limit order requires valid entry_price' if p.nil? || p <= 0
                   end
                 end

      txn_side = side.to_s.upcase # "BUY" | "SELL"

      # ------------ build payload ------------
      {
        # identifiers / routing
        # correlation_id: client_ref.to_s, # for tracking/idempotency
        transaction_type: txn_side,                           # BUY / SELL
        exchange_segment: instrument.exchange_segment,        # e.g. "NSE_FNO"
        product_type: product_type.to_s.upcase, # INTRADAY / CNC / MARGIN / MTF
        order_type: ord_type, # LIMIT / MARKET
        validity: validity.to_s.upcase, # DAY (required by some setups)

        # instrument + qty
        security_id: instrument.security_id.to_s,
        quantity: qty.to_i,

        # price legs
        price: price, # only for LIMIT (omitted for MARKET)
        target_price: PriceMath.round_tick(tp_value),
        stop_loss_price: PriceMath.round_tick(sl_value),
        trailing_jump: trail_sl_jump && PriceMath.round_tick(trail_sl_jump)
      }.compact
    end
  end
end

# File: app/services/pg_locks.rb
module PgLocks
  def self.with_lock(key)
    lock_id = Zlib.crc32(key.to_s)
    ActiveRecord::Base.connection.execute("SELECT pg_advisory_lock(#{lock_id})")
    yield
  ensure
    ActiveRecord::Base.connection.execute("SELECT pg_advisory_unlock(#{lock_id})")
  end
end

# File: app/services/pnl/live_calculator.rb
module Pnl
  class LiveCalculator
    def self.for_position(pos)
      # pos is a hash from PositionCache
      ltp = Live::TickCache.ltp(pos[:seg], pos[:sid]).to_f
      avg = (pos[:net_qty].to_i >= 0 ? pos[:buy_avg] : pos[:sell_avg]).to_f
      qty = pos[:net_qty].to_i.abs

      # For options, multiply by lot size (lookup from Instrument/Derivative) if you want total â‚¹
      lot = pos[:lot_size] || 1
      direction = pos[:net_qty].to_i >= 0 ? +1 : -1
      unreal = (ltp - avg) * qty * lot * direction
      { ltp:, unrealized: unreal.round(2) }
    end
  end
end

# File: app/services/portfolio/sync.rb
module Portfolio
  class Sync < ApplicationService
    def call
      sync_holdings
      sync_positions
    end

    def sync_holdings
      arr = DhanHQ::Models::Holding.all # => array of hashes per API
      Array(arr).each do |h|
        Holding
          .find_or_initialize_by(exchange: h.exchange, security_id: h.security_id)
          .update!(
            trading_symbol: h.trading_symbol,
            isin: h.isin,
            total_qty: h.total_qty,
            dp_qty: h.dp_qty,
            t1_qty: h.t1_qty,
            available_qty: h.available_qty,
            collateral_qty: h.collateral_qty,
            avg_cost_price: h.avg_cost_price
          )
      end
    rescue DhanHQ::InternalServerError => e
      Rails.logger.error("Failed to sync holdings: #{e.message}")
      []
    end

    def sync_positions
      arr = DhanHQ::Models::Position.all

      Array(arr).each do |p|
        pp p
        Position
          .find_or_initialize_by(exchange_segment: p.exchange_segment, security_id: p.security_id)
          .update!(
            dhan_client_id: p.dhan_client_id,
            trading_symbol: p.trading_symbol,
            position_type: p.position_type,
            product_type: p.product_type,
            buy_avg: p.buy_avg,
            buy_qty: p.buy_qty,
            cost_price: p.cost_price,
            sell_avg: p.sell_avg,
            sell_qty: p.sell_qty,
            net_qty: p.net_qty,
            realized_profit: p.realized_profit,
            unrealized_profit: p.unrealized_profit,
            rbi_reference_rate: p.rbi_reference_rate,
            multiplier: p.multiplier,
            carry_forward_buy_qty: p.carry_forward_buy_qty,
            carry_forward_sell_qty: p.carry_forward_sell_qty,
            carry_forward_buy_value: p.carry_forward_buy_value,
            carry_forward_sell_value: p.carry_forward_sell_value,
            day_buy_qty: p.day_buy_qty,
            day_sell_qty: p.day_sell_qty,
            day_buy_value: p.day_buy_value,
            day_sell_value: p.day_sell_value,
            drv_expiry_date: begin
              Date.parse(p.drv_expiry_date)
            rescue StandardError
              nil
            end,
            drv_option_type: p.drv_option_type,
            drv_strike_price: p.drv_strike_price,
            cross_currency: p.cross_currency
          )
      end
    end
  end
end

# File: app/services/price_math.rb
module PriceMath
  TICK = 0.05

  def self.round_tick(x)
    return nil if x.nil?

    ((x.to_f / TICK).round * TICK).round(2)
  end

  def self.floor_tick(x)
    ((x.to_f / TICK).floor * TICK).round(2)
  end

  def self.ceil_tick(x)
    ((x.to_f / TICK).ceil * TICK).round(2)
  end

  def self.valid_tick?(x)
    # Avoid float fuzziness: work in paise
    ((x.to_f * 100).round % (TICK * 100).to_i).zero?
  end
end

# File: app/services/regime/chop_detector.rb
# app/services/regime/chop_detector.rb
# Detects sideways/range conditions using lightweight signals from CandleSeries.
class Regime::ChopDetector
  # Any 2 true â‡’ choppy
  # cs5/cs15 are CandleSeries instances (5m/15m) you already have.
  def self.choppy_pre_entry?(cs5, cs15, opts = {})
    adx_th    = (opts[:adx_min] || 18).to_i
    atr_mult  = (opts[:atr_quiet_mult] || 0.8).to_f
    cross_win = (opts[:vwap_cross_window] || 30).to_i

    low_adx   = safe { cs5.adx(14) }&.<(adx_th) || false
    quiet_atr = begin
      atr_now  = safe { cs5.atr(5) } || 0.0
      atr_med  = safe { cs5.atr(5).median(50) } || atr_now
      atr_now > 0 && atr_med > 0 && (atr_now < atr_med * atr_mult)
    rescue StandardError
      false
    end
    vwap_x    = vwap_crossings(cs5, cross_win) >= 3
    nr5       = narrow_range?(cs5, 5)

    [low_adx, quiet_atr, vwap_x, nr5].count(true) >= 2
  end

  # ---- helpers ----

  def self.vwap_crossings(cs, window)
    vwap = safe { cs.vwap_series(window: window) } # preferred if you have it
    closes = safe { cs.close_series(window: window) }
    if vwap && closes && vwap.size == closes.size && vwap.size > 1
      signs = closes.zip(vwap).map { |c, v| (c <=> v) } # -1, 0, 1
      signs.each_cons(2).count { |a, b| (a <=> b) == -1 || (a <=> b) == 1 }
    else
      # Fallback: approximate with current vwap line if only one value
      0
    end
  rescue StandardError
    0
  end

  def self.narrow_range?(cs, n)
    # NR(n): current bar range <= min range of last n bars
    bars = safe { cs.last_n(n + 1) } || []
    return false unless bars.size >= 2

    rng = ->(b) { (b[:high] - b[:low]).to_f }
    cur = rng.call(bars.last)
    hist = bars[0...-1].map(&rng)
    cur <= hist.min
  rescue StandardError
    false
  end

  def self.safe(&)
    yield
  rescue StandardError
    nil
  end
end


# File: app/services/risk/guard.rb
module Risk
  class Guard
    DEFAULT_MAX_TICK_AGE = 5 # seconds

    def trading_enabled?
      Setting.fetch_bool('trading_enabled', true)
    end

    def per_trade_risk_rupees
      Setting.fetch_i('risk.per_trade_rupees', 0)
    end

    def daily_loss_cap_rupees
      Setting.fetch_i('risk.daily_loss_cap_rupees', 0)
    end

    def max_trades_per_day
      Setting.fetch_i('risk.max_trades_per_day', 0)
    end

    # ---- Gates ----

    # Returns [allowed(Boolean), reason(String)]
    # expected_risk_rupees: how much you'd risk if this entry is placed (use per_trade_risk_rupees)
    # seg/sid: instrument identifiers for staleness check
    def entry_allowed?(expected_risk_rupees:, seg:, sid:, max_tick_age: DEFAULT_MAX_TICK_AGE)
      return [false, 'trading_disabled'] unless trading_enabled?

      return [false, 'ticks_stale'] if stale?(seg:, sid:, max_age: max_tick_age)

      return [false, 'max_trades_reached'] unless trade_budget_ok?

      return [false, 'daily_loss_cap'] unless daily_loss_ok?(expected_risk_rupees: expected_risk_rupees)

      [true, 'ok']
    end

    # Alias for simpler boolean interface
    # Returns true if entry is allowed, false otherwise
    def ok_to_enter?(expected_risk_rupees:, seg:, sid:, max_tick_age: DEFAULT_MAX_TICK_AGE)
      allowed, _reason = entry_allowed?(expected_risk_rupees: expected_risk_rupees, seg: seg, sid: sid, max_tick_age: max_tick_age)
      allowed
    end

    # Freshness of ticks
    def stale?(seg:, sid:, max_age: DEFAULT_MAX_TICK_AGE)
      tick = begin
        Live::TickCache.get(seg, sid)
      rescue StandardError
        nil
      end
      return true unless tick && tick[:ts].is_a?(Time)

      (Time.zone.now - tick[:ts]) > max_age
    end

    # New entry should not push realized losses beyond the cap
    # Rule: remaining_loss_budget >= expected_risk
    def daily_loss_ok?(expected_risk_rupees:)
      cap  = [daily_loss_cap_rupees, 0].max
      loss = realized_loss_today_abs
      remaining = cap - loss
      remaining >= expected_risk_rupees.to_i
    end

    def trade_budget_ok?
      # Count entries (orders) created today; adjust scope if you count positions instead
      taken = Order.where('created_at::date = ?', Date.current).count
      taken < max_trades_per_day
    end

    # ---- Helpers ----

    # Absolute value of today's realized loss (rupees); profits don't increase budget
    def realized_loss_today_abs
      pnl = Position.where(state: :closed)
                    .where('updated_at::date = ?', Date.current)
                    .sum(:realized_pnl).to_f
      pnl.negative? ? pnl.abs : 0.0
    end
  end
end


# File: app/services/risk/scalp_params.rb
# app/services/risk/scalp_params.rb
# Convenience wrapper for building scalp or momentum params.
class Risk::ScalpParams
  def self.for(entry_premium:, mode:)
    case mode
    when :scalp
      Risk::ToSuperParams.call(
        entry_premium: entry_premium,
        sl_pct: 0.25,  # keep risk constant
        tp_pct: 0.30,  # smaller, grab-able TP
        trail_pct: 0.18,
        trail_jump_pct: 0.10
      )
    else # :momentum (default)
      Risk::ToSuperParams.call(
        entry_premium: entry_premium,
        sl_pct: 0.25,
        tp_pct: 0.50,
        trail_pct: 0.20,
        trail_jump_pct: 0.10
      )
    end
  end
end


# File: app/services/risk/to_super_params.rb
# app/services/risk/to_super_params.rb
class Risk::ToSuperParams
  # sl/tp/trail/jump are ABSOLUTE premium values derived from entry premium
  def self.call(entry_premium:, sl_pct: 0.25, tp_pct: 0.50, trail_pct: 0.20, trail_jump_pct: 0.10)
    ep = entry_premium.to_f
    raise ArgumentError, 'entry_premium must be > 0' if ep <= 0

    sl   = [PriceMath.round_tick(ep * sl_pct),   0.05].max
    tp   = [PriceMath.round_tick(ep * tp_pct),   0.05].max
    tval = [PriceMath.round_tick(ep * trail_pct), 0.05].max
    tjmp = [PriceMath.round_tick(ep * trail_jump_pct), 0.05].max

    {
      sl_value: sl,
      tp_value: tp,
      trail_sl_value: tval,
      trail_sl_jump: tjmp
    }
  end
end


# File: app/services/runner/auto_pilot.rb
# frozen_string_literal: true

module Runner
  class AutoPilot < ApplicationService
    WINDOW = { start: '09:20', stop: '15:15' }.freeze

    MODE = Struct.new(:name, :tf, :adx_min, :profit_arm_pct, :time_stop_s, :scalp,
                      keyword_init: true)

    NORMAL = MODE.new(
      name: :normal, tf: '5', adx_min: 20, profit_arm_pct: 0.01, time_stop_s: 480, scalp: false
    )
    SCALP = MODE.new(
      name: :scalp, tf: '3', adx_min: 16, profit_arm_pct: 0.01, time_stop_s: 240, scalp: true
    )

    def initialize(symbols:, mode: :normal, roster: nil)
      @symbols = Array(symbols).presence || %w[NIFTY BANKNIFTY]
      @mode    = (mode.to_s == 'scalp' ? SCALP : NORMAL)
      @roster  = roster || @symbols
      @running = Concurrent::AtomicBoolean.new(false)
      @last_entry_at = {}
    end

    def call
      start!
    end

    def start!
      return if @running.true?

      @running.make_true
      Live::WsHub.instance.start!(mode: :quote)
      subscribe_underlyings!

      # Kick off bars loop (fetch 5m/3m series) and trade loop
      @thread = Thread.new { main_loop }
      self
    end

    def stop!
      @running.make_false
      @thread&.kill
      self
    end

    private

    def main_loop
      loop do
        break unless @running.true?

        now = Time.zone.now
        run_once if inside_session?(now)
        sleep 10 # light cadence; bars fetch is heavier below
      end
    end

    def run_once
      # Pull series for each symbol on the configured TF
      Bars::FetchLoop.start(symbols: @roster, timeframe: tf_for(@mode.tf)) do |sym, series|
        process_symbol(sym, series)
      end
      sleep 12 # let one fetch cycle finish; guard against tight loops
      Bars::FetchLoop.stop
    end

    def process_symbol(sym, series)
      return if Regime::ChopDetector.choppy_pre_entry?(series, series, adx_min: @mode.adx_min)

      trend = holy_or_supertrend(series)
      return if %i[side neutral].include?(trend)

      inst = fetch_instrument(sym)
      return unless inst

      side = (trend == :up ? :ce : :pe)
      leg  = Options::ChainAnalyzer.call(underlying: inst, side: side, config: { strategy_type: (@mode.scalp ? 'intraday' : 'intraday') })
      return unless leg && leg[:ltp].to_f.positive?

      # Budget/guard: 30% capital per trade; expect ~1R equal to 10% of premium baseline
      qty = leg[:lot_size].to_i
      return if qty <= 0

      # Skip repeated entries too fast
      return if entered_recently?(sym)

      sl, tp, trail = rr_for(inst, leg, series)
      return unless risk_ok?(inst, expected_risk_rupees: qty * leg[:ltp] * 0.10) # ~10% of premium

      place_super(inst, side, qty, sl: sl, tp: tp, trail: trail)
      @last_entry_at[sym] = Time.current
    rescue StandardError => e
      Rails.logger.warn("[AutoPilot] #{sym} #{e.class}: #{e.message}")
    end

    def rr_for(inst, leg, series)
      # ATR% â†’ map to SL/TP/trail like your AlertProcessors did
      atr = begin
        series.atr(20)
      rescue StandardError
        nil
      end
      atr_pct = if atr && (c = series.closes.last).to_f.positive?
                  atr.to_f / c
                end

      if atr_pct&.positive?
        sl_pct    = (atr_pct * 2.0).clamp(0.05, 0.18)
        tp_pct    = (atr_pct * 4.0).clamp(0.10, 0.40)
        trail_pct = atr_pct.clamp(0.03, 0.12)
      else
        sl_pct = 0.10
        tp_pct = 0.20
        trail_pct = 0.03 # defaults
      end

      price = leg[:ltp].to_f
      [
        (price * (1 - sl_pct)),
        (price * (1 + tp_pct)),
        (price * trail_pct)
      ].map { |x| PriceMath.round_tick(x) }
    end

    def place_super(inst, side, qty, sl:, tp:, trail:)
      client_ref = "AP-#{inst.security_id}-#{side}-#{Time.now.to_i}"
      params = Orders::SuperParamsBuilder.call(
        instrument: inst,
        side: :buy,
        qty: qty,
        entry_type: :market,
        sl_value: sl,
        tp_value: tp,
        trail_sl_value: (trail.positive? ? trail : nil),
        trail_sl_jump: (trail.positive? ? trail : nil),
        client_ref: client_ref
      )
      Rails.logger.info("[AutoPilot] Super params â†’ #{params}")
      # Place or dry-run
      if Setting.fetch_bool('PLACE_ORDER', false)
        order = Orders::Executor.call(
          instrument: inst, side: :buy, qty: qty, entry_type: :market,
          risk_params: { sl_value: sl, tp_value: tp, trail_sl_value: trail, trail_sl_jump: trail },
          client_ref: client_ref
        )
        # subscribe the derivative as well
        begin
          Live::WsHub.instance.subscribe(seg: order.instrument.exchange_segment, sid: order.instrument.security_id.to_s)
        rescue StandardError
          nil
        end
        register_for_management(order, inst.symbol_name, side: side)
      else
        notify("ðŸ’¡ DRYRUN SUPER PARAMS\n#{params.inspect}", tag: 'DRYRUN')
      end
    end

    def register_for_management(order, underlying, side:)
      # Attach into PositionGuard
      intent = {
        security_id: order.instrument.security_id,
        exchange_segment: order.instrument.exchange_segment,
        entry_price: order.entry_price || 0.0,
        underlying_symbol: underlying
      }
      Execution::PositionGuard.register_intent(intent)
      # microâ€‘TP manager can be scheduled via a simple timer on each tick too (optional)
    end

    # ----- helpers -----
    def subscribe_underlyings!
      @symbols.each do |sym|
        inst = fetch_instrument(sym)
        Live::WsHub.instance.subscribe(seg: inst.exchange_segment, sid: inst.security_id.to_s) if inst
      end
    end

    def holy_or_supertrend(series)
      hg = Indicators::HolyGrail.call(candles: to_dhan_hash(series))
      pp hq
      case hg&.bias
      when :bullish then :up
      when :bearish then :down
      else :side
      end
    rescue StandardError
      # fallback: simple supertrend compare
      st = Indicators::Supertrend.new(series: series).call
      return :side if st.empty?

      series.closes.last > st.last ? :up : :down
    end

    def to_dhan_hash(series)
      {
        'timestamp' => series.candles.map { |c| c.timestamp.to_i },
        'open' => series.opens,
        'high' => series.highs,
        'low' => series.lows,
        'close' => series.closes,
        'volume' => series.candles.map(&:volume)
      }
    end

    def fetch_instrument(sym)
      Instrument.segment_index.find_by(symbol_name: sym) || Instrument.segment_equity.find_by(display_name: sym)
    end

    def risk_ok?(inst, expected_risk_rupees:)
      Risk::Guard.new.ok_to_enter?(expected_risk_rupees: expected_risk_rupees.to_i,
                                   seg: inst.exchange_segment, sid: inst.security_id.to_s)
    end

    def entered_recently?(sym)
      t = @last_entry_at[sym]
      t && (Time.current - t) < 90 # coolâ€‘down 90s per underlying
    end

    def inside_session?(now = Time.zone.now)
      t1 = Time.zone.parse(WINDOW[:start])
      t2 = Time.zone.parse(WINDOW[:stop])
      now.between?(t1, t2) && MarketCalendar.trading_day?(now.to_date)
    end

    def tf_for(tf)
      { '1' => '1m', '3' => '3m', '5' => '5m', '15' => '15m' }[tf.to_s] || '5m'
    end
  end
end


# File: app/services/runner/mtf_loop.rb
# frozen_string_literal: true

module Runner
  class MtfLoop
    class << self
      def start(symbols:, timeframe: '15m')
        stop
        @running = true
        Rails.logger.info("[Mtf] loop start #{symbols.join(', ')} @#{timeframe}")

        Bars::FetchLoop.start(timeframe: timeframe, symbols: symbols) do |symbol, _series|
          break unless @running

          begin
            inst = Instrument.segment_index.find_by(symbol_name: symbol) || Instrument.segment_equity.find_by(display_name: symbol)
            next unless inst

            sig = Strategy::MtfSmcEntry.call(inst)
            next unless sig

            # pick option leg
            leg = Strategy::OptionLocator.new(symbol).atm_leg_for(sig.direction == :bullish ? :bullish : :bearish)

            # sizing (use your existing sizing module)
            budget = Scalp::Budget.current || Scalp::Budget.new(ScalpSession.today!)
            sizing = Scalp::Sizing.for(leg, budget: budget)

            next if sizing.qty <= 0 || !budget.can_trade?

            # # place order
            # intent = Execution::DhanRouter.place_super_order!(leg, sizing)

            # # subscribe ticks for exit/trailing
            # Live::WsHub.instance.subscribe(seg: leg.exchange_segment, sid: leg.security_id)

            # # register with guard
            # Execution::PositionGuard.instance.register(
            #   pos_id: nil, # if you persist immediately, pass id
            #   exchange_segment: leg.exchange_segment,
            #   security_id: leg.security_id,
            #   entry: intent.entry_price,
            #   qty: sizing.qty,
            #   sl_pct: sizing.sl_pct, tp_pct: sizing.tp_pct, trail_pct: sizing.trail_pct,
            #   placed_as: 'super', super_order_id: intent.broker_order_id
            # )

            Rails.logger.info("[Mtf] #{symbol} #{sig.direction.upcase} -> leg=#{leg.security_id} why=#{sig.why}")
          rescue StandardError => e
            Rails.logger.error("[Mtf] fail #{symbol}: #{e.class} #{e.message}")
            Rails.logger.error(
              "[MTF] fail #{symbol}: #{e.class} #{e.message}\n" \
              "#{(e.backtrace || [])[0, 8].join("\n")}"
            )
          end
        end
      end

      def stop
        @running = false
        Bars::FetchLoop.stop
      end
    end
  end
end


# File: app/services/runner/positions_loop.rb
# app/services/runner/positions_loop.rb (inside loop, when you have p, ltp)
Positions::Manager.call(position: p)
Exits::MicroTP.call(
  order: p.order,
  ltp: ltp,
  entry_ts: p.created_at,
  side: (if p.order&.side&.to_sym == :buy
           p.option_call? ? :buy_ce : :buy_pe
         else
           :unknown
         end)
)

# app/services/runner/positions_loop.rb
module Runner
  class PositionsLoop
    INTERVAL = 0.5 # seconds
    TZ       = 'Asia/Kolkata'

    def initialize
      @risk    = Risk::Guard.new
      @running = false
    end

    def start
      return if @running

      @running = true
      @thread = Thread.new { run! }
      @thread
    end

    def stop
      @running = false
      @thread&.join(1)
    end

    private

    def run!
      Thread.current.name = begin
        'PositionsLoop'
      rescue StandardError
        nil
      end
      loop do
        break unless @running

        begin
          Position.open.includes(:order, :instrument).find_each do |p|
            manage_position(p)
          end
        rescue StandardError => e
          Rails.logger.error("[PositionsLoop] #{e.class} #{e.message}\n#{e.backtrace&.first(5)&.join("\n")}")
        ensure
          sleep INTERVAL
        end
      end
      Rails.logger.info('[PositionsLoop] stopped')
    end

    def manage_position(p)
      ins = p.instrument
      ltp = Live::TickCache.ltp(ins.exchange_segment, ins.security_id)
      return unless ltp

      # update unrealized P&L in rupees for options buying (premium delta * qty)
      entry = p.entry_price.to_f.nonzero? || p.order&.entry_price.to_f
      qty   = p.order&.qty.to_i
      if entry && entry > 0 && qty > 0
        p.unrealized_pnl = (ltp.to_f - entry) * qty
        p.save! if p.changed?
      end

      # trailer + micro TP / BE (tighten-only)
      Orders::SuperModifier.call(order: p.order) # no-op if nothing to change
      Exits::MicroTP.call(order: p.order, ltp: ltp, entry_ts: p.created_at, side: infer_side(p))

      # hard-flat if placing another loss would breach cap is not enough;
      # here we protect against live drawdown crossing the cap immediately:
      hard_flat_if_cap_breached!
    end

    def infer_side(p)
      # For long options we buy premium; if you store CE/PE, wire this properly.
      :buy_ce
    end

    def hard_flat_if_cap_breached!
      cap  = @risk.daily_loss_cap_rupees
      loss = @risk.realized_loss_today_abs
      # approximate unrealized loss across all open positions (only negative P&L counts)
      unreal = Position.open.sum('LEAST(unrealized_pnl, 0)').to_f.abs
      return unless (loss + unreal) >= cap && cap > 0

      Rails.logger.warn("[HARD-FLAT] Daily cap breached (#{loss + unreal} >= #{cap}) â†’ closing all + disabling trading")
      flatten_all!
      Setting.put('trading_enabled', 'false')
    end

    def flatten_all!
      Position.open.includes(:order).find_each do |p|
        Orders::Closer.call(order: p.order) if p.order&.super_ref.present?
      rescue StandardError => e
        Rails.logger.error("[HARD-FLAT] close failed pos=#{p.id} #{e.class} #{e.message}")
      end
    end
  end
end


# File: app/services/runner/recent_signals.rb
# app/services/runner/recent_signals.rb
module Runner
  class RecentSignals
    KEY = 'recent_signals'

    # store a short-lived fingerprint per underlying (e.g., 30s)
    def self.seen?(underlying_id:, fingerprint:, ttl: 30)
      key = "#{KEY}:#{underlying_id}:#{fingerprint}"
      already = Rails.cache.exist?(key)
      Rails.cache.write(key, true, expires_in: ttl)
      already
    end
  end
end


# File: app/services/runner/strategy_loop.rb
# app/services/runner/strategy_loop.rb (inside eval_instrument, before placing order)
cs5  = CandleSeries.for(ins, '5m')
cs15 = CandleSeries.for(ins, '15m')

scalp_mode = Regime::ChopDetector.choppy_pre_entry?(cs5, cs15)

entry_premium = opt[:ltp].to_f
risk_params   = Risk::ScalpParams.for(
  entry_premium: entry_premium,
  mode: scalp_mode ? :scalp : :momentum
)

Orders::Executor.call(
  instrument: Instrument.find_by(security_id: opt[:security_id]),
  side: :buy,
  qty: qty,
  entry_type: :market,
  risk_params: risk_params,
  client_ref: "super:#{ins.id}:#{Time.now.to_i}:#{SecureRandom.hex(3)}"
)

# app/services/runner/strategy_loop.rb
module Runner
  class StrategyLoop
    TICK      = 0.25 # seconds between scans
    TZ        = 'Asia/Kolkata'

    def initialize(instruments:)
      @instruments = Array(instruments)
      @risk        = Risk::Guard.new
      @running     = false
    end

    def start
      return if @running

      @running = true
      @thread = Thread.new { run! }
      @thread
    end

    def stop
      @running = false
      @thread&.join(1)
    end

    private

    def run!
      Thread.current.name = begin
        'StrategyLoop'
      rescue StandardError
        nil
      end
      loop do
        break unless @running

        begin
          break unless @risk.trading_enabled?
          next unless within_trade_window?

          @instruments.each do |ul|
            eval_underlying(ul)
          end
        rescue StandardError => e
          Rails.logger.error("[StrategyLoop] #{e.class} #{e.message}\n#{e.backtrace&.first(5)&.join("\n")}")
        ensure
          sleep TICK
        end
      end
      Rails.logger.info('[StrategyLoop] stopped')
    end

    def within_trade_window?
      Time.use_zone(TZ) do
        now  = Time.zone.now
        wnd1 = now.change(hour: 9,  min: 20)..now.change(hour: 11, min: 15)
        wnd2 = now.change(hour: 13, min: 30)..now.change(hour: 15, min: 5)
        wnd1.cover?(now) || wnd2.cover?(now)
      end
    end

    def eval_underlying(ul)
      # staleness gate (on underlying symbol/index)
      if @risk.stale?(seg: ul.exchange_segment, sid: ul.security_id)
        Rails.logger.debug { "[StrategyLoop] stale ticks for #{ul.symbol}, skipping" }
        return
      end

      # strategy compute on last closed bar (1m)
      cs1  = CandleSeries.for(ul, '1m')
      bar  = cs1.last_bar
      strat = Strategy::Router.for(ul)
      strat.on_bar(bar: bar)

      sig = strat.entry_signal
      return unless sig # no entry

      # trade budget gate + daily-loss gate
      ok, reason = @risk.entry_allowed?(
        expected_risk_rupees: @risk.per_trade_risk_rupees,
        seg: ul.exchange_segment, sid: ul.security_id
      )
      unless ok
        Rails.logger.info("[ENTRY-BLOCKED] #{ul.symbol} reason=#{reason}")
        return
      end

      # ensure at most one order per signal fingerprint (15m ST state + side)
      fp = signal_fingerprint(ul: ul, sig: sig)
      if Runner::RecentSignals.seen?(underlying_id: ul.id, fingerprint: fp, ttl: 30)
        Rails.logger.debug { "[StrategyLoop] duplicate signal suppressed #{ul.symbol} fp=#{fp}" }
        return
      end

      # choose CE/PE strike (ATMÂ±1 with filters)
      cp  = (sig.side == :buy_ce ? :ce : :pe)
      opt = Options::ChainAnalyzer.call(underlying: ul, side: cp)
      unless opt
        Rails.logger.info("[StrategyLoop] no viable option for #{ul.symbol} side=#{cp}")
        return
      end

      # size by rupees risk
      qty = Sizing.qty_for_rupees_risk(
        premium: opt[:ltp].to_f,
        lot_size: opt[:lot_size].to_i,
        sl_pct: 0.25,
        per_trade_rupees: @risk.per_trade_risk_rupees
      )
      if qty <= 0
        Rails.logger.info("[StrategyLoop] qty=0 for #{ul.symbol} (risk too small vs lot)")
        return
      end

      # scalp vs momentum risk params
      cs5  = CandleSeries.for(ul, '5m')
      cs15 = CandleSeries.for(ul, '15m')
      scalp_mode = Regime::ChopDetector.choppy_pre_entry?(cs5, cs15)
      entry_premium = opt[:ltp].to_f
      risk_params = Risk::ScalpParams.for(entry_premium: entry_premium, mode: (scalp_mode ? :scalp : :momentum))

      # final send (market entry by default)
      client_ref = "super:#{ul.id}:#{Time.now.to_i}:#{SecureRandom.hex(3)}"
      Orders::Executor.call(
        instrument: Instrument.find_by(security_id: opt[:security_id]),
        side: :buy,
        qty: qty,
        entry_type: :market, # or :limit with entry_price rounded to 0.05
        risk_params: risk_params,
        client_ref: client_ref
      )

      Rails.logger.info("[ENTRY] #{ul.symbol} #{sig.side} scalp=#{scalp_mode} ltp=#{entry_premium} qty=#{qty} ref=#{client_ref}")
    end

    def signal_fingerprint(ul:, sig:)
      # keep it simple, include side + minute timestamp
      t = Time.now.utc.strftime('%Y%m%d%H%M')
      "#{ul.id}:#{sig.side}:#{t}"
    end
  end
end


# File: app/services/scalp/budget.rb
module Scalp
  class Budget
    def initialize(session)
      @session = session
      @allow_entries = true
      @mutex = Mutex.new
    end

    def on_trade_closed!(realized_pnl:)
      @mutex.synchronize do
        @session.increment!(:realized_pnl, realized_pnl)
      end
    end

    def can_trade?
      @allow_entries && !daily_loss_hit?
    end

    def block_new_entries!
      @allow_entries = false
    end

    def daily_loss_hit?
      @session.realized_pnl <= -@session.max_day_loss
    end

    def risk_rupees
      BigDecimal(@session.params['risk_rupees'].to_s.presence || '600.0')
    end

    def profit_trigger_rupees
      BigDecimal(@session.params['profit_trigger_rupees'].to_s.presence || '1000.0')
    end

    def no_entries_after # "15:00" default
      (@session.params['no_entries_after'] || '15:00').to_s
    end

    def roster
      Array(@session.params['roster']).presence || %w[NIFTY BANKNIFTY]
    end
  end
end

# File: app/services/scalp/close_strikes_manager.rb
module Scalp
  class CloseStrikesManager
    class << self
      def start(roster)
        @mutex ||= Mutex.new
        @started = true
        @subscribed = Set.new # holds "SEGMENT:SECURITY_ID" keys
        @roster = Array(roster)

        # subscribe underlyings up front (indices/stocks)
        @roster.each { |symbol| subscribe_underlying!(symbol) }
      rescue StandardError => e
        Rails.logger.error("[CloseStrikesManager] start failed: #{e.class}: #{e.message}")
      end

      def stop
        @started = false
        # Optional: perform a bulk UNSUB here if you want to clean everything
        # unsubscribe_all!
      rescue StandardError => e
        Rails.logger.error("[CloseStrikesManager] stop failed: #{e.class}: #{e.message}")
      end

      # Subscribe option legs for a given symbol (e.g., ATM Â± 1)
      # Pass an array of [segment, security_id] pairs or Derivative records.
      def subscribe_legs!(legs)
        return unless @started

        pairs = normalize_pairs(legs)
        with_client do |client|
          to_add = filter_new(pairs)
          chunked(to_add, 90).each do |batch|
            client.subscribe_many(:quote, batch) # or :full if you want depth/OI
            mark_subscribed(batch)
          rescue StandardError => e
            Rails.logger.warn("[CloseStrikesManager] subscribe_many failed: #{e.class}: #{e.message}")
          end
        end
      end

      # Called by PositionGuard after exit; real impl can ref-count and UNSUB.
      def unsubscribe_if_unused(segment, security_id)
        # Optional: track refs per leg and UNSUB when count goes zero.
        # For now, we keep them subscribed; DhanHQ allows <=100 per frame and
        # we aim to stay within that via focused ATMÂ±1 usage.
        true
      end

      # Convenience for subscribing a single leg (Derivative or [seg, id])
      def subscribe_leg!(leg)
        subscribe_legs!([leg])
      end

      private

      # Subscribe the underlying itself so we can watch spot drift if desired
      def subscribe_underlying!(symbol)
        inst = Instrument.find_by(symbol: symbol) || Instrument.find_by(tradingsymbol: symbol)
        return unless inst

        segment = inst.exchange_segment # e.g., "NSE_FNO" for index futures; adjust per your mapping
        sec_id  = inst.security_id
        return unless segment.present? && sec_id.present?

        subscribe_legs!([[segment, sec_id]])
      end

      def with_client
        # Try to get the running WS client from your supervisor or directly:
        client = (WSSupervisor.respond_to?(:client) && WSSupervisor.client) ||
                 (defined?(DhanHQ::WS::Client) && DhanHQ::WS::Client.try(:current)) ||
                 (defined?(DhanHQ::WS::Client) && DhanHQ::WS::Client.try(:instance))

        unless client
          Rails.logger.warn('[CloseStrikesManager] WS client not available yet')
          return
        end
        yield client
      end

      def normalize_pairs(legs)
        legs.filter_map do |leg|
          case leg
          when Array
            seg, id = leg
            next unless seg && id

            [seg.to_s, id.to_i]
          else
            # treat as Derivative or a PORO responding to segment/security_id
            seg = leg.respond_to?(:exchange_segment) ? leg.exchange_segment : leg.segment
            id  = leg.respond_to?(:security_id) ? leg.security_id : leg.id
            next unless seg && id

            [seg.to_s, id.to_i]
          end
        end
      end

      def filter_new(pairs)
        @mutex.synchronize do
          pairs.reject { |seg, id| @subscribed.include?("#{seg}:#{id}") }
        end
      end

      def mark_subscribed(pairs)
        @mutex.synchronize do
          pairs.each { |seg, id| @subscribed.add("#{seg}:#{id}") }
        end
      end

      def chunked(arr, size)
        arr.each_slice(size).to_a
      end

      # If you later implement hard UNSUB:
      # def unsubscribe_all!
      #   with_client do |client|
      #     keys = @mutex.synchronize { @subscribed.to_a }
      #     pairs = keys.map { |k| seg, id = k.split(":"); [seg, id.to_i] }
      #     chunked(pairs, 90).each { |batch| client.unsubscribe_many(:quote, batch) }
      #   end
      #   @mutex.synchronize { @subscribed.clear }
      # end
    end
  end
end

# File: app/services/scalp/control.rb
module Scalp
  class Control
    def self.kill_today!(reason: 'manual')
      session = ScalpSession.find_by(trade_date: Date.current)
      session&.update!(status: :killed, params: session.params.merge(kill_reason: reason))
    end

    def self.stop_today!
      session = ScalpSession.find_by(trade_date: Date.current)
      session&.update!(status: :stopped)
    end
  end
end

# File: app/services/scalp/roster.rb
module Scalp
  class Roster
    def self.list(session)
      Array(session.params['roster']).presence || %w[NIFTY BANKNIFTY]
    end
  end
end

# File: app/services/scalp/rules.rb
module Scalp
  class Rules
    # candles => your CandleSeries for 1m
    # Expect: supertrend(direction: :up|:down), rsi(14), adx(14)
    def self.entry_signal(symbol, candles)
      st  = candles.supertrend(factor: 2.0, period: 10)
      rsi = candles.rsi(14).last
      adx = candles.adx(14).last
      dir = st.direction # :up or :down at last bar

      return nil unless adx && adx > 25

      if dir == :up && rsi && rsi > 50
        OpenStruct.new(direction: :bullish)
      elsif dir == :down && rsi && rsi < 50
        OpenStruct.new(direction: :bearish)
      end
    end
  end
end

# File: app/services/scalp/runner.rb
module Scalp
  class Runner < ApplicationService
    def initialize(session:)
      @session = session
      @running = true
    end

    def call
      @session.update!(status: :running, equity_peak: @session.equity)
      boot!

      loop do
        break unless @running

        enforce_time_window!
        enforce_kill_switch!
        sleep 1
      end
    ensure
      shutdown!
    end

    def stop!
      @running = false
    end

    private

    def boot!
      @budget = Budget.new(@session)

      Scalp::WSSupervisor.start(mode: :quote)
      CloseStrikesManager.start(Scalp::Roster.list(@session))
      Execution::PositionGuard.start(@budget)

      # 1-minute entries across roster
      Bars::FetchLoop.start(timeframe: '1m', symbols: Scalp::Roster.list(@session)) do |symbol, candles|
        next unless in_entry_window? && @budget.can_trade?

        signal = Rules.entry_signal(symbol, candles)
        next unless signal

        leg   = Strategy::OptionLocator.new(symbol).atm_leg_for(signal.direction) # CE for :bullish, PE for :bearish
        entry = Scalp::Sizing.for(leg, budget: @budget)
        next if entry.qty <= 0

        intent = Execution::DhanRouter.place_super_order!(leg, entry) # super order or fallback path
        Execution::PositionGuard.register_intent(intent)
        @session.increment!(:trades_count)
      end
    end

    def in_entry_window?
      now = Time.current.in_time_zone('Asia/Kolkata')
      cutoff = @budget.no_entries_after
      now < now.change(hour: cutoff.split(':')[0].to_i, min: cutoff.split(':')[1].to_i)
    end

    def enforce_time_window!
      now = Time.current.in_time_zone('Asia/Kolkata')
      return unless now >= now.change(hour: 15, min: 25)

      stop!
    end

    def enforce_kill_switch!
      @session.reload
      @session.update!(equity_peak: [@session.equity_peak, @session.equity].max)
      stop! if @budget.daily_loss_hit?
    end

    def shutdown!
      Execution::PositionGuard.stop
      CloseStrikesManager.stop
      WSSupervisor.stop
      Bars::FetchLoop.stop
      @session.update!(status: :stopped) if @session.running?
    end
  end
end

# File: app/services/scalp/sizing.rb
module Scalp
  class Sizing
    # derivative must respond to lot_size and ltp
    def self.for(derivative, budget:, sl_pct: BigDecimal('0.10'))
      lot_size    = derivative.lot_size.to_i
      entry_price = BigDecimal(derivative.ltp.to_s)
      risk        = budget.risk_rupees

      return OpenStruct.new(qty: 0, sl_pct: sl_pct) if entry_price <= 0 || lot_size <= 0

      lots = (risk / (entry_price * sl_pct * lot_size)).floor
      qty  = [lots, 1].max * lot_size
      OpenStruct.new(qty: qty, sl_pct: sl_pct)
    end
  end
end

# File: app/services/scalp/ws_supervisor.rb
# frozen_string_literal: true

module Scalp
  class WSSupervisor
    def initialize(indices:, mode: :quote)
      @mode = mode
      @indices = indices
      @bus = TickBus.new
      @agg = CandleAggregator.new(interval_sec: 300) { |ev| on_candle_close(ev) }
      @running = Concurrent::AtomicBoolean.new(false)
    end
    attr_reader :agg

    def start!
      return if @running.true?

      @running.make_true

      # seed 5m series for indices (from your Instrument helpers)
      @indices.each do |it|
        inst = Instrument.find_by(security_id: it[:security_id].to_s)
        next unless inst

        cs = inst.candle_series(interval: '5') || CandleSeries.new(symbol: inst.symbol, interval: '5')
        @agg.seed_series!(segment: it[:segment], security_id: it[:security_id], series: cs)
      end

      @ws = DhanHQ::WS::Client.new(mode: @mode).start
      @ws.on(:tick) { |t| on_tick(t) }
      @indices.each { |i| @ws.subscribe_one(segment: i[:segment], security_id: i[:security_id]) }

      @drainer = Thread.new do
        loop do
          @bus.drain
          sleep 0.01 if @running.true?
        end
      end
      self
    end

    def stop!
      @running.make_false
      @ws&.stop
      @drainer&.kill
    end

    def subscribe_option(seg:, sid:) = @ws.subscribe_one(segment: seg, security_id: sid)

    private

    def on_tick(t)
      TickCache.put(t)
      @bus.publish("ticks.#{t[:segment]}.#{t[:security_id]}", t)
      @agg.on_tick(t)
      CloseStrikesManager.instance.on_index_tick(t) # dynamic close strikes
    end

    def on_candle_close(ev)
      Strategy::SupertrendOptionLong.instance.on_index_candle(ev[:segment], ev[:security_id])
    end
  end
end

# File: app/services/sizing.rb
# app/services/sizing.rb
module Sizing
  # qty in contracts (lot-sized)
  def self.qty_for_rupees_risk(premium:, lot_size:, per_trade_rupees:, sl_pct: 0.25)
    return 0 if premium.to_f <= 0 || lot_size.to_i <= 0 || per_trade_rupees.to_i <= 0

    sl_points = PriceMath.round_tick(premium.to_f * sl_pct.to_f)
    per_lot_risk = sl_points * lot_size.to_i
    return 0 if per_lot_risk <= 0

    lots = (per_trade_rupees.to_i / per_lot_risk).floor
    [lots, 1].max * lot_size.to_i
  end
end


# File: app/services/smc/bos.rb
# SMC Component: Break of Structure (BOS)
module Smc
  class Bos < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      index = candles.size - 2
      return false if index < 4

      # Detect BOS: Higher High followed by higher low (bullish) or Lower Low + Lower High (bearish)
      last_high = candles[index].high
      prev_high = candles[index - 2].high
      last_low  = candles[index].low
      prev_low  = candles[index - 2].low

      bullish_bos = last_high > prev_high && candles[index + 1].low > prev_low
      bearish_bos = last_low < prev_low && candles[index + 1].high < prev_high

      bullish_bos || bearish_bos
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/choch.rb
# SMC Component: Change of Character (CHOCH)
module Smc
  class Choch < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      recent = candles.last(5)
      prev = candles.last(10)[0...5]

      bullish_choch = recent.first.low > prev.map(&:low).max && recent.last.close > recent.first.open
      bearish_choch = recent.first.high < prev.map(&:high).min && recent.last.close < recent.first.open

      bullish_choch || bearish_choch
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/fair_value_gap.rb
# frozen_string_literal: true

module Smc
  class FairValueGap < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 3

      # Use last 3 candles
      c1, c2, c3 = candles[-3..]

      bullish_gap = c3.low > c1.high
      bearish_gap = c3.high < c1.low

      bullish_gap || bearish_gap
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/inducement.rb
# frozen_string_literal: true

module Smc
  class Inducement < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      lookback = 15
      current = candles.last
      past = candles.last(lookback + 1)[0...lookback]

      inducement_up = false
      inducement_down = false

      # False breakout above previous highs (trap long buyers)
      highest_past_high = past.map(&:high).max
      inducement_up = true if current.high > highest_past_high && current.close < highest_past_high && current.bearish?

      # False breakdown below previous lows (trap short sellers)
      lowest_past_low = past.map(&:low).min
      inducement_down = true if current.low < lowest_past_low && current.close > lowest_past_low && current.bullish?

      inducement_up || inducement_down
    rescue StandardError => e
      Rails.logger.error("SMC::Inducement error: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/interpreter.rb
module SMC
  class Interpreter < ApplicationService
    def initialize(analysis_hash)
      @analysis = analysis_hash
    end

    def call
      client = OpenAI::Client.new(...)
      prompt = build_prompt
      response = client.chat(... prompt ...)
      JSON.parse(response.dig("choices", 0, "message", "content"))
    end

    def build_prompt
      openai_prompt_for_smc(@analysis)
    end
  end
end


# File: app/services/smc/mitigation.rb
# frozen_string_literal: true

module Smc
  class Mitigation < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      # Reuse previously defined Order Blocks
      order_blocks = Smc::OrderBlock.call(series: series)
      return false if order_blocks.blank?

      # Pick the last known OB zone
      ob = order_blocks.last
      return false unless ob[:index] && ob[:type] && ob[:range]

      # Only consider mitigation attempts that come after 3 candles from OB
      mitigation_index = ob[:index] + 3
      return false if candles.size <= mitigation_index

      # Look for price touching or reacting from OB zone in later candles
      candles[mitigation_index..].each do |candle|
        if ob[:type] == :bullish
          return true if candle.low <= ob[:range][:low] && candle.close > ob[:range][:low]
        elsif ob[:type] == :bearish
          return true if candle.high >= ob[:range][:high] && candle.close < ob[:range][:high]
        end
      end

      false
    rescue StandardError => e
      Rails.logger.error("Mitigation check failed: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/order_block.rb
# frozen_string_literal: true

module Smc
  class OrderBlock < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      last_index = candles.size - 1
      lookback = 10

      (last_index - lookback).upto(last_index - 2) do |i|
        curr = candles[i]
        nxt  = candles[i + 1]

        # Bullish Order Block: Last bearish candle before strong bullish candle
        return true if curr.bearish? && nxt.bullish? && nxt.close > nxt.open + series.atr && price_respected_order_block?(curr.low, :bullish)

        # Bearish Order Block: Last bullish candle before strong bearish candle
        return true if curr.bullish? && nxt.bearish? && nxt.close < nxt.open - series.atr && price_respected_order_block?(curr.high, :bearish)
      end

      false
    end

    private

    attr_reader :series, :candles

    def price_respected_order_block?(level, direction)
      last = candles.last
      if direction == :bullish
        last.low >= level
      else
        last.high <= level
      end
    end
  end
end


# File: app/services/strategies/base_indicator_strategy.rb
module Strategies
  class BaseIndicatorStrategy
    attr_reader :instrument, :series, :interval

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def initialize(instrument, series: nil, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = series || instrument.candles(interval)
    end

    def series
      @series ||= instrument.candles(interval)
    end

    def candles
      @candles ||= series.candles
    end

    def closes
      @closes ||= candles.map(&:close)
    end

    def highs
      @highs ||= candles.map(&:high)
    end

    def lows
      @lows ||= candles.map(&:low)
    end

    def opens
      @opens ||= candles.map(&:open)
    end

    def volumes
      @volumes ||= candles.map(&:volume)
    end

    def last_candle
      @last_candle ||= candles.last
    end

    def signal?
      raise NotImplementedError, "#{self.class.name} must implement #signal?"
    end

    def signal_details
      result = signal?
      return nil unless result

      {
        signal: result,
        confidence: confidence_score,
        reason: reason_text
      }
    end
  end
end

# File: app/services/strategies/basic_trend_strategy.rb
module Strategies
  class BasicTrendStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw_data = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw_data)
    end

    def call
      calc = Indicators::Calculator.new(@series)
      if calc.bullish_signal?
        :buy_ce
      elsif calc.bearish_signal?
        :buy_pe
      else
        :hold
      end
    end
  end
end

# File: app/services/strategies/bollinger_rsi.rb
module Strategies
  class BollingerRsi < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      close = instrument.candles.closes.last
      bands = instrument.bollinger_bands

      pp "RSI: #{rsi}, Close: #{close}, Bands: #{bands.inspect}"
      return :buy_ce if close > bands[:upper] && rsi < 70

      :buy_pe if close < bands[:lower] && rsi > 30
    end

    def confidence_score = 65
    def reason_text = "BB/RSI: Close=#{series.closes.last}, RSI=#{series.rsi}, Bands=#{series.bollinger_bands.inspect}"
  end
end



# File: app/services/strategies/donchian_adx.rb
module Strategies
  class DonchianAdx < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      donchians = instrument.donchian_channel
      adx = instrument.adx

      return :buy_ce if close > donchians.first.upper_bound && adx > 25

      :buy_pe if close < donchians.first.lower_bound && adx > 25
    end

    def confidence_score = 70
    def reason_text = "Donchian/ADX: Close=#{instrument.candles.closes.last}, Donchian=#{instrument.donchian_channel.first.inspect}, ADX=#{instrument.adx}"
  end
end



# File: app/services/strategies/holy_grail_strategy.rb
# frozen_string_literal: true

module Strategies
  class HolyGrailStrategy < BaseIndicatorStrategy
    STRATEGIES = {
      rsi_adx: Strategies::RsiAdxCombo,
      macd_supertrend: Strategies::MacdSupertrend,
      bollinger_rsi: Strategies::BollingerRsi,
      donchian_adx: Strategies::DonchianAdx
      # vwap_rsi: Strategies::VwapRsi,
      # obv_macd: Strategies::ObvMacd
    }.freeze

    STRATEGY_WEIGHTS = {
      rsi_adx: 0.15,
      macd_supertrend: 0.2,
      bollinger_rsi: 0.15,
      donchian_adx: 0.15
      # vwap_rsi: 0.15,
      # obv_macd: 0.2
    }.freeze

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def call
      results = run_all_strategies

      top_signal = results[:votes].max_by { |_signal, w| w }&.first || :hold
      final_score = results[:score]

      {
        strategy: :holygrail,
        instrument: instrument.symbol_name,
        action: top_signal,
        confidence: final_score.round(2),
        reasons: results[:reasons],
        telemetry: results[:telemetry],
        decision: final_score >= 0.65 ? top_signal : :hold
      }
    end

    # âœ¨ AI Prompt Payload: use this output to pass to OpenAI
    def ai_prompt_payload
      result = call
      <<~PROMPT.strip
        Instrument: #{result[:instrument]}
        Final Action: #{result[:action].to_s.upcase}
        Confidence Score: #{result[:confidence]}%
        Decision Reasoning:
        #{result[:reasons].map { |r| "- #{r}" }.join("\n")}

        Indicator Telemetry:
        #{result[:telemetry].map { |k, v| "#{k.to_s.titleize}: #{v}" }.join("\n")}

        Based on the above, analyze the current market structure, probable support/resistance zones, and possible close for today. If market is closed, prepare analysis for next session. Suggest any CE/PE trade or HOLD decision with SL/TP levels.
      PROMPT
    end

    private

    attr_reader :instrument, :series

    def run_all_strategies
      results = {
        score: 0.0,
        votes: Hash.new(0),
        reasons: [],
        telemetry: {}
      }

      STRATEGIES.each do |key, klass|
        strat = klass.new(instrument, series: series)
        outcome = strat.signal_details

        next unless outcome

        weight = STRATEGY_WEIGHTS[key]
        results[:votes][outcome[:signal]] += weight
        results[:score] += outcome[:confidence] * weight
        results[:reasons] << "#{key.to_s.titleize} â†’ #{outcome[:signal].to_s.upcase} (#{(outcome[:confidence] * weight).round(1)} pts)"
        results[:telemetry][key] = outcome[:reason]
      end

      results
    end
  end
end

# File: app/services/strategies/liquidity_grab_strategy.rb
module Strategies
  class LiquidityGrabStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      grab_up = @series.liquidity_grab_up?
      grab_down = @series.liquidity_grab_down?

      return :short if grab_up
      return :long  if grab_down

      false
    end
  end
end

# File: app/services/strategies/macd_supertrend.rb
module Strategies
  class MacdSupertrend < BaseIndicatorStrategy
    def signal?
      macd = instrument.macd
      supertrend = instrument.supertrend_signal

      macd_line = macd[:macd]
      signal_line = macd[:signal]

      if macd_line > signal_line && supertrend == :long_entry
        :buy_ce
      elsif macd_line < signal_line && supertrend == :short_entry
        :buy_pe
      end
    end

    def confidence_score = 75
    def reason_text = "MACD/ST: MACD=#{instrument.macd[:macd]}, Signal=#{instrument.macd[:signal]}, Supertrend=#{instrument.supertrend_signal}"
  end
end



# File: app/services/strategies/obv_macd.rb
module Strategies
  class ObvMacd < BaseIndicatorStrategy
    def signal?
      obv = series.obv
      macd = series.macd
      macd_line = macd.last[:macd]
      signal_line = macd.last[:signal]

      return :buy_ce if obv_trending_up?(obv) && macd_line > signal_line

      :buy_pe if obv_trending_down?(obv) && macd_line < signal_line
    end

    def obv_trending_up?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b > a }
    end

    def obv_trending_down?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b < a }
    end

    def confidence_score = 70
    def reason_text = "OBV/MACD: OBV trend detected, MACD=#{series.macd.last[:macd]}, Signal=#{series.macd.last[:signal]}"
  end
end


# File: app/services/strategies/price_action_strategy.rb
module Strategies
  class PriceActionStrategy < ApplicationService
    def initialize(instrument, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = CandleSeries.new(symbol: instrument.symbol_name, interval:)
      raw = instrument.intraday_ohlc(interval: interval)
      @series.load_from_raw(raw)
    end

    def signal?
      # basic setup
      @last = @series.candles.last
      @prev = @series.candles[-2]
      @third = @series.candles[-3]

      bullish_pinbar? || bearish_engulfing? || breakout_candle?
    end

    private

    def bullish_pinbar?
      body = (@last.close - @last.open).abs
      lower_wick = @last.open - @last.low if @last.bullish?
      lower_wick = @last.close - @last.low if @last.bearish?

      lower_wick && lower_wick > body * 2 && @last.close > @last.open
    end

    def bearish_engulfing?
      @prev.bullish? &&
        @last.bearish? &&
        @last.open > @prev.close &&
        @last.close < @prev.open
    end

    def breakout_candle?
      highs = @series.candles[-5..-2].map(&:high)
      @last.high > highs.max && @last.close > highs.max
    end
  end
end

# File: app/services/strategies/rsi_adx_combo.rb
module Strategies
  class RsiAdxCombo < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      adx = instrument.adx

      return :buy_ce if rsi > 30 && adx > 20

      :buy_pe if rsi < 70 && adx > 20
    end

    def confidence_score = 70

    def reason_text
      "RSI/ADX Combo: RSI=#{instrument.rsi.round(2)}, ADX=#{instrument.adx.round(2)}"
    end
  end
end



# File: app/services/strategies/smart_money_strategy.rb
module Strategies
  class SmartMoneyStrategy
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      fvg     = Indicators::FairValueGap.new(@series).detect.last
      blocks  = Indicators::OrderBlock.new(@series).bullish_order_blocks.last
      bos     = Indicators::Structure.new(@series).break_of_structure.last

      return false unless bos && fvg && blocks

      # Apply filters (e.g., direction match)
      bos[:direction] == :up && blocks[:low] > fvg[:from]
    end

    def analysis_result
      {
        symbol: @instrument.symbol_name,
        interval: @series.interval,
        structure: Indicators::Structure.new(@series).summary,
        order_blocks: Indicators::OrderBlock.new(@series).summary,
        fair_value_gaps: Indicators::FairValueGap.new(@series).summary,
        current_price: @series.closes.last,
        signal: signal? ? :long_entry : :hold
      }
    end
  end
end


# File: app/services/strategies/smc_strategy.rb
# frozen_string_literal: true

module Strategies
  class SmcStrategy < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
      @score = 0
      @reasons = []
    end

    def call
      return hold_signal('Not enough candles') if candles.size < 50

      # Run all Smc indicators
      bos     = Smc::Bos.call(series: series)
      choch   = Smc::Choch.call(series: series)
      order_blocks = Smc::OrderBlock.call(series: series)
      fvg     = Smc::FairValueGap.call(series: series)
      mitg    = Smc::Mitigation.call(series: series)
      induc   = Smc::Inducement.call(series: series)
      grab_up = series.liquidity_grab_up?
      grab_dn = series.liquidity_grab_down?

      # Scoring
      apply_score(:bos, bos)
      apply_score(:choch, choch)
      apply_score(:order_block, order_blocks)
      apply_score(:fvg, fvg)
      apply_score(:mitigation, mitg)
      apply_score(:inducement, induc)
      apply_score(:liquidity_grab_up, grab_up)
      apply_score(:liquidity_grab_down, grab_dn)

      confidence = score

      if confidence >= 70 && (bos || choch)
        action = if grab_up
                   :buy_pe
                 else
                   grab_dn ? :buy_ce : :hold
                 end
        build_signal(action, confidence)
      else
        hold_signal("Low Smc confidence: #{confidence}%")
      end
    rescue StandardError => e
      notify_failure(e, 'SmcStrategy')
      hold_signal("Exception: #{e.message}")
    end

    private

    attr_reader :series, :score, :reasons, :candles

    def apply_score(name, result)
      return unless result

      weight = case name
               when :bos then 20
               when :choch then 15
               when :order_block then 10
               when :fvg then 10
               when :mitigation then 10
               when :inducement then 10
               when :liquidity_grab_up, :liquidity_grab_down then 15
               else 0
               end

      @score += weight
      reasons << "#{name.to_s.titleize} = TRUE (+#{weight})"
    end

    def build_signal(action, confidence)
      {
        strategy: :Smc,
        action: action,
        confidence: confidence,
        reasons: reasons,
        stop_loss: derive_sl(action),
        take_profit: derive_tp(action)
      }
    end

    def derive_sl(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.low - atr : last.high + atr
    end

    def derive_tp(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.close + (3 * atr) : last.close - (3 * atr)
    end

    def hold_signal(reason)
      {
        strategy: :Smc,
        action: :hold,
        confidence: score,
        reasons: reasons << reason
      }
    end
  end
end


# File: app/services/strategies/vwap_rsi.rb
module Strategies
  class VwapRsi < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      vwap = instrument.vwap
      rsi = instrument.rsi

      return :buy_ce if close > vwap && rsi > 40

      :buy_pe if close < vwap && rsi < 60
    end

    def confidence_score = 60
    def reason_text = "VWAP/RSI: Close=#{series.closes.last}, VWAP=#{series.vwap}, RSI=#{series.rsi.last}"
  end
end



# File: app/services/strategy/mtf_smc_entry.rb
# frozen_string_literal: true

module Strategy
  class MtfSmcEntry
    Result = Struct.new(:direction, :why, :meta, keyword_init: true) # direction: :bullish/:bearish

    def self.call(instrument)
      s = Mtf::SeriesLoader.load(instrument: instrument, base_interval: '5')
      return nil unless s&.h4 && s.h1 && s.m15

      # 4H: Direction / Key levels / S&D
      bias = case Mtf::Structure.trend(s.h4, lookback: 8)
             when :up   then :bullish
             when :down then :bearish
             else :none
             end

      Rails.logger.debug { "#{instrument.symbol_name}: #{bias}" }
      return nil if bias == :none

      # 1H: Trend + BOS or CHOCH near OB/Fvg/liquidity
      h1_trend = Mtf::Structure.trend(s.h1, lookback: 6)
      bos      = Mtf::Structure.bos(s.h1, dir: (bias == :bullish ? :up : :down))
      choch    = Mtf::Structure.choch(s.h1, prior_dir: (bias == :bullish ? :down : :up))
      ob_zone  = Mtf::OrderBlock.last_before_bos(s.h1, bos)
      fvg_list = Mtf::Fvg.scan(s.h1, lookback: 40)
      pools    = (bias == :bullish ? Mtf::Liquidity.equal_lows(s.h1) : Mtf::Liquidity.equal_highs(s.h1))

      # Require context alignment: trend or BOS/CHOCH in bias direction
      aligned = (h1_trend == (bias == :bullish ? :up : :down)) || bos || choch
      return nil unless aligned

      # 15m: Confirmation (BOS + pullback to OB/Fvg or reaction at liquidity)
      m15_bos = Mtf::Structure.bos(s.m15, dir: (bias == :bullish ? :up : :down))
      return nil unless m15_bos

      last_price = s.m15.candles.last.close
      confirm =
        if ob_zone && Mtf::OrderBlock.price_touches?(ob_zone, last_price)
          :ob_touch
        elsif (gap = fvg_list.last) && Mtf::Fvg.price_in_gap?(gap, last_price)
          :fvg_retrace
        elsif (pool = pools.last) && ((bias == :bullish && last_price >= pool.level) || (bias == :bearish && last_price <= pool.level))
          :liquidity_sweep
        else
          :bos_only
        end

      # Extra filter: Supertrend & ADX on 15m
      st_sig = s.m15.supertrend_signal
      strong = begin
        ta = TechnicalAnalysis::Adx.calculate(s.m15.hlc, period: 14).first&.adx.to_f
        ta >= 18
      rescue StandardError
        true
      end
      return nil unless strong &&
                        ((bias == :bullish && st_sig == :long_entry) || (bias == :bearish && st_sig == :short_entry))

      Result.new(
        direction: (bias == :bullish ? :bullish : :bearish),
        why: "4H=#{bias} 1H_trend=#{h1_trend} 15m=#{confirm}",
        meta: { bos: !!bos, choch: !!choch, ob: !!ob_zone, fvg: fvg_list.any?, pools: pools.any? }
      )
    end
  end
end


# File: app/services/strategy/router.rb
# frozen_string_literal: true

class Strategy::Router
  def self.for(instrument)
    # Feature flag or config lookup could live here
    Strategies::SupertrendContinuation.new(instrument: instrument, tf: '5m')
  end
end


# File: app/services/telegram_notifier.rb
# frozen_string_literal: true

require 'net/http'
require 'uri'

class TelegramNotifier
  TELEGRAM_API = 'https://api.telegram.org'

  def self.send_message(text, chat_id: nil, **extra_params)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendMessage', chat_id:, text:, **extra_params)
  end

  def self.send_chat_action(action:, chat_id: nil)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendChatAction', chat_id:, action:)
  end

  private_class_method def self.post(method, **params)
    uri = URI("#{TELEGRAM_API}/bot#{ENV.fetch('TELEGRAM_BOT_TOKEN')}/#{method}")
    res = Net::HTTP.post_form(uri, params)
    Rails.logger.error("Telegram #{method} failed: #{res.body}") unless res.is_a?(Net::HTTPSuccess)
    res
  rescue StandardError => e
    Rails.logger.error("Telegram #{method} error: #{e.message}")
  end
end


# File: app/strategies/base_strategy.rb
# frozen_string_literal: true

class BaseStrategy
  attr_reader :instrument, :tf, :settings

  def initialize(instrument:, tf: '5m', settings: {})
    @instrument = instrument
    @tf = tf
    @settings = settings
    @last_signal_at = nil
  end

  # Called on every new bar close
  def on_bar(bar:)
    # override
  end

  # Return a SignalStruct or nil
  def entry_signal
    nil
  end

  # Return a SignalStruct or nil (given active position side)
  def exit_signal(position_side:, entry_at:, ltp:)
    nil
  end

  protected

  def recent_signal_cooldown?(seconds:)
    return false unless @last_signal_at

    (Time.now - @last_signal_at) < seconds
  end

  def mark_signal!
    @last_signal_at = Time.now
  end
end


# File: app/strategies/signal.rb
# frozen_string_literal: true

SignalStruct = Struct.new(
  :type,       # :entry or :exit
  :side,       # :buy_ce / :buy_pe or :close
  :reason,     # short string
  :confidence, # 0.0..1.0
  :context,    # hash of indicator values
  keyword_init: true
)


# File: app/strategies/supertrend_continuation.rb
# frozen_string_literal: true

class Strategies::SupertrendContinuation < BaseStrategy
  ADX_MIN = 18

  def on_bar(bar:)
    # compute and cache indicators for the latest bar snapshot
    @cs1 = CandleSeries.for(instrument, '1m')
    @cs5 = CandleSeries.for(instrument, '5m')
    @cs15 = CandleSeries.for(instrument, '15m')

    @st5  = @cs5.supertrend(len: 10, factor: 2.0)
    @st15 = @cs15.supertrend(len: 10, factor: 2.0)
    @adx5 = begin
      @cs5.adx(14)
    rescue StandardError
      nil
    end

    @vwap5 = begin
      vwap_for(@cs5)
    rescue StandardError
      nil
    end
    @close = bar[:close] || bar.close

    @long_bias  = st_up?(@st5) && st_up?(@st15) && vwap_ok?(:long)
    @short_bias = st_down?(@st5) && st_down?(@st15) && vwap_ok?(:short)
  end

  # ---------- ENTRY ----------
  def entry_signal
    return nil if recent_signal_cooldown?(seconds: 30) # avoid rapid refires
    return nil unless (@adx5 || 0) >= ADX_MIN

    if @long_bias
      mark_signal!
      return SignalStruct.new(
        type: :entry, side: :buy_ce, reason: 'ST align + ADX + VWAP long',
        confidence: conf_score(:long),
        context: ctx
      )
    end

    if @short_bias
      mark_signal!
      return SignalStruct.new(
        type: :entry, side: :buy_pe, reason: 'ST align + ADX + VWAP short',
        confidence: conf_score(:short),
        context: ctx
      )
    end
    nil
  end

  # ---------- EXIT ----------
  # Basic exits for a runner already in market
  def exit_signal(position_side:, entry_at:, ltp:)
    # opposite ST flip (hard exit)
    if position_side == :buy_ce && st_down?(@st5)
      return SignalStruct.new(type: :exit, side: :close, reason: 'ST flip down', confidence: 1.0, context: ctx)
    elsif position_side == :buy_pe && st_up?(@st5)
      return SignalStruct.new(type: :exit, side: :close, reason: 'ST flip up', confidence: 1.0, context: ctx)
    end

    # VWAP loss + momentum fade (soft exit)
    if position_side == :buy_ce && @vwap5 && @close < @vwap5 && (@adx5 || 0) < ADX_MIN
      return SignalStruct.new(type: :exit, side: :close, reason: 'VWAP loss + weak ADX (CE)', confidence: 0.8, context: ctx)
    elsif position_side == :buy_pe && @vwap5 && @close > @vwap5 && (@adx5 || 0) < ADX_MIN
      return SignalStruct.new(type: :exit, side: :close, reason: 'VWAP loss + weak ADX (PE)', confidence: 0.8, context: ctx)
    end

    # Time stop (e.g., >8m with <0.5R progress) â€” compute R from settings if you track entry premium
    if entry_at && (Time.now - entry_at) > 8 * 60
      return SignalStruct.new(type: :exit, side: :close, reason: 'time stop 8m', confidence: 0.6, context: ctx)
    end

    nil
  end

  private

  def vwap_for(cs)
    return nil unless cs.respond_to?(:vwap)

    cs.vwap
  end

  def st_up?(st)   = st && (st.respond_to?(:trend_up?)   ? st.trend_up?   : st[:trend] == :up)
  def st_down?(st) = st && (st.respond_to?(:trend_down?) ? st.trend_down? : st[:trend] == :down)

  def vwap_ok?(dir)
    return true unless @vwap5 # if VWAP unavailable, don't block
    return @close > @vwap5 if dir == :long
    return @close < @vwap5 if dir == :short

    true
  end

  def conf_score(dir)
    base = 0.6
    base += 0.2 if dir == :long && st_up?(@st15)
    base += 0.2 if dir == :short && st_down?(@st15)
    base += 0.1 if (@adx5 || 0) >= (ADX_MIN + 5)
    base.clamp(0.0, 1.0)
  end

  def ctx
    {
      adx5: @adx5,
      st5: (if @st5.respond_to?(:trend)
              @st5.trend
            else
              (if @long_bias
                 :up
               else
                 (@short_bias ? :down : :flat)
               end)
            end),
      st15: (@st15.respond_to?(:trend) ? @st15.trend : nil),
      vwap: @vwap5,
      close: @close
    }
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/import_instruments.rake
namespace :instruments do
  desc 'Import instruments from DhanHQ CSV'
  task import: :environment do
    pp 'Starting instruments import...'
    start_time = Time.current

    begin
      InstrumentsImporter.import_from_url

      duration = Time.current - start_time
      pp "\nImport completed successfully in #{duration.round(2)} seconds!"
      pp "Total Instruments: #{Instrument.count}"
      pp "Total Derivatives: #{Derivative.count}"

      # Show some stats
      pp "\n--- Stats ---"
      pp "NSE Instruments: #{Instrument.nse.count}"
      pp "BSE Instruments: #{Instrument.bse.count}"
      pp "NSE Derivatives: #{Derivative.nse.count}"
      pp "BSE Derivatives: #{Derivative.bse.count}"
      pp "Options: #{Derivative.options.count}"
      pp "Futures: #{Derivative.futures.count}"
      pp 'Instruments: Instrument.count'
      pp 'Derivatives: Derivative.count'
      pp "TOTAL: #{Instrument.count + Derivative.count}"
    rescue StandardError => e
      pp "Import failed: #{e.message}"
      pp e.backtrace.join("\n")
    end
  end

  desc 'Clear all instruments and derivatives'
  task clear: :environment do
    pp 'Clearing all instruments and derivatives...'
    Derivative.delete_all
    Instrument.delete_all
    pp 'Cleared successfully!'
  end

  desc 'Reimport (clear and import)'
  task reimport: %i[clear import]
end


# File: lib/tasks/trader.rake
# lib/tasks/trader.rake
namespace :trader do
  desc 'Start strategy and positions loops'
  task start: :environment do
    instruments = Instrument.where(symbol: %w[NIFTY BANKNIFTY SENSEX]) # adjust
    $strategy_loop  = Runner::StrategyLoop.new(instruments: instruments).start
    $positions_loop = Runner::PositionsLoop.new.start
    puts 'Loops started. Ctrl-C to stop (if foreground).'
    sleep
  end

  desc 'Stop loops (flip kill-switch)'
  task stop: :environment do
    Setting.put('trading_enabled', 'false')
    puts 'Kill-switch flipped off.'
  end
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end


# File: config/initializers/dhanhq.rb
require 'DhanHQ'

DhanHQ.configure_with_env
DhanHQ.logger.level = (ENV['DHAN_LOG_LEVEL'] || 'INFO').upcase.then { |l| Logger.const_get(l) }

# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += %i[
  passw email secret token _key crypt salt certificate otp ssn cvv cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/openai.rb
OpenAI.configure do |config|
  config.access_token = ENV.fetch('OPENAI_API_KEY', nil)
end

# File: config/initializers/ws_hub.rb
# frozen_string_literal: true

if ENV['ENABLE_WS'] == 'true'
  cfg = Rails.application.config_for(:dhan_ws)
  Rails.application.config.to_prepare do
    Live::WsHub.instance.start!(mode: (cfg['mode'] || 'quote').to_sym)
    Array(cfg['initial']).each do |h|
      Live::WsHub.instance.subscribe(seg: h[:segment], sid: h[:security_id])
    end
  end

  at_exit do
    Live::WsHub.instance.stop!
  rescue StandardError
    nil
  end
end


