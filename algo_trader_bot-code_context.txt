# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/jobs/scalp_session_runner_job.rb
class ScalpSessionRunnerJob < ApplicationJob
  queue_as :default

  # Long-running job â€“ ensure delayed_job timeout is high enough or disabled for this queue
  def perform(date: Date.current, capital: 100000.0, max_day_loss: 3000.0, roster: %w[NIFTY BANKNIFTY], risk_rupees: 600.0)
    session = ScalpSession.find_or_create_by!(trade_date: date) do |s|
      s.capital      = capital
      s.max_day_loss = max_day_loss
      s.params = {
        'risk_rupees' => risk_rupees,
        'roster' => roster,
        'profit_trigger_rupees' => 1000.0,
        'no_entries_after' => '15:00'
      }
    end
    Scalp::Runner.call(session: session)
  end
end

# File: app/jobs/scalp_session_stop_job.rb
class ScalpSessionStopJob < ApplicationJob
  queue_as :default

  def perform(date: Date.current)
    if (session = ScalpSession.find_by(trade_date: date))
      # simple signal: flip status â†’ runner loop will see it
      session.update!(status: :killed)
    end
  end
end

# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/candle.rb
class Candle
  attr_reader :timestamp, :open, :high, :low, :close, :volume

  def initialize(ts:, open:, high:, low:, close:, volume:)
    @timestamp = ts
    @open = open.to_f
    @high = high.to_f
    @low = low.to_f
    @close = close.to_f
    @volume = volume.to_i
  end

  def bullish? = close >= open
  def bearish? = close < open
end

# File: app/models/candle_series.rb
class CandleSeries
  include Enumerable

  attr_reader :symbol, :interval, :candles

  def initialize(symbol:, interval: '5')
    @symbol = symbol
    @interval = interval
    @candles = []
  end

  def each(&) = candles.each(&)
  def add_candle(candle) = candles << candle

  def load_from_raw(response)
    normalise_candles(response).each do |row|
      @candles << Candle.new(
        ts: Time.zone.parse(row[:timestamp].to_s),
        open: row[:open], high: row[:high],
        low: row[:low], close: row[:close],
        volume: row[:volume]
      )
    end
  end

  def normalise_candles(resp)
    return [] if resp.blank?

    return resp.map { |c| slice_candle(c) } if resp.is_a?(Array)

    raise "Unexpected candle format: #{resp.class}" unless resp.is_a?(Hash) && resp['high'].is_a?(Array)

    size = resp['high'].size
    (0...size).map do |i|
      {
        open: resp['open'][i].to_f,
        close: resp['close'][i].to_f,
        high: resp['high'][i].to_f,
        low: resp['low'][i].to_f,
        timestamp: Time.zone.at(resp['timestamp'][i]),
        volume: resp['volume'][i].to_i
      }
    end
  end

  def opens  = candles.map(&:open)
  def closes = candles.map(&:close)
  def highs  = candles.map(&:high)
  def lows   = candles.map(&:low)

  def hlc
    candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        high: c.high,
        low: c.low,
        close: c.close
      }
    end
  end

  def atr(period = 14)
    TechnicalAnalysis::Atr.calculate(hlc, period: period).first.atr
  end

  def swing_high?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].high
    left = candles[(index - lookback)...index].map(&:high)
    right = candles[(index + 1)..(index + lookback)].map(&:high)
    current > left.max && current > right.max
  end

  def swing_low?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].low
    left = candles[(index - lookback)...index].map(&:low)
    right = candles[(index + 1)..(index + lookback)].map(&:low)
    current < left.min && current < right.min
  end

  def recent_highs(n = 20)
    candles.last(n).map(&:high)
  end

  def recent_lows(n = 20)
    candles.last(n).map(&:low)
  end

  def previous_swing_high
    recent_highs.sort[-2] # 2nd highest
  end

  def previous_swing_low
    recent_lows.sort[1]   # 2nd lowest
  end

  def liquidity_grab_up?(lookback: 20)
    high_now = candles.last.high
    high_prev = previous_swing_high

    high_now > high_prev &&
      candles.last.close < high_prev && # Rejection after breakout
      candles.last.bearish?
  end

  def liquidity_grab_down?(lookback: 20)
    low_now = candles.last.low
    low_prev = previous_swing_low

    low_now < low_prev &&
      candles.last.close > low_prev && # Rejection after breakdown
      candles.last.bullish?
  end

  def rsi(period = 14)
    RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: closes, period: period).call
  end

  def moving_average(period = 20)
    RubyTechnicalAnalysis::MovingAverages.new(series: closes, period: period)
  end

  def sma(period = 20)
    moving_average(period).sma
  end

  def ema(period = 20)
    moving_average(period).ema
  end

  def macd(fast_period = 12, slow_period = 26, signal_period = 9)
    macd = RubyTechnicalAnalysis::Macd.new(series: closes, fast_period: fast_period, slow_period: slow_period, signal_period: signal_period)
    macd.call
  end

  def rate_of_change(period = 5)
    closes = self.closes
    return nil if closes.size < period + 1

    # ((current_close - close_n_periods_ago) / close_n_periods_ago) * 100
    roc_series = []
    closes.each_with_index do |price, idx|
      if idx < period
        roc_series << nil # not enough data for these initial points
      else
        previous_price = closes[idx - period]
        roc_series << (((price - previous_price) / previous_price.to_f) * 100.0)
      end
    end
    roc_series
  end

  def supertrend_signal
    trend_line = Indicators::Supertrend.new(series: self).call
    return nil if trend_line.empty?

    latest_close = closes.last
    latest_trend = trend_line.last

    return :long_entry if latest_close > latest_trend

    :short_entry if latest_close < latest_trend
  end

  def inside_bar?(i)
    return false if i < 1

    curr = @candles[i]
    prev = @candles[i - 1]
    curr.high < prev.high && curr.low > prev.low
  end

  def bollinger_bands(period: 20)
    return nil if candles.size < period

    bb = RubyTechnicalAnalysis::BollingerBands.new(
      series: closes,
      period: period
    ).call

    { upper: bb[0], lower: bb[1], middle: bb[2] }
  end

  def donchian_channel(period: 20)
    return nil if candles.size < period

    dc = candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        value: c.close
      }
    end
    TechnicalAnalysis::Dc.calculate(dc, period: period)
  end
end

# File: app/models/concerns/candle_extension.rb
# Extend Instrument with candle series integration
module CandleExtension
  extend ActiveSupport::Concern

  included do
    def candles(interval: '5')
      @ohlc_cache ||= {}
      return @ohlc_cache[interval] if @ohlc_cache[interval] && !ohlc_stale?(interval)

      raw_data = intraday_ohlc(interval: interval)
      return nil if raw_data.blank?

      @ohlc_cache[interval] = CandleSeries.new(symbol: symbol_name, interval: interval).tap do |series|
        series.load_from_raw(raw_data)
      end
    end

    def ohlc_stale?(interval)
      return true unless @last_ohlc_fetched

      Time.current - (@last_ohlc_fetched[interval] ||= 1.hour.ago) > 5.minutes
    ensure
      @last_ohlc_fetched ||= {}
      @last_ohlc_fetched[interval] = Time.current
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end

    def rsi(period = 14, interval: '5')
      cs = candles(interval: interval)
      cs&.rsi(period)
    end

    def macd(fast_period = 12, slow_period = 26, signal_period = 9, interval: '5')
      cs = candles(interval: interval)
      macd_result = cs&.macd(fast_period, slow_period, signal_period)
      return nil unless macd_result

      {
        macd: macd_result[0],
        signal: macd_result[1],
        histogram: macd_result[2]
      }
    end

    def adx(period = 14, interval: '5')
      cs = candles(interval: interval)
      closes = cs&.closes
      highs  = cs&.highs
      lows   = cs&.lows
      return nil unless closes && highs && lows

      hlc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end

      ta_adx = TechnicalAnalysis::Adx.calculate(hlc, period: period).first
      ta_adx&.adx
    end

    def supertrend_signal(interval: '5')
      cs = candles(interval: interval)
      cs&.supertrend_signal
    end

    def liquidity_grab_up?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_up?
    end

    def liquidity_grab_down?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_down?
    end

    def bollinger_bands(period: 20, interval: '5')
      cs = candles(interval: interval)
      return nil unless cs

      cs.bollinger_bands(period: period)
    end

    def donchian_channel(period: 20, interval: '5')
      cs = candles(interval: interval)

      dc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          value: c.close
        }
      end
      TechnicalAnalysis::Dc.calculate(dc, period: period)
    end

    def obv(interval: '5')
      dcv = candles(interval: interval).candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          close: c.close,
          volume: c.volume || 0
        }
      end

      TechnicalAnalysis::Obv.calculate(dcv)
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end
  end
end


# File: app/models/concerns/instrument_helpers.rb
module InstrumentHelpers
  extend ActiveSupport::Concern
  include CandleExtension

  included do
    # Enums common to Instrument and Derivative
    enum :exchange, { nse: 'NSE', bse: 'BSE', mcx: 'MCX' }
    enum :segment, { index: 'I', equity: 'E', currency: 'C', derivatives: 'D', commodity: 'M' }, prefix: true
    enum :instrument_code, {
      index: 'INDEX',
      futures_index: 'FUTIDX',
      options_index: 'OPTIDX',
      equity: 'EQUITY',
      futures_stock: 'FUTSTK',
      options_stock: 'OPTSTK',
      futures_currency: 'FUTCUR',
      options_currency: 'OPTCUR',
      futures_commodity: 'FUTCOM',
      options_commodity: 'OPTFUT'
    }, prefix: true

    scope :nse, -> { where(exchange: 'NSE') }
    scope :bse, -> { where(exchange: 'BSE') }

    # Validations for enums can also go here, if common
  end

  # Shared instance methods for market data fetching and helpers
  def ltp
    fetch_ltp_from_api
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def quote_ltp
    quote = quotes.order(tick_time: :desc).first
    return nil unless quote

    quote.ltp.to_f
  rescue StandardError => e
    Rails.logger.error("Failed to fetch latest quote LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def fetch_ltp_from_api
    response = DhanHQ::Models::MarketFeed.ltp(exch_segment_enum)
    response.dig('data', exchange_segment, security_id.to_s, 'last_price') if response['status'] == 'success'
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP from API for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def ohlc
    response = DhanHQ::Models::MarketFeed.ohlc(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def historical_ohlc(from_date: nil, to_date: nil, oi: false)
    DhanHQ::Models::HistoricalData.daily(
      securityId: security_id,
      exchangeSegment: exchange_segment,
      instrument: instrument_type,
      oi: oi,
      fromDate: from_date || (Time.zone.today - 365).to_s,
      toDate: to_date || (Time.zone.today - 1).to_s,
      expiryCode: 0
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Historical OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def intraday_ohlc(interval: '5', oi: false, from_date: nil, to_date: nil)
    to_date ||= MarketCalendar.today_or_last_trading_day.to_s
    from_date ||= (Date.parse(to_date) - 5).to_s # fetch last 5 sessions by default

    DhanHQ::Models::HistoricalData.intraday(
      security_id: security_id,
      exchange_segment: exchange_segment,
      instrument: instrument_type,
      interval: interval,
      oi: oi,
      from_date: from_date || (Time.zone.today - 90).to_s,
      to_date: to_date || (Time.zone.today - 1).to_s
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Intraday OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def depth
    response = DhanHQ::Models::MarketFeed.quote(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  # Helper method: dynamic exchange_segment string for API calls
  def exchange_segment
    case [exchange.to_sym, segment.to_sym]
    when %i[nse index], %i[bse index] then 'IDX_I'
    when %i[nse equity] then 'NSE_EQ'
    when %i[bse equity] then 'BSE_EQ'
    when %i[nse derivatives] then 'NSE_FNO'
    when %i[bse derivatives] then 'BSE_FNO'
    when %i[nse currency] then 'NSE_CURRENCY'
    when %i[bse currency] then 'BSE_CURRENCY'
    when %i[mcx commodity] then 'MCX_COMM'
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  private

  def exch_segment_enum
    { exchange_segment => [security_id.to_i] }
  end

  def numeric_value?(value)
    value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
  end
end

# File: app/models/concerns/instrument_type_mapping.rb
# frozen_string_literal: true

module InstrumentTypeMapping
  # ------------------------------------------------------------------
  # Parent â†’ child mapping straight from Dhan CSV spec
  # ------------------------------------------------------------------
  PARENT_TO_CHILDREN = {
    'INDEX' => %w[FUTIDX OPTIDX],
    'EQUITY' => %w[FUTSTK OPTSTK],
    # Commodity & Currency donâ€™t have their own high-level codes in CSV,
    # so we treat the futures variant itself as â€œparentâ€.
    'FUTCOM' => %w[OPTFUT],
    'FUTCUR' => %w[OPTCUR]
  }.freeze

  # ------------------------------------------------------------------
  # Child â†’ parent lookup (built from the hash above)
  # ------------------------------------------------------------------
  CHILD_TO_PARENT =
    PARENT_TO_CHILDREN.flat_map { |parent, kids| kids.map { |kid| [kid, parent] } }
                      .to_h
                      .freeze

  # --------------------------------------------------
  # Public helpers
  # --------------------------------------------------

  # Given *any* code, return its underlying parent.
  #   underlying_for("FUTIDX")  => "INDEX"
  #   underlying_for("INDEX")   => "INDEX"
  def self.underlying_for(code)
    CHILD_TO_PARENT[code] || code
  end

  # Given an underlying parent, return all derivative codes
  #   derivative_codes_for("INDEX") => ["FUTIDX","OPTIDX"]
  def self.derivative_codes_for(parent_code)
    PARENT_TO_CHILDREN[parent_code] || []
  end

  # Convenience lists
  def self.all_parents  = PARENT_TO_CHILDREN.keys
  def self.all_children = CHILD_TO_PARENT.keys
end


# File: app/models/derivative.rb
class Derivative < ApplicationRecord
  include InstrumentHelpers

  belongs_to :instrument

  scope :options, -> { where.not(option_type: [nil, '']) }
  scope :futures, -> { where(option_type: [nil, '']) }
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  include InstrumentHelpers

  has_many :derivatives, dependent: :destroy

  accepts_nested_attributes_for :derivatives, allow_destroy: true

  # API Methods
  def fetch_option_chain(expiry = nil)
    expiry ||= expiry_list.first
    data = DhanHQ::Models::OptionChain.fetch(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment,
      expiry: expiry
    )
    return nil unless data

    filtered_data = filter_option_chain_data(data)

    { last_price: data['last_price'], oc: filtered_data }
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{security_id}: #{e.message}")
    nil
  end

  def filter_option_chain_data(data)
    data['oc'].select do |_strike, option_data|
      call_data = option_data['ce']
      put_data = option_data['pe']

      has_call_values = call_data && call_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end
      has_put_values = put_data && put_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end

      has_call_values || has_put_values
    end
  end

  def expiry_list
    DhanHQ::Models::OptionChain.fetch_expiry_list(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment
    )
  end
end


# File: app/models/scalp_session.rb
class ScalpSession < ApplicationRecord
  enum :status, { idle: 'idle', running: 'running', stopped: 'stopped', killed: 'killed' }

  validates :trade_date, presence: true
  validates :capital, :max_day_loss, :realized_pnl, :equity_peak, numericality: true

  def equity
    capital + realized_pnl
  end
end


# File: app/services/algo_runner.rb
class AlgoRunner
  def self.execute_all
    Instrument.watchlist.find_each do |inst|
      result = Strategies::BasicTrendStrategy.call(inst)
      case result
      when :buy_ce
        Execution::OrderExecutor.buy_option_ce(inst)
      end
    end
  end
end

# File: app/services/analysis/options_behaviour_analyzer.rb
module Analysis
  class OptionsBehaviourAnalyzer < ApplicationService
    def initialize(option_chain:, expiry:, underlying_spot:, symbol:, historical: [])
      @chain = option_chain.with_indifferent_access
      @expiry = expiry
      @spot = underlying_spot
      @symbol = symbol
      @historical = historical
    end

    def call
      atm = determine_atm
      return nil unless atm

      analysis = {
        symbol: @symbol,
        expiry: @expiry,
        spot: @spot,
        atm: atm,
        ce: extract_behaviour_data(atm, :ce),
        pe: extract_behaviour_data(atm, :pe),
        time: Time.zone.now
      }

      notify("ðŸ§  Behaviour Data Prepared for #{@symbol}\n\n#{analysis.inspect.truncate(1200)}", tag: 'OPTIONS_BEHAVIOUR')

      analysis
    end

    private

    def determine_atm
      @chain[:oc].keys.map(&:to_f).min_by { |s| (@spot - s).abs }
    end

    def extract_behaviour_data(strike, side)
      data = @chain[:oc][format('%.6f', strike)][side.to_s]
      return {} unless data

      {
        last_price: data['last_price'],
        iv: data['implied_volatility'],
        delta: data.dig('greeks', 'delta'),
        gamma: data.dig('greeks', 'gamma'),
        theta: data.dig('greeks', 'theta'),
        vega: data.dig('greeks', 'vega'),
        oi: data['oi'],
        volume: data['volume'],
        price_change: data['last_price'].to_f - data['previous_close_price'].to_f,
        oi_change: data['oi'].to_i - data['previous_oi'].to_i
      }
    end
  end
end

# File: app/services/application_service.rb
# frozen_string_literal: true

class ApplicationService
  def self.call(...)
    new(...).call
  end

  private

  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
  # ðŸ“£ Telegram Integration
  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

  def notify_step(step, message = nil)
    notify("ðŸ”¹ Step: #{step}\n#{message || '...'}", tag: step.to_s.upcase)
  end

  def notify_success(message = 'âœ… Step completed successfully')
    notify(message, tag: 'SUCCESS')
  end

  def notify_failure(error, step = nil)
    notify("âŒ Failure#{" at #{step}" if step}: #{error.class} â€“ #{error.message}", tag: 'FAILURE')
  end

  def notify(message, tag: nil)
    context = "[#{self.class.name}]"
    final_message = tag.present? ? "#{context} [#{tag}] \n\n #{message}" : "#{context} #{message}"
    TelegramNotifier.send_message(final_message)
  rescue StandardError => e
    log_error("Telegram Notify Failed: #{e.class} - #{e.message}")
  end

  def typing_ping
    TelegramNotifier.send_chat_action(chat_id: nil, action: 'typing')
  rescue StandardError => e
    log_error("Telegram Typing Action Failed: #{e.class} - #{e.message}")
  end

  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
  # ðŸ§¾ Logging Helpers (auto-prefix with class name)
  # â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

  %i[info warn error debug].each do |lvl|
    define_method("log_#{lvl}") do |msg|
      Rails.logger.send(lvl, "[#{self.class.name}] #{msg}")
    end
  end
end

# File: app/services/execution/order_executor.rb
module Execution
  class OrderExecutor
    def self.buy_option_ce(instrument)
      # Derive CE option symbol from spot instrument
      derivative = DerivativePicker.pick_ce(instrument)

      order = DhanHQ::Models::Order.new(
        transaction_type: 'BUY',
        exchange_segment: 'NSE_FNO',
        product_type: 'INTRADAY',
        order_type: 'MARKET',
        validity: 'DAY',
        security_id: derivative.security_id,
        quantity: derivative.lot_size
      )

      order.save
    end
  end
end

# File: app/services/execution/position_guard.rb
module Execution
  class PositionGuard
    TICK_INTERVAL_MS = 200 # safety if you rate-limit checks

    PositionState = Struct.new(
      :security_id, :segment, :entry_price, :peak_price, :entered_at,
      :trailing_mode, :underlying_symbol, :last_underlying_high_ts, :last_underlying_high
    )

    class << self
      def start(budget)
        @budget = budget
        @states = {}
        @mutex  = Mutex.new
        @running = true
        boot_ws_handlers
      end

      def stop
        @running = false
      end

      def register_intent(intent)
        state = PositionState.new(
          intent.security_id,
          intent.exchange_segment,
          BigDecimal(intent.entry_price.to_s),
          BigDecimal(intent.entry_price.to_s),
          Time.current,
          false,
          intent.underlying_symbol,
          Time.current,
          nil
        )
        @mutex.synchronize { @states[key(intent)] = state }
      end

      private

      def key(intent_or_state)
        "#{intent_or_state.segment}:#{intent_or_state.security_id}"
      end

      def boot_ws_handlers
        # Hook into your WS tick stream
        DhanHQ::WS::Bus.on_tick do |tick|
          next unless @running

          handle_tick(tick)
        end
      end

      def handle_tick(tick)
        k = "#{tick.segment}:#{tick.security_id}"
        state = @states[k]
        return unless state

        ltp = BigDecimal(tick.ltp.to_s)
        return if ltp <= 0

        # Peak tracking
        state.peak_price = [state.peak_price, ltp].max

        # Flip to trailing mode once profit exceeds max(1%, â‚¹1000)
        profit_pct = (ltp - state.entry_price) / state.entry_price
        if !state.trailing_mode && (profit_pct >= 0.01 || (ltp - state.entry_price) * lot_size_for(state) >= @budget.profit_trigger_rupees)
          state.trailing_mode = true
        end

        # Hard SL: 10% from entry
        if ltp <= state.entry_price * BigDecimal('0.90')
          exit_and_finalize!(state, reason: :hard_sl)
          return
        end

        # Time stop: 3 minutes and not green
        if Time.current - state.entered_at >= 3.minutes && ltp <= state.entry_price
          exit_and_finalize!(state, reason: :time_stop)
          return
        end

        # Trailing exit: 1% drop from peak once trailing_mode
        return unless state.trailing_mode && ltp <= state.peak_price * BigDecimal('0.99')

        exit_and_finalize!(state, reason: :trail_hit)
        nil

        # Optional: consolidation on underlying (update via separate underlying feed)
        # if no new underlying high for 2+ bars, consider exit
        # Pseudocode placeholders:
        # if underlying_consolidating?(state.underlying_symbol)
        #   exit_and_finalize!(state, reason: :underlying_consolidation)
        # end
      end

      def lot_size_for(state)
        # Look up derivative by security_id if needed; fallback 1
        Derivative.find_by(security_id: state.security_id)&.lot_size.to_i.nonzero? || 1
      end

      def exit_and_finalize!(state, reason:)
        # If super order placed â†’ modify/cancel bracket; else market exit
        Orders::Manager.exit_position!(security_id: state.security_id, segment: state.segment, reason: reason)
        # Compute realized_pnl from broker or internal calc
        realized = Orders::Analyzer.realized_pnl_for(state.security_id, state.segment) # returns decimal â‚¹
        @budget.on_trade_closed!(realized_pnl: realized)
        @mutex.synchronize { @states.delete("#{state.segment}:#{state.security_id}") }
        CloseStrikesManager.unsubscribe_if_unused(state.security_id, state.segment)
      rescue StandardError => e
        Rails.logger.error("[PositionGuard] exit failed #{state.inspect} #{e.class}: #{e.message}")
      end
    end
  end
end

# File: app/services/indicators/breaker_block.rb
module Indicators
  class BreakerBlock
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def identify
      breakers = []

      @candles.each_with_index do |candle, i|
        next if i < 5

        prev = @candles[i - 1]
        before_prev = @candles[i - 2]

        # 1ï¸âƒ£ Detect bullish breaker (failed bullish OB -> turns bearish)
        if bullish_ob_fail?(before_prev, prev, candle)
          breakers << {
            type: :bearish_breaker,
            breaker_zone: { high: before_prev.high, low: before_prev.low },
            broken_at: candle.timestamp,
            retest_pending: true
          }
        end

        # 2ï¸âƒ£ Detect bearish breaker (failed bearish OB -> turns bullish)
        next unless bearish_ob_fail?(before_prev, prev, candle)

        breakers << {
          type: :bullish_breaker,
          breaker_zone: { high: before_prev.high, low: before_prev.low },
          broken_at: candle.timestamp,
          retest_pending: true
        }
      end

      breakers
    end

    private

    def bullish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bullish? &&
        next_candle.low < ob.low &&         # OB invalidated
        breaker_candle.close > ob.high      # Breaker confirmation
    end

    def bearish_ob_fail?(ob, next_candle, breaker_candle)
      ob.bearish? &&
        next_candle.high > ob.high &&       # OB invalidated
        breaker_candle.close < ob.low       # Breaker confirmation
    end
  end
end

# File: app/services/indicators/calculator.rb
module Indicators
  class Calculator
    def initialize(series)
      @series = series
    end

    def rsi(period = 14)
      RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: @series.closes, period:).call
    end

    def macd
      RubyTechnicalAnalysis::Macd.new(series: @series.closes).call
    end

    def adx(period = 14)
      hlc = @series.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end
      TechnicalAnalysis::Adx.calculate(hlc, period:).last.adx
    end

    def bullish_signal?
      rsi < 30 && adx > 20 && series.closes.last > series.closes[-2]
    end

    def bearish_signal?
      rsi > 70 && adx > 20 && series.closes.last < series.closes[-2]
    end
  end
end

# File: app/services/indicators/fair_value_gap.rb
module Indicators
  class FairValueGap
    def initialize(series)
      @series = series
    end

    def detect
      fvg_zones = []
      @series.each_cons(3).with_index do |(c1, _c2, c3), i|
        if c3.low > c1.high
          fvg_zones << { index: i + 1, from: c1.high, to: c3.low, direction: :up }
        elsif c3.high < c1.low
          fvg_zones << { index: i + 1, from: c3.high, to: c1.low, direction: :down }
        end
      end
      fvg_zones
    end
  end
end


# File: app/services/indicators/intrinio_wrapper.rb
# app/services/indicators/intrinio_wrapper.rb
module Indicators
  class IntrinioWrapper
    SUPPORTED = TechnicalAnalysis::Indicator.names.map(&:to_s)
    attr_reader :data

    def initialize(data)
      @data = data
    end

    # example: RSI
    def rsi(period: 14)
      vals = TechnicalAnalysis::Rsi.calculate(data,
                                              period: period, price_key: :close)
      vals.map(&:value)
    end

    def adx(period: 14)
      vals = TechnicalAnalysis::Adx.calculate(data, period: period, price_key: :close)
      vals.map(&:adx)
    end

    def macd(fast: 12, slow: 26, signal: 9)
      TechnicalAnalysis::Macd.calculate(data,
                                        fast_period: fast, slow_period: slow, signal_period: signal, price_key: :close)
    end

    def obv
      TechnicalAnalysis::Obv.calculate(data, price_key: :close, volume_key: :volume)
    end

    # .. auto-generate other wrappers via meta-programming if you like
    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  rescue TechnicalAnalysis::ValidationError => e
    Rails.logger.warn("[IntrinioWrapper] #{e.class}: #{e.message}")
    []
  end
end


# File: app/services/indicators/order_block.rb
module Indicators
  class OrderBlock
    def initialize(series)
      @series = series
    end

    def bullish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bearish? && next_c.bullish? && next_c.close > prev.high
      end
    end

    def bearish_order_blocks
      @series.each_cons(3).with_index.filter_map do |(prev, curr, next_c), i|
        { index: i + 1, low: curr.low, high: curr.high } if curr.bullish? && next_c.bearish? && next_c.close < prev.low
      end
    end
  end
end


# File: app/services/indicators/ruby_ta_wrapper.rb
# app/services/indicators/ruby_ta_wrapper.rb
module Indicators
  class RubyTAWrapper
    SUPPORTED = %w[
      rsi macd stochastic_intraday momentum_index chaikin_money_flow
      bollinger_bands pivot_points mass_index qstick rate_of_change
      wilders_smoothing volume_oscillator williams_r price_channel
    ].freeze
    attr_reader :series

    def initialize(series) = @series = series

    # e.g.
    def rsi(period: 14)
      t = RubyTechnicalAnalysis::RelativeStrengthIndex.new(
               series: series.closes, period: period
             )
      t.valid? ? t.call : []
    end

    def macd(fast: 12, slow: 26, signal: 9)
      t = RubyTechnicalAnalysis::MACD.new(series: series.closes,
                                          fast_period: fast, slow_period: slow, signal_period: signal)
      t.valid? ? t.call : []
    end

    # ... same pattern for other SUPPORTED indicators

    def self.supports?(name)
      SUPPORTED.include?(name.to_s)
    end
  end
end


# File: app/services/indicators/structure.rb
module Indicators
  class Structure
    def initialize(series:)
      @series = series
    end

    def break_of_structure
      bos_points = []

      @series.candles.each_with_index do |c, i|
        if @series.swing_high?(i) && c.close < c.open
          bos_points << { index: i, type: :bos, direction: :down }
        elsif @series.swing_low?(i) && c.close > c.open
          bos_points << { index: i, type: :bos, direction: :up }
        end
      end
      bos_points
    end
  end
end


# File: app/services/indicators/supertrend.rb
module Indicators
  class Supertrend < ApplicationService
    attr_reader :series, :period, :multiplier, :supertrend_values, :candles

    def initialize(series:, period: 10, multiplier: 3.0)
      @series = series
      @candles = series.candles
      @period = period
      @multiplier = multiplier
      @supertrend_values = []
    end

    def call
      atr = calculate_atr
      return [] if atr.empty?

      supertrend = []
      trend = [] # :bullish or :bearish

      candles.each_with_index do |candle, i|
        next if i < period

        hl2 = (candle.high + candle.low) / 2.0
        upper_band = hl2 + (multiplier * atr[i])
        lower_band = hl2 - (multiplier * atr[i])

        if i == period
          supertrend[i] = upper_band
          trend[i] = :bearish
        else
          prev_close = candles[i - 1].close
          prev_supertrend = supertrend[i - 1]

          if prev_close <= supertrend[i - 1]
            supertrend[i] = [upper_band, prev_supertrend].min
            trend[i] = candle.close <= supertrend[i] ? :bearish : :bullish
          else
            supertrend[i] = [lower_band, prev_supertrend].max
            trend[i] = candle.close >= supertrend[i] ? :bullish : :bearish
          end
        end

        supertrend_values[i] = supertrend[i]
      end

      supertrend_values
    end

    private

    def calculate_atr
      tr = []
      atr = []

      candles.each_with_index do |candle, i|
        if i.zero?
          tr[i] = candle.high - candle.low
        else
          prev_close = candles[i - 1].close
          tr[i] = [
            candle.high - candle.low,
            (candle.high - prev_close).abs,
            (candle.low - prev_close).abs
          ].max
        end
      end

      # Simple Moving Average for ATR
      (0...candles.size).each do |i|
        atr[i] = if i < period
                   nil
                 else
                   tr[(i - period + 1)..i].compact.sum / period
                 end
      end

      atr
    end
  end
end


# File: app/services/instruments_importer.rb
# app/services/instruments_importer.rb
# frozen_string_literal: true

require 'csv'
require 'open-uri'

class InstrumentsImporter
  CSV_URL         = 'https://images.dhan.co/api-data/api-scrip-master-detailed.csv'
  CACHE_PATH      = Rails.root.join('tmp/dhan_scrip_master.csv') # â† NEW
  CACHE_MAX_AGE   = 24.hours # â† NEW
  VALID_EXCHANGES = %w[NSE BSE].freeze
  BATCH_SIZE      = 1_000

  class << self
    # ------------------------------------------------------------
    # Public entry point
    # ------------------------------------------------------------
    def import_from_url
      csv_text = fetch_csv_with_cache # â† NEW (was: URI.open(CSV_URL).read)
      import_from_csv(csv_text)
    end

    # ------------------------------------------------------------
    # Fetch CSV with 24-hour cache
    # ------------------------------------------------------------
    # â† NEW helper
    def fetch_csv_with_cache
      if CACHE_PATH.exist? && Time.current - CACHE_PATH.mtime < CACHE_MAX_AGE
        Rails.logger.info "Using cached CSV (#{CACHE_PATH})"
        return CACHE_PATH.read
      end

      Rails.logger.info 'Downloading fresh CSV from Dhanâ€¦'
      csv_text = URI.open(CSV_URL).read

      CACHE_PATH.dirname.mkpath
      File.write(CACHE_PATH, csv_text)
      Rails.logger.info "Saved CSV to #{CACHE_PATH}"

      csv_text
    rescue StandardError => e
      Rails.logger.warn "CSV download failed: #{e.message}"
      raise e if CACHE_PATH.exist? == false   # donâ€™t swallow if no fallback

      Rails.logger.warn 'Falling back to cached CSV (may be stale)'
      CACHE_PATH.read
    end
    private :fetch_csv_with_cache             # keep helper private

    def import_from_csv(csv_content)
      instruments_rows, derivatives_rows = build_batches(csv_content)
      Rails.logger.debug instruments_rows.size, derivatives_rows.size
      # instruments_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }
      # derivatives_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }

      import_instruments!(instruments_rows)  unless instruments_rows.empty?
      import_derivatives!(derivatives_rows)  unless derivatives_rows.empty?
    end

    private

    # ------------------------------------------------------------
    # 1. Split CSV rows
    # ------------------------------------------------------------
    def build_batches(csv_content)
      instruments = []
      derivatives = []

      CSV.parse(csv_content, headers: true).each do |row|
        next unless VALID_EXCHANGES.include?(row['EXCH_ID'])

        attrs = build_attrs(row)

        if row['SEGMENT'] == 'D'   # Derivative
          derivatives << attrs.slice(*Derivative.column_names.map(&:to_sym))
        else                       # Cash / Index
          instruments << attrs.slice(*Instrument.column_names.map(&:to_sym))
        end
      end

      [instruments, derivatives]
    end

    def build_attrs(row)
      now = Time.zone.now
      {
        security_id: row['SECURITY_ID'],
        exchange: row['EXCH_ID'],
        segment: row['SEGMENT'],
        isin: row['ISIN'],
        instrument_code: row['INSTRUMENT'],
        underlying_security_id: row['UNDERLYING_SECURITY_ID'],
        underlying_symbol: row['UNDERLYING_SYMBOL'],
        symbol_name: row['SYMBOL_NAME'],
        display_name: row['DISPLAY_NAME'],
        instrument_type: row['INSTRUMENT_TYPE'],
        series: row['SERIES'],
        lot_size: row['LOT_SIZE']&.to_i,
        expiry_date: safe_date(row['SM_EXPIRY_DATE']),
        strike_price: row['STRIKE_PRICE']&.to_f,
        option_type: row['OPTION_TYPE'],
        tick_size: row['TICK_SIZE']&.to_f,
        expiry_flag: row['EXPIRY_FLAG'],
        bracket_flag: row['BRACKET_FLAG'],
        cover_flag: row['COVER_FLAG'],
        asm_gsm_flag: row['ASM_GSM_FLAG'],
        asm_gsm_category: row['ASM_GSM_CATEGORY'],
        buy_sell_indicator: row['BUY_SELL_INDICATOR'],
        buy_co_min_margin_per: row['BUY_CO_MIN_MARGIN_PER']&.to_f,
        sell_co_min_margin_per: row['SELL_CO_MIN_MARGIN_PER']&.to_f,
        buy_co_sl_range_max_perc: row['BUY_CO_SL_RANGE_MAX_PERC']&.to_f,
        sell_co_sl_range_max_perc: row['SELL_CO_SL_RANGE_MAX_PERC']&.to_f,
        buy_co_sl_range_min_perc: row['BUY_CO_SL_RANGE_MIN_PERC']&.to_f,
        sell_co_sl_range_min_perc: row['SELL_CO_SL_RANGE_MIN_PERC']&.to_f,
        buy_bo_min_margin_per: row['BUY_BO_MIN_MARGIN_PER']&.to_f,
        sell_bo_min_margin_per: row['SELL_BO_MIN_MARGIN_PER']&.to_f,
        buy_bo_sl_range_max_perc: row['BUY_BO_SL_RANGE_MAX_PERC']&.to_f,
        sell_bo_sl_range_max_perc: row['SELL_BO_SL_RANGE_MAX_PERC']&.to_f,
        buy_bo_sl_range_min_perc: row['BUY_BO_SL_RANGE_MIN_PERC']&.to_f,
        sell_bo_sl_min_range: row['SELL_BO_SL_MIN_RANGE']&.to_f,
        buy_bo_profit_range_max_perc: row['BUY_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        sell_bo_profit_range_max_perc: row['SELL_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        buy_bo_profit_range_min_perc: row['BUY_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        sell_bo_profit_range_min_perc: row['SELL_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        mtf_leverage: row['MTF_LEVERAGE']&.to_f,
        created_at: now,
        updated_at: now
      }
    end

    # ------------------------------------------------------------
    # 3. Upsert instruments
    # ------------------------------------------------------------
    def import_instruments!(rows)
      res = Instrument.import(
        rows,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            display_name isin instrument_code instrument_type
            underlying_symbol lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Instruments: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4. Upsert derivatives
    # ------------------------------------------------------------
    def import_derivatives!(rows)
      with_parent, without_parent = attach_instrument_ids(rows)

      Rails.logger.info "Derivatives w/ parent: #{with_parent.size}"
      Rails.logger.info "Derivatives w/o parent: #{without_parent.size}"

      return if with_parent.empty?

      res = Derivative.import(
        with_parent,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            symbol_name display_name isin instrument_code instrument_type
            underlying_symbol series lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Derivatives: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4a. Attach instrument_id to each derivative row
    # ------------------------------------------------------------
    def attach_instrument_ids(rows)
      enum_to_csv = Instrument.instrument_codes

      # ðŸ”‘ lookup key = [csv_code, UNDERLYING_SYMBOL]
      lookup = Instrument.pluck(
        :id, :instrument_code, :underlying_symbol, :exchange, :segment
      ).each_with_object({}) do |(id, enum_code, sym, _exch, _seg), h|
        next if sym.blank?

        csv_code = enum_to_csv[enum_code] || enum_code # keep CSV code itself
        key      = [csv_code, sym.upcase]
        h[key]   = id
      end

      Rails.logger.debug { "lookup size: #{lookup.size}" }

      with_parent    = []
      without_parent = []
      count = 0
      rows.each do |h|
        count += 1 if h[:underlying_symbol]
        next without_parent << h if h[:underlying_symbol].blank?

        parent_code = InstrumentTypeMapping.underlying_for(h[:instrument_code]) # FUTIDX âžœ INDEX
        key         = [parent_code, h[:underlying_symbol].upcase]

        if (pid = lookup[key])
          h[:instrument_id] = pid
          with_parent << h
        else
          without_parent << h
        end
      end

      [with_parent, without_parent]
    end

    # ------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------
    def safe_date(str)
      Date.parse(str)
    rescue StandardError
      nil
    end

    def map_segment(char)
      { 'I' => 'index', 'E' => 'equity', 'C' => 'currency',
        'D' => 'derivatives', 'M' => 'commodity' }[char] || char.downcase
    end
  end
end

# File: app/services/live/tick_cache.rb
# frozen_string_literal: true

require 'concurrent'

module Live
  class TickCache
    MAP = Concurrent::Map.new

    def self.put(t)
      MAP["#{t[:segment]}:#{t[:security_id]}"] = t
    end

    def self.get(segment, security_id)
      MAP["#{segment}:#{security_id}"]
    end

    def self.ltp(segment, security_id)
      MAP["#{segment}:#{security_id}"]&.dig(:ltp)
    end

    def self.clear
      MAP.clear
    end
  end
end


# File: app/services/live/ws_hub.rb
# frozen_string_literal: true

require 'singleton'
require 'concurrent'

module Live
  class WsHub
    include Singleton

    def initialize
      @running  = Concurrent::AtomicBoolean.new(false)
      @client   = nil
      @subs     = Concurrent::Set.new # "SEG:SID"
      @handlers = Concurrent::Array.new
    end

    def start!(mode: :quote)
      return self if @running.true?

      @client = DhanHQ::WS::Client.new(mode: mode).start
      @client.on(:tick) { |t| handle_tick(t) }
      @running.make_true
      self
    end

    def stop!
      return self unless @running.true?

      @running.make_false
      @client&.disconnect! # graceful + no reconnect
      @client = nil
      self
    end

    # Subscribe single instrument (idempotent)
    def subscribe(seg:, sid:)
      key = k(seg, sid)
      return self if @subs.include?(key)

      @subs.add(key)
      @client&.subscribe_one(segment: seg, security_id: sid)
      self
    end

    # Unsubscribe (if you want to shrink the stream)
    def unsubscribe(seg:, sid:)
      key = k(seg, sid)
      return self unless @subs.include?(key)

      @subs.delete(key)
      @client&.unsubscribe_one(segment: seg, security_id: sid)
      self
    end

    # Convenient multi-subscribe
    def subscribe_many(list)
      list.each { |h| subscribe(seg: h[:segment] || h['segment'], sid: h[:security_id] || h['security_id']) }
      self
    end

    # Register per-app tick listener (non-blocking please)
    def on_tick(&blk)
      @handlers << blk
      self
    end

    # Subscribe all currently-open positions (call on boot if desired)
    def subscribe_from_open_positions!
      Position.where(status: %w[OPEN ACTIVE LIVE]).pluck(:exchange_segment, :security_id).each do |seg, sid|
        subscribe(seg: seg, sid: sid.to_s)
      end
      self
    end

    private

    def handle_tick(t)
      TickCache.put(t) # global last-known tick
      begin
        ActiveSupport::Notifications.instrument('tick.dhanhq', tick: t)
      rescue StandardError
        nil
      end
      # Local handlers
      @handlers.each do |h|
        h.call(t)
      rescue StandardError
        nil
      end
    end

    def k(seg, sid) = "#{seg}:#{sid}"
  end
end


# File: app/services/market_calendar.rb
module MarketCalendar
  MARKET_HOLIDAYS = [
    # Add static or API-fetched holiday dates here
    Date.new(2025, 8, 15)
    # ...
  ]

  def self.trading_day?(date)
    weekday = date.on_weekday?
    !MARKET_HOLIDAYS.include?(date) && weekday
  end

  def self.last_trading_day(from: Time.zone.today)
    date = from
    date -= 1 until trading_day?(date)
    date
  end

  def self.today_or_last_trading_day
    trading_day?(Time.zone.today) ? Time.zone.today : last_trading_day
  end
end


# File: app/services/openai/behaviour_explainer.rb
module Openai
  class BehaviourExplainer < ApplicationService
    def initialize(analysis_hash)
      @data = analysis_hash
    end

    def call
      prompt = build_prompt
      typing_ping
      completion = OpenAI::Client.new.chat(
        parameters: {
          model: 'gpt-4',
          messages: [
            { role: 'system', content: 'You are an options trading expert' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7
        }
      )
      result = completion.dig('choices', 0, 'message', 'content')
      notify("ðŸ“˜ AI Options Insight for #{@data[:symbol]}:\n\n#{result}", tag: 'AI_EXPLAIN')
      result
    rescue StandardError => e
      notify_failure(e, :openai)
      nil
    end

    def build_prompt
      <<~PROMPT
        Given the following ATM options data for #{@data[:symbol]} (#{@data[:expiry]}), analyze the market sentiment and expected move direction:

        CE:
        â€¢ Price: #{@data[:ce][:last_price]}
        â€¢ IV: #{@data[:ce][:iv]}
        â€¢ Î”: #{@data[:ce][:delta]}
        â€¢ Î¸: #{@data[:ce][:theta]}
        â€¢ OI: #{@data[:ce][:oi]}
        â€¢ Price Change: #{@data[:ce][:price_change]}

        PE:
        â€¢ Price: #{@data[:pe][:last_price]}
        â€¢ IV: #{@data[:pe][:iv]}
        â€¢ Î”: #{@data[:pe][:delta]}
        â€¢ Î¸: #{@data[:pe][:theta]}
        â€¢ OI: #{@data[:pe][:oi]}
        â€¢ Price Change: #{@data[:pe][:price_change]}

        Spot: #{@data[:spot]}
        ATM: #{@data[:atm]}

        Respond with:
        - Sentiment: Bullish / Bearish / Neutral
        - Reasoning
        - Suggested next move for CE or PE buying (if any)
      PROMPT
    end
  end
end

# File: app/services/option/chain_analyzer.rb


# File: app/services/scalp/budget.rb
module Scalp
  class Budget
    def initialize(session)
      @session = session
      @allow_entries = true
      @mutex = Mutex.new
    end

    def on_trade_closed!(realized_pnl:)
      @mutex.synchronize do
        @session.increment!(:realized_pnl, realized_pnl)
      end
    end

    def can_trade?
      @allow_entries && !daily_loss_hit?
    end

    def block_new_entries!
      @allow_entries = false
    end

    def daily_loss_hit?
      @session.realized_pnl <= -@session.max_day_loss
    end

    def risk_rupees
      BigDecimal(@session.params['risk_rupees'].to_s.presence || '600.0')
    end

    def profit_trigger_rupees
      BigDecimal(@session.params['profit_trigger_rupees'].to_s.presence || '1000.0')
    end

    def no_entries_after # "15:00" default
      (@session.params['no_entries_after'] || '15:00').to_s
    end

    def roster
      Array(@session.params['roster']).presence || %w[NIFTY BANKNIFTY]
    end
  end
end

# File: app/services/scalp/close_strikes_manager.rb
module Scalp
  class CloseStrikesManager
    class << self
      def start(roster)
        @mutex ||= Mutex.new
        @started = true
        @subscribed = Set.new # holds "SEGMENT:SECURITY_ID" keys
        @roster = Array(roster)

        # subscribe underlyings up front (indices/stocks)
        @roster.each { |symbol| subscribe_underlying!(symbol) }
      rescue StandardError => e
        Rails.logger.error("[CloseStrikesManager] start failed: #{e.class}: #{e.message}")
      end

      def stop
        @started = false
        # Optional: perform a bulk UNSUB here if you want to clean everything
        # unsubscribe_all!
      rescue StandardError => e
        Rails.logger.error("[CloseStrikesManager] stop failed: #{e.class}: #{e.message}")
      end

      # Subscribe option legs for a given symbol (e.g., ATM Â± 1)
      # Pass an array of [segment, security_id] pairs or Derivative records.
      def subscribe_legs!(legs)
        return unless @started

        pairs = normalize_pairs(legs)
        with_client do |client|
          to_add = filter_new(pairs)
          chunked(to_add, 90).each do |batch|
            client.subscribe_many(:quote, batch) # or :full if you want depth/OI
            mark_subscribed(batch)
          rescue StandardError => e
            Rails.logger.warn("[CloseStrikesManager] subscribe_many failed: #{e.class}: #{e.message}")
          end
        end
      end

      # Called by PositionGuard after exit; real impl can ref-count and UNSUB.
      def unsubscribe_if_unused(segment, security_id)
        # Optional: track refs per leg and UNSUB when count goes zero.
        # For now, we keep them subscribed; DhanHQ allows <=100 per frame and
        # we aim to stay within that via focused ATMÂ±1 usage.
        true
      end

      # Convenience for subscribing a single leg (Derivative or [seg, id])
      def subscribe_leg!(leg)
        subscribe_legs!([leg])
      end

      private

      # Subscribe the underlying itself so we can watch spot drift if desired
      def subscribe_underlying!(symbol)
        inst = Instrument.find_by(symbol: symbol) || Instrument.find_by(tradingsymbol: symbol)
        return unless inst

        segment = inst.exchange_segment # e.g., "NSE_FNO" for index futures; adjust per your mapping
        sec_id  = inst.security_id
        return unless segment.present? && sec_id.present?

        subscribe_legs!([[segment, sec_id]])
      end

      def with_client
        # Try to get the running WS client from your supervisor or directly:
        client = (WSSupervisor.respond_to?(:client) && WSSupervisor.client) ||
                 (defined?(DhanHQ::WS::Client) && DhanHQ::WS::Client.try(:current)) ||
                 (defined?(DhanHQ::WS::Client) && DhanHQ::WS::Client.try(:instance))

        unless client
          Rails.logger.warn('[CloseStrikesManager] WS client not available yet')
          return
        end
        yield client
      end

      def normalize_pairs(legs)
        legs.filter_map do |leg|
          case leg
          when Array
            seg, id = leg
            next unless seg && id

            [seg.to_s, id.to_i]
          else
            # treat as Derivative or a PORO responding to segment/security_id
            seg = leg.respond_to?(:exchange_segment) ? leg.exchange_segment : leg.segment
            id  = leg.respond_to?(:security_id) ? leg.security_id : leg.id
            next unless seg && id

            [seg.to_s, id.to_i]
          end
        end
      end

      def filter_new(pairs)
        @mutex.synchronize do
          pairs.reject { |seg, id| @subscribed.include?("#{seg}:#{id}") }
        end
      end

      def mark_subscribed(pairs)
        @mutex.synchronize do
          pairs.each { |seg, id| @subscribed.add("#{seg}:#{id}") }
        end
      end

      def chunked(arr, size)
        arr.each_slice(size).to_a
      end

      # If you later implement hard UNSUB:
      # def unsubscribe_all!
      #   with_client do |client|
      #     keys = @mutex.synchronize { @subscribed.to_a }
      #     pairs = keys.map { |k| seg, id = k.split(":"); [seg, id.to_i] }
      #     chunked(pairs, 90).each { |batch| client.unsubscribe_many(:quote, batch) }
      #   end
      #   @mutex.synchronize { @subscribed.clear }
      # end
    end
  end
end

# File: app/services/scalp/control.rb
module Scalp
  class Control
    def self.kill_today!(reason: 'manual')
      session = ScalpSession.find_by(trade_date: Date.current)
      session&.update!(status: :killed, params: session.params.merge(kill_reason: reason))
    end

    def self.stop_today!
      session = ScalpSession.find_by(trade_date: Date.current)
      session&.update!(status: :stopped)
    end
  end
end

# File: app/services/scalp/roster.rb
module Scalp
  class Roster
    def self.list(session)
      Array(session.params['roster']).presence || %w[NIFTY BANKNIFTY]
    end
  end
end

# File: app/services/scalp/rules.rb
module Scalp
  class Rules
    # candles => your CandleSeries for 1m
    # Expect: supertrend(direction: :up|:down), rsi(14), adx(14)
    def self.entry_signal(symbol, candles)
      st  = candles.supertrend(factor: 2.0, period: 10)
      rsi = candles.rsi(14).last
      adx = candles.adx(14).last
      dir = st.direction # :up or :down at last bar

      return nil unless adx && adx > 25

      if dir == :up && rsi && rsi > 50
        OpenStruct.new(direction: :bullish)
      elsif dir == :down && rsi && rsi < 50
        OpenStruct.new(direction: :bearish)
      end
    end
  end
end

# File: app/services/scalp/runner.rb
module Scalp
  class Runner < ApplicationService
    def initialize(session:)
      @session = session
      @running = true
    end

    def call
      @session.update!(status: :running, equity_peak: @session.equity)
      boot!

      loop do
        break unless @running

        enforce_time_window!
        enforce_kill_switch!
        sleep 1
      end
    ensure
      shutdown!
    end

    def stop!
      @running = false
    end

    private

    def boot!
      Time.use_zone('Asia/Kolkata') {}
      @budget = Budget.new(@session)

      Scalp::WSSupervisor.start(mode: :quote)
      CloseStrikesManager.start(Scalp::Roster.list(@session))
      Execution::PositionGuard.start(@budget)

      # 1-minute entries across roster
      Bars::FetchLoop.start(timeframe: '1m', symbols: Scalp::Roster.list(@session)) do |symbol, candles|
        next unless in_entry_window? && @budget.can_trade?

        signal = Rules.entry_signal(symbol, candles)
        next unless signal

        leg   = Strategy::OptionLocator.new(symbol).atm_leg_for(signal.direction) # CE for :bullish, PE for :bearish
        entry = Scalp::Sizing.for(leg, budget: @budget)
        next if entry.qty <= 0

        intent = Execution::DhanRouter.place_super_order!(leg, entry) # super order or fallback path
        Execution::PositionGuard.register_intent(intent)
        @session.increment!(:trades_count)
      end
    end

    def in_entry_window?
      now = Time.current.in_time_zone('Asia/Kolkata')
      cutoff = @budget.no_entries_after
      now < now.change(hour: cutoff.split(':')[0].to_i, min: cutoff.split(':')[1].to_i)
    end

    def enforce_time_window!
      now = Time.current.in_time_zone('Asia/Kolkata')
      return unless now >= now.change(hour: 15, min: 25)

      stop!
    end

    def enforce_kill_switch!
      @session.reload
      @session.update!(equity_peak: [@session.equity_peak, @session.equity].max)
      stop! if @budget.daily_loss_hit?
    end

    def shutdown!
      Execution::PositionGuard.stop
      CloseStrikesManager.stop
      WSSupervisor.stop
      Bars::FetchLoop.stop
      @session.update!(status: :stopped) if @session.running?
    end
  end
end

# File: app/services/scalp/sizing.rb
module Scalp
  class Sizing
    # derivative must respond to lot_size and ltp
    def self.for(derivative, budget:, sl_pct: BigDecimal('0.10'))
      lot_size    = derivative.lot_size.to_i
      entry_price = BigDecimal(derivative.ltp.to_s)
      risk        = budget.risk_rupees

      return OpenStruct.new(qty: 0, sl_pct: sl_pct) if entry_price <= 0 || lot_size <= 0

      lots = (risk / (entry_price * sl_pct * lot_size)).floor
      qty  = [lots, 1].max * lot_size
      OpenStruct.new(qty: qty, sl_pct: sl_pct)
    end
  end
end

# File: app/services/scalp/ws_supervisor.rb
# frozen_string_literal: true

module Scalp
  class WSSupervisor
    def initialize(indices:, mode: :quote)
      @mode = mode
      @indices = indices
      @bus = TickBus.new
      @agg = CandleAggregator.new(interval_sec: 300) { |ev| on_candle_close(ev) }
      @running = Concurrent::AtomicBoolean.new(false)
    end
    attr_reader :agg

    def start!
      return if @running.true?

      @running.make_true

      # seed 5m series for indices (from your Instrument helpers)
      @indices.each do |it|
        inst = Instrument.find_by(security_id: it[:security_id].to_s)
        next unless inst

        cs = inst.candle_series(interval: '5') || CandleSeries.new(symbol: inst.symbol, interval: '5')
        @agg.seed_series!(segment: it[:segment], security_id: it[:security_id], series: cs)
      end

      @ws = DhanHQ::WS::Client.new(mode: @mode).start
      @ws.on(:tick) { |t| on_tick(t) }
      @indices.each { |i| @ws.subscribe_one(segment: i[:segment], security_id: i[:security_id]) }

      @drainer = Thread.new do
        loop do
          @bus.drain
          sleep 0.01 if @running.true?
        end
      end
      self
    end

    def stop!
      @running.make_false
      @ws&.stop
      @drainer&.kill
    end

    def subscribe_option(seg:, sid:) = @ws.subscribe_one(segment: seg, security_id: sid)

    private

    def on_tick(t)
      TickCache.put(t)
      @bus.publish("ticks.#{t[:segment]}.#{t[:security_id]}", t)
      @agg.on_tick(t)
      CloseStrikesManager.instance.on_index_tick(t) # dynamic close strikes
    end

    def on_candle_close(ev)
      Strategy::SupertrendOptionLong.instance.on_index_candle(ev[:segment], ev[:security_id])
    end
  end
end

# File: app/services/smc/bos.rb
# SMC Component: Break of Structure (BOS)
module Smc
  class Bos < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      index = candles.size - 2
      return false if index < 4

      # Detect BOS: Higher High followed by higher low (bullish) or Lower Low + Lower High (bearish)
      last_high = candles[index].high
      prev_high = candles[index - 2].high
      last_low  = candles[index].low
      prev_low  = candles[index - 2].low

      bullish_bos = last_high > prev_high && candles[index + 1].low > prev_low
      bearish_bos = last_low < prev_low && candles[index + 1].high < prev_high

      bullish_bos || bearish_bos
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/choch.rb
# SMC Component: Change of Character (CHOCH)
module Smc
  class Choch < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      recent = candles.last(5)
      prev = candles.last(10)[0...5]

      bullish_choch = recent.first.low > prev.map(&:low).max && recent.last.close > recent.first.open
      bearish_choch = recent.first.high < prev.map(&:high).min && recent.last.close < recent.first.open

      bullish_choch || bearish_choch
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/fair_value_gap.rb
# frozen_string_literal: true

module Smc
  class FairValueGap < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 3

      # Use last 3 candles
      c1, c2, c3 = candles[-3..]

      bullish_gap = c3.low > c1.high
      bearish_gap = c3.high < c1.low

      bullish_gap || bearish_gap
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/inducement.rb
# frozen_string_literal: true

module Smc
  class Inducement < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      lookback = 15
      current = candles.last
      past = candles.last(lookback + 1)[0...lookback]

      inducement_up = false
      inducement_down = false

      # False breakout above previous highs (trap long buyers)
      highest_past_high = past.map(&:high).max
      inducement_up = true if current.high > highest_past_high && current.close < highest_past_high && current.bearish?

      # False breakdown below previous lows (trap short sellers)
      lowest_past_low = past.map(&:low).min
      inducement_down = true if current.low < lowest_past_low && current.close > lowest_past_low && current.bullish?

      inducement_up || inducement_down
    rescue StandardError => e
      Rails.logger.error("SMC::Inducement error: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end


# File: app/services/smc/interpreter.rb
module SMC
  class Interpreter < ApplicationService
    def initialize(analysis_hash)
      @analysis = analysis_hash
    end

    def call
      client = OpenAI::Client.new(...)
      prompt = build_prompt
      response = client.chat(... prompt ...)
      JSON.parse(response.dig("choices", 0, "message", "content"))
    end

    def build_prompt
      openai_prompt_for_smc(@analysis)
    end
  end
end


# File: app/services/smc/mitigation.rb
# frozen_string_literal: true

module Smc
  class Mitigation < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 20

      # Reuse previously defined Order Blocks
      order_blocks = Smc::OrderBlock.call(series: series)
      return false if order_blocks.blank?

      # Pick the last known OB zone
      ob = order_blocks.last
      return false unless ob[:index] && ob[:type] && ob[:range]

      # Only consider mitigation attempts that come after 3 candles from OB
      mitigation_index = ob[:index] + 3
      return false if candles.size <= mitigation_index

      # Look for price touching or reacting from OB zone in later candles
      candles[mitigation_index..].each do |candle|
        if ob[:type] == :bullish
          return true if candle.low <= ob[:range][:low] && candle.close > ob[:range][:low]
        elsif ob[:type] == :bearish
          return true if candle.high >= ob[:range][:high] && candle.close < ob[:range][:high]
        end
      end

      false
    rescue StandardError => e
      Rails.logger.error("Mitigation check failed: #{e.message}")
      false
    end

    private

    attr_reader :series, :candles
  end
end

# File: app/services/smc/order_block.rb
# frozen_string_literal: true

module Smc
  class OrderBlock < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
    end

    def call
      return false if candles.size < 10

      last_index = candles.size - 1
      lookback = 10

      (last_index - lookback).upto(last_index - 2) do |i|
        curr = candles[i]
        nxt  = candles[i + 1]

        # Bullish Order Block: Last bearish candle before strong bullish candle
        return true if curr.bearish? && nxt.bullish? && nxt.close > nxt.open + series.atr && price_respected_order_block?(curr.low, :bullish)

        # Bearish Order Block: Last bullish candle before strong bearish candle
        return true if curr.bullish? && nxt.bearish? && nxt.close < nxt.open - series.atr && price_respected_order_block?(curr.high, :bearish)
      end

      false
    end

    private

    attr_reader :series, :candles

    def price_respected_order_block?(level, direction)
      last = candles.last
      if direction == :bullish
        last.low >= level
      else
        last.high <= level
      end
    end
  end
end


# File: app/services/strategies/base_indicator_strategy.rb
module Strategies
  class BaseIndicatorStrategy
    attr_reader :instrument, :series, :interval

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def initialize(instrument, series: nil, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = series || instrument.candles(interval)
    end

    def series
      @series ||= instrument.candles(interval)
    end

    def candles
      @candles ||= series.candles
    end

    def closes
      @closes ||= candles.map(&:close)
    end

    def highs
      @highs ||= candles.map(&:high)
    end

    def lows
      @lows ||= candles.map(&:low)
    end

    def opens
      @opens ||= candles.map(&:open)
    end

    def volumes
      @volumes ||= candles.map(&:volume)
    end

    def last_candle
      @last_candle ||= candles.last
    end

    def signal?
      raise NotImplementedError, "#{self.class.name} must implement #signal?"
    end

    def signal_details
      result = signal?
      return nil unless result

      {
        signal: result,
        confidence: confidence_score,
        reason: reason_text
      }
    end
  end
end

# File: app/services/strategies/basic_trend_strategy.rb
module Strategies
  class BasicTrendStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw_data = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw_data)
    end

    def call
      calc = Indicators::Calculator.new(@series)
      if calc.bullish_signal?
        :buy_ce
      elsif calc.bearish_signal?
        :buy_pe
      else
        :hold
      end
    end
  end
end

# File: app/services/strategies/bollinger_rsi.rb
module Strategies
  class BollingerRsi < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      close = instrument.candles.closes.last
      bands = instrument.bollinger_bands

      pp "RSI: #{rsi}, Close: #{close}, Bands: #{bands.inspect}"
      return :buy_ce if close > bands[:upper] && rsi < 70

      :buy_pe if close < bands[:lower] && rsi > 30
    end

    def confidence_score = 65
    def reason_text = "BB/RSI: Close=#{series.closes.last}, RSI=#{series.rsi}, Bands=#{series.bollinger_bands.inspect}"
  end
end



# File: app/services/strategies/donchian_adx.rb
module Strategies
  class DonchianAdx < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      donchians = instrument.donchian_channel
      adx = instrument.adx

      return :buy_ce if close > donchians.first.upper_bound && adx > 25

      :buy_pe if close < donchians.first.lower_bound && adx > 25
    end

    def confidence_score = 70
    def reason_text = "Donchian/ADX: Close=#{instrument.candles.closes.last}, Donchian=#{instrument.donchian_channel.first.inspect}, ADX=#{instrument.adx}"
  end
end



# File: app/services/strategies/holy_grail_strategy.rb
# frozen_string_literal: true

module Strategies
  class HolyGrailStrategy < BaseIndicatorStrategy
    STRATEGIES = {
      rsi_adx: Strategies::RsiAdxCombo,
      macd_supertrend: Strategies::MacdSupertrend,
      bollinger_rsi: Strategies::BollingerRsi,
      donchian_adx: Strategies::DonchianAdx
      # vwap_rsi: Strategies::VwapRsi,
      # obv_macd: Strategies::ObvMacd
    }.freeze

    STRATEGY_WEIGHTS = {
      rsi_adx: 0.15,
      macd_supertrend: 0.2,
      bollinger_rsi: 0.15,
      donchian_adx: 0.15
      # vwap_rsi: 0.15,
      # obv_macd: 0.2
    }.freeze

    def initialize(instrument, series: nil)
      @instrument = instrument
      @series = series || instrument.candles('5')
    end

    def call
      results = run_all_strategies

      top_signal = results[:votes].max_by { |_signal, w| w }&.first || :hold
      final_score = results[:score]

      {
        strategy: :holygrail,
        instrument: instrument.symbol_name,
        action: top_signal,
        confidence: final_score.round(2),
        reasons: results[:reasons],
        telemetry: results[:telemetry],
        decision: final_score >= 0.65 ? top_signal : :hold
      }
    end

    # âœ¨ AI Prompt Payload: use this output to pass to OpenAI
    def ai_prompt_payload
      result = call
      <<~PROMPT.strip
        Instrument: #{result[:instrument]}
        Final Action: #{result[:action].to_s.upcase}
        Confidence Score: #{result[:confidence]}%
        Decision Reasoning:
        #{result[:reasons].map { |r| "- #{r}" }.join("\n")}

        Indicator Telemetry:
        #{result[:telemetry].map { |k, v| "#{k.to_s.titleize}: #{v}" }.join("\n")}

        Based on the above, analyze the current market structure, probable support/resistance zones, and possible close for today. If market is closed, prepare analysis for next session. Suggest any CE/PE trade or HOLD decision with SL/TP levels.
      PROMPT
    end

    private

    attr_reader :instrument, :series

    def run_all_strategies
      results = {
        score: 0.0,
        votes: Hash.new(0),
        reasons: [],
        telemetry: {}
      }

      STRATEGIES.each do |key, klass|
        strat = klass.new(instrument, series: series)
        outcome = strat.signal_details

        next unless outcome

        weight = STRATEGY_WEIGHTS[key]
        results[:votes][outcome[:signal]] += weight
        results[:score] += outcome[:confidence] * weight
        results[:reasons] << "#{key.to_s.titleize} â†’ #{outcome[:signal].to_s.upcase} (#{(outcome[:confidence] * weight).round(1)} pts)"
        results[:telemetry][key] = outcome[:reason]
      end

      results
    end
  end
end

# File: app/services/strategies/liquidity_grab_strategy.rb
module Strategies
  class LiquidityGrabStrategy < ApplicationService
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      grab_up = @series.liquidity_grab_up?
      grab_down = @series.liquidity_grab_down?

      return :short if grab_up
      return :long  if grab_down

      false
    end
  end
end

# File: app/services/strategies/macd_supertrend.rb
module Strategies
  class MacdSupertrend < BaseIndicatorStrategy
    def signal?
      macd = instrument.macd
      supertrend = instrument.supertrend_signal

      macd_line = macd[:macd]
      signal_line = macd[:signal]

      if macd_line > signal_line && supertrend == :long_entry
        :buy_ce
      elsif macd_line < signal_line && supertrend == :short_entry
        :buy_pe
      end
    end

    def confidence_score = 75
    def reason_text = "MACD/ST: MACD=#{instrument.macd[:macd]}, Signal=#{instrument.macd[:signal]}, Supertrend=#{instrument.supertrend_signal}"
  end
end



# File: app/services/strategies/obv_macd.rb
module Strategies
  class ObvMacd < BaseIndicatorStrategy
    def signal?
      obv = series.obv
      macd = series.macd
      macd_line = macd.last[:macd]
      signal_line = macd.last[:signal]

      return :buy_ce if obv_trending_up?(obv) && macd_line > signal_line

      :buy_pe if obv_trending_down?(obv) && macd_line < signal_line
    end

    def obv_trending_up?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b > a }
    end

    def obv_trending_down?(obv)
      obv.last(3).each_cons(2).all? { |a, b| b < a }
    end

    def confidence_score = 70
    def reason_text = "OBV/MACD: OBV trend detected, MACD=#{series.macd.last[:macd]}, Signal=#{series.macd.last[:signal]}"
  end
end


# File: app/services/strategies/price_action_strategy.rb
module Strategies
  class PriceActionStrategy < ApplicationService
    def initialize(instrument, interval: '5')
      @instrument = instrument
      @interval = interval
      @series = CandleSeries.new(symbol: instrument.symbol_name, interval:)
      raw = instrument.intraday_ohlc(interval: interval)
      @series.load_from_raw(raw)
    end

    def signal?
      # basic setup
      @last = @series.candles.last
      @prev = @series.candles[-2]
      @third = @series.candles[-3]

      bullish_pinbar? || bearish_engulfing? || breakout_candle?
    end

    private

    def bullish_pinbar?
      body = (@last.close - @last.open).abs
      lower_wick = @last.open - @last.low if @last.bullish?
      lower_wick = @last.close - @last.low if @last.bearish?

      lower_wick && lower_wick > body * 2 && @last.close > @last.open
    end

    def bearish_engulfing?
      @prev.bullish? &&
        @last.bearish? &&
        @last.open > @prev.close &&
        @last.close < @prev.open
    end

    def breakout_candle?
      highs = @series.candles[-5..-2].map(&:high)
      @last.high > highs.max && @last.close > highs.max
    end
  end
end

# File: app/services/strategies/rsi_adx_combo.rb
module Strategies
  class RsiAdxCombo < BaseIndicatorStrategy
    def signal?
      rsi = instrument.rsi
      adx = instrument.adx

      return :buy_ce if rsi > 30 && adx > 20

      :buy_pe if rsi < 70 && adx > 20
    end

    def confidence_score = 70

    def reason_text
      "RSI/ADX Combo: RSI=#{instrument.rsi.round(2)}, ADX=#{instrument.adx.round(2)}"
    end
  end
end



# File: app/services/strategies/smart_money_strategy.rb
module Strategies
  class SmartMoneyStrategy
    def initialize(instrument)
      @instrument = instrument
      raw = instrument.intraday_ohlc(interval: '5')
      @series = CandleSeries.new(symbol: instrument.symbol_name)
      @series.load_from_raw(raw)
    end

    def signal?
      fvg     = Indicators::FairValueGap.new(@series).detect.last
      blocks  = Indicators::OrderBlock.new(@series).bullish_order_blocks.last
      bos     = Indicators::Structure.new(@series).break_of_structure.last

      return false unless bos && fvg && blocks

      # Apply filters (e.g., direction match)
      bos[:direction] == :up && blocks[:low] > fvg[:from]
    end

    def analysis_result
      {
        symbol: @instrument.symbol_name,
        interval: @series.interval,
        structure: Indicators::Structure.new(@series).summary,
        order_blocks: Indicators::OrderBlock.new(@series).summary,
        fair_value_gaps: Indicators::FairValueGap.new(@series).summary,
        current_price: @series.closes.last,
        signal: signal? ? :long_entry : :hold
      }
    end
  end
end


# File: app/services/strategies/smc_strategy.rb
# frozen_string_literal: true

module Strategies
  class SmcStrategy < ApplicationService
    def initialize(series:)
      @series = series
      @candles = series.candles
      @score = 0
      @reasons = []
    end

    def call
      return hold_signal('Not enough candles') if candles.size < 50

      # Run all Smc indicators
      bos     = Smc::Bos.call(series: series)
      choch   = Smc::Choch.call(series: series)
      order_blocks = Smc::OrderBlock.call(series: series)
      fvg     = Smc::FairValueGap.call(series: series)
      mitg    = Smc::Mitigation.call(series: series)
      induc   = Smc::Inducement.call(series: series)
      grab_up = series.liquidity_grab_up?
      grab_dn = series.liquidity_grab_down?

      # Scoring
      apply_score(:bos, bos)
      apply_score(:choch, choch)
      apply_score(:order_block, order_blocks)
      apply_score(:fvg, fvg)
      apply_score(:mitigation, mitg)
      apply_score(:inducement, induc)
      apply_score(:liquidity_grab_up, grab_up)
      apply_score(:liquidity_grab_down, grab_dn)

      confidence = score

      if confidence >= 70 && (bos || choch)
        action = if grab_up
                   :buy_pe
                 else
                   grab_dn ? :buy_ce : :hold
                 end
        build_signal(action, confidence)
      else
        hold_signal("Low Smc confidence: #{confidence}%")
      end
    rescue StandardError => e
      notify_failure(e, 'SmcStrategy')
      hold_signal("Exception: #{e.message}")
    end

    private

    attr_reader :series, :score, :reasons, :candles

    def apply_score(name, result)
      return unless result

      weight = case name
               when :bos then 20
               when :choch then 15
               when :order_block then 10
               when :fvg then 10
               when :mitigation then 10
               when :inducement then 10
               when :liquidity_grab_up, :liquidity_grab_down then 15
               else 0
               end

      @score += weight
      reasons << "#{name.to_s.titleize} = TRUE (+#{weight})"
    end

    def build_signal(action, confidence)
      {
        strategy: :Smc,
        action: action,
        confidence: confidence,
        reasons: reasons,
        stop_loss: derive_sl(action),
        take_profit: derive_tp(action)
      }
    end

    def derive_sl(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.low - atr : last.high + atr
    end

    def derive_tp(action)
      atr = Indicators::AtrBand.call(series: series)
      last = series.last
      action == :buy_ce ? last.close + (3 * atr) : last.close - (3 * atr)
    end

    def hold_signal(reason)
      {
        strategy: :Smc,
        action: :hold,
        confidence: score,
        reasons: reasons << reason
      }
    end
  end
end


# File: app/services/strategies/vwap_rsi.rb
module Strategies
  class VwapRsi < BaseIndicatorStrategy
    def signal?
      close = instrument.candles.closes.last
      vwap = instrument.vwap
      rsi = instrument.rsi

      return :buy_ce if close > vwap && rsi > 40

      :buy_pe if close < vwap && rsi < 60
    end

    def confidence_score = 60
    def reason_text = "VWAP/RSI: Close=#{series.closes.last}, VWAP=#{series.vwap}, RSI=#{series.rsi.last}"
  end
end



# File: app/services/telegram_notifier.rb
# frozen_string_literal: true

require 'net/http'
require 'uri'

class TelegramNotifier
  TELEGRAM_API = 'https://api.telegram.org'

  def self.send_message(text, chat_id: nil, **extra_params)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendMessage', chat_id:, text:, **extra_params)
  end

  def self.send_chat_action(action:, chat_id: nil)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendChatAction', chat_id:, action:)
  end

  private_class_method def self.post(method, **params)
    uri = URI("#{TELEGRAM_API}/bot#{ENV.fetch('TELEGRAM_BOT_TOKEN')}/#{method}")
    res = Net::HTTP.post_form(uri, params)
    Rails.logger.error("Telegram #{method} failed: #{res.body}") unless res.is_a?(Net::HTTPSuccess)
    res
  rescue StandardError => e
    Rails.logger.error("Telegram #{method} error: #{e.message}")
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/import_instruments.rake
namespace :instruments do
  desc 'Import instruments from DhanHQ CSV'
  task import: :environment do
    pp 'Starting instruments import...'
    start_time = Time.current

    begin
      InstrumentsImporter.import_from_url

      duration = Time.current - start_time
      pp "\nImport completed successfully in #{duration.round(2)} seconds!"
      pp "Total Instruments: #{Instrument.count}"
      pp "Total Derivatives: #{Derivative.count}"

      # Show some stats
      pp "\n--- Stats ---"
      pp "NSE Instruments: #{Instrument.nse.count}"
      pp "BSE Instruments: #{Instrument.bse.count}"
      pp "NSE Derivatives: #{Derivative.nse.count}"
      pp "BSE Derivatives: #{Derivative.bse.count}"
      pp "Options: #{Derivative.options.count}"
      pp "Futures: #{Derivative.futures.count}"
      pp 'Instruments: Instrument.count'
      pp 'Derivatives: Derivative.count'
      pp "TOTAL: #{Instrument.count + Derivative.count}"
    rescue StandardError => e
      pp "Import failed: #{e.message}"
      pp e.backtrace.join("\n")
    end
  end

  desc 'Clear all instruments and derivatives'
  task clear: :environment do
    pp 'Clearing all instruments and derivatives...'
    Derivative.delete_all
    Instrument.delete_all
    pp 'Cleared successfully!'
  end

  desc 'Reimport (clear and import)'
  task reimport: %i[clear import]
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end


# File: config/initializers/dhanhq.rb
require 'DhanHQ'

DhanHQ.configure_with_env
DhanHQ.logger.level = (ENV['DHAN_LOG_LEVEL'] || 'INFO').upcase.then { |l| Logger.const_get(l) }

# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += %i[
  passw email secret token _key crypt salt certificate otp ssn cvv cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/openai.rb
OpenAI.configure do |config|
  config.access_token = ENV.fetch('OPENAI_API_KEY', nil)
end

# File: config/initializers/ws_hub.rb
# frozen_string_literal: true

if ENV['ENABLE_WS'] == 'true'
  cfg = Rails.application.config_for(:dhan_ws)
  Rails.application.config.to_prepare do
    Live::WsHub.instance.start!(mode: (cfg['mode'] || 'quote').to_sym)
    Array(cfg['initial']).each do |h|
      Live::WsHub.instance.subscribe(seg: h[:segment], sid: h[:security_id])
    end
  end

  at_exit do
    Live::WsHub.instance.stop!
  rescue StandardError
    nil
  end
end



