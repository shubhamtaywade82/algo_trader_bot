# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/lib/state/events.rb
# app/lib/state/events.rb
module State
  class Events
    PATH = Rails.root.join("tmp/trader_events.ndjson")

    def self.log(type:, data:)
      File.open(PATH, "a") { |f| f.puts({ ts: Time.now.iso8601, type:, data: }.to_json) }
    rescue => e
      Rails.logger.warn("Event log fail: #{e.class} #{e.message}")
    end

    def self.replay!
      return unless File.exist?(PATH)
      File.foreach(PATH) do |line|
        evt = JSON.parse(line) rescue next
        apply(evt["type"], evt["data"].deep_symbolize_keys)
      end
    end

    def self.apply(type, data)
      case type.to_sym
      when :order_upsert   then State::OrderCache.put!(data[:client_ref], data)
      when :order_delete   then # optional, already handled
      when :position_upsert then State::PositionCache.upsert!(**data.slice(:seg,:sid,:prod), attrs: data)
      when :position_delete then State::PositionCache.delete!(**data.slice(:seg,:sid,:prod))
      end
    end
  end
end


# File: app/lib/state/order_cache.rb
# app/lib/state/order_cache.rb
module State
  class OrderCache
    KEY = 'orders:v1' # single hash stored in Rails.cache

    def self.fetch_all
      Rails.cache.fetch(KEY) { {} } # { client_ref => { ... } }
    end

    def self.get(client_ref) = fetch_all[client_ref]

    def self.put!(client_ref, payload)
      h = fetch_all
      h[client_ref] = payload
      Rails.cache.write(KEY, h)
      Events.log(type: :order_upsert, data: payload)
      true
    end

    def self.find_by_broker_id(oid)
      fetch_all.values.find { |o| o[:broker_order_id] == oid }
    end

    def self.delete!(client_ref)
      h = fetch_all
      h.delete(client_ref)
      Rails.cache.write(KEY, h)
      Events.log(type: :order_delete, data: { client_ref: })
    end
  end
end


# File: app/lib/state/position_cache.rb
# app/lib/state/position_cache.rb
module State
  class PositionCache
    KEY = 'positions:v1' # { pos_key => {...} }

    def self.key(seg:, sid:, prod:)
      "#{seg}:#{sid}:#{prod}"
    end

    def self.fetch_all
      Rails.cache.fetch(KEY) { {} }
    end

    def self.get(seg:, sid:, prod:)
      fetch_all[key(seg:, sid:, prod:)]
    end

    def self.upsert!(seg:, sid:, prod:, attrs:)
      h = fetch_all
      k = key(seg:, sid:, prod:)
      h[k] = (h[k] || {}).merge(attrs).merge(updated_at: Time.current)
      Rails.cache.write(KEY, h)
      Events.log(type: :position_upsert, data: h[k].merge(key: k))
      h[k]
    end

    def self.delete!(seg:, sid:, prod:)
      h = fetch_all
      h.delete(key(seg:, sid:, prod:))
      Rails.cache.write(KEY, h)
      Events.log(type: :position_delete, data: { seg:, sid:, prod: })
    end
  end
end


# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/candle.rb
class Candle
  attr_reader :timestamp, :open, :high, :low, :close, :volume

  def initialize(ts:, open:, high:, low:, close:, volume:)
    @timestamp = ts
    @open = open.to_f
    @high = high.to_f
    @low = low.to_f
    @close = close.to_f
    @volume = volume.to_i
  end

  def bullish? = close >= open
  def bearish? = close < open
end

# File: app/models/candle_series.rb
class CandleSeries
  include Enumerable

  attr_reader :symbol, :interval, :candles

  def initialize(symbol:, interval: '5')
    @symbol = symbol
    @interval = interval
    @candles = []
  end

  def each(&) = candles.each(&)
  def add_candle(candle) = candles << candle

  def load_from_raw(response)
    normalise_candles(response).each do |row|
      @candles << Candle.new(
        ts: Time.zone.parse(row[:timestamp].to_s),
        open: row[:open], high: row[:high],
        low: row[:low], close: row[:close],
        volume: row[:volume]
      )
    end
  end

  def normalise_candles(resp)
    return [] if resp.blank?

    return resp.map { |c| slice_candle(c) } if resp.is_a?(Array)

    raise "Unexpected candle format: #{resp.class}" unless resp.is_a?(Hash) && resp['high'].is_a?(Array)

    size = resp['high'].size
    (0...size).map do |i|
      {
        open: resp['open'][i].to_f,
        close: resp['close'][i].to_f,
        high: resp['high'][i].to_f,
        low: resp['low'][i].to_f,
        timestamp: Time.zone.at(resp['timestamp'][i]),
        volume: resp['volume'][i].to_i
      }
    end
  end

  # Normalises a single candle entry which may be provided either as a Hash
  # with symbol/string keys or as an Array in the order:
  # [timestamp, open, high, low, close, volume].
  def slice_candle(candle)
    if candle.is_a?(Hash)
      {
        open: candle[:open] || candle['open'],
        close: candle[:close] || candle['close'],
        high: candle[:high] || candle['high'],
        low: candle[:low] || candle['low'],
        timestamp: candle[:timestamp] || candle['timestamp'],
        volume: candle[:volume] || candle['volume'] || 0
      }
    elsif candle.respond_to?(:[]) && candle.size >= 6
      {
        timestamp: candle[0],
        open: candle[1],
        high: candle[2],
        low: candle[3],
        close: candle[4],
        volume: candle[5]
      }
    else
      raise "Unexpected candle format: #{candle.inspect}"
    end
  end

  def opens  = candles.map(&:open)
  def closes = candles.map(&:close)
  def highs  = candles.map(&:high)
  def lows   = candles.map(&:low)

  def to_hash
    {
      'timestamp' => candles.map { |c| c.timestamp.to_i },
      'open' => opens,
      'high' => highs,
      'low' => lows,
      'close' => closes,
      'volume' => candles.map(&:volume)
    }
  end

  def hlc
    candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        high: c.high,
        low: c.low,
        close: c.close
      }
    end
  end

  def atr(period = 14)
    TechnicalAnalysis::Atr.calculate(hlc, period: period).first.atr
  end

  def swing_high?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].high
    left = candles[(index - lookback)...index].map(&:high)
    right = candles[(index + 1)..(index + lookback)].map(&:high)
    current > left.max && current > right.max
  end

  def swing_low?(index, lookback = 2)
    return false if index < lookback || index + lookback >= candles.size

    current = candles[index].low
    left = candles[(index - lookback)...index].map(&:low)
    right = candles[(index + 1)..(index + lookback)].map(&:low)
    current < left.min && current < right.min
  end

  def recent_highs(n = 20)
    candles.last(n).map(&:high)
  end

  def recent_lows(n = 20)
    candles.last(n).map(&:low)
  end

  def previous_swing_high
    recent_highs.sort[-2] # 2nd highest
  end

  def previous_swing_low
    recent_lows.sort[1]   # 2nd lowest
  end

  def liquidity_grab_up?(lookback: 20)
    high_now = candles.last.high
    high_prev = previous_swing_high

    high_now > high_prev &&
      candles.last.close < high_prev && # Rejection after breakout
      candles.last.bearish?
  end

  def liquidity_grab_down?(lookback: 20)
    low_now = candles.last.low
    low_prev = previous_swing_low

    low_now < low_prev &&
      candles.last.close > low_prev && # Rejection after breakdown
      candles.last.bullish?
  end

  def rsi(period = 14)
    RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: closes, period: period).call
  end

  def moving_average(period = 20)
    RubyTechnicalAnalysis::MovingAverages.new(series: closes, period: period)
  end

  def sma(period = 20)
    moving_average(period).sma
  end

  def ema(period = 20)
    moving_average(period).ema
  end

  def macd(fast_period = 12, slow_period = 26, signal_period = 9)
    macd = RubyTechnicalAnalysis::Macd.new(series: closes, fast_period: fast_period, slow_period: slow_period, signal_period: signal_period)
    macd.call
  end

  def rate_of_change(period = 5)
    closes = self.closes
    return nil if closes.size < period + 1

    # ((current_close - close_n_periods_ago) / close_n_periods_ago) * 100
    roc_series = []
    closes.each_with_index do |price, idx|
      if idx < period
        roc_series << nil # not enough data for these initial points
      else
        previous_price = closes[idx - period]
        roc_series << (((price - previous_price) / previous_price.to_f) * 100.0)
      end
    end
    roc_series
  end

  def supertrend_signal
    trend_line = Indicators::Supertrend.new(series: self).call
    return nil if trend_line.empty?

    latest_close = closes.last
    latest_trend = trend_line.last

    return :long_entry if latest_close > latest_trend

    :short_entry if latest_close < latest_trend
  end

  def inside_bar?(i)
    return false if i < 1

    curr = @candles[i]
    prev = @candles[i - 1]
    curr.high < prev.high && curr.low > prev.low
  end

  def bollinger_bands(period: 20)
    return nil if candles.size < period

    bb = RubyTechnicalAnalysis::BollingerBands.new(
      series: closes,
      period: period
    ).call

    { upper: bb[0], lower: bb[1], middle: bb[2] }
  end

  def donchian_channel(period: 20)
    return nil if candles.size < period

    dc = candles.each_with_index.map do |c, _i|
      {
        date_time: Time.zone.at(c.timestamp || 0),
        value: c.close
      }
    end
    TechnicalAnalysis::Dc.calculate(dc, period: period)
  end
end

# File: app/models/concerns/candle_extension.rb
# Extend Instrument with candle series integration
module CandleExtension
  extend ActiveSupport::Concern

  included do
    def candles(interval: '5')
      @ohlc_cache ||= {}
      return @ohlc_cache[interval] if @ohlc_cache[interval] && !ohlc_stale?(interval)

      raw_data = intraday_ohlc(interval: interval)
      return nil if raw_data.blank?

      @ohlc_cache[interval] = CandleSeries.new(symbol: symbol_name, interval: interval).tap do |series|
        series.load_from_raw(raw_data)
      end
    end

    def ohlc_stale?(interval)
      return true unless @last_ohlc_fetched

      Time.current - (@last_ohlc_fetched[interval] ||= 1.hour.ago) > 5.minutes
    ensure
      @last_ohlc_fetched ||= {}
      @last_ohlc_fetched[interval] = Time.current
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end

    def rsi(period = 14, interval: '5')
      cs = candles(interval: interval)
      cs&.rsi(period)
    end

    def macd(fast_period = 12, slow_period = 26, signal_period = 9, interval: '5')
      cs = candles(interval: interval)
      macd_result = cs&.macd(fast_period, slow_period, signal_period)
      return nil unless macd_result

      {
        macd: macd_result[0],
        signal: macd_result[1],
        histogram: macd_result[2]
      }
    end

    def adx(period = 14, interval: '5')
      cs = candles(interval: interval)
      closes = cs&.closes
      highs  = cs&.highs
      lows   = cs&.lows
      return nil unless closes && highs && lows

      hlc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end

      ta_adx = TechnicalAnalysis::Adx.calculate(hlc, period: period).first
      ta_adx&.adx
    end

    def supertrend_signal(interval: '5')
      cs = candles(interval: interval)
      cs&.supertrend_signal
    end

    def liquidity_grab_up?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_up?
    end

    def liquidity_grab_down?(interval: '5')
      cs = candles(interval: interval)
      cs&.liquidity_grab_down?
    end

    def bollinger_bands(period: 20, interval: '5')
      cs = candles(interval: interval)
      return nil unless cs

      cs.bollinger_bands(period: period)
    end

    def donchian_channel(period: 20, interval: '5')
      cs = candles(interval: interval)

      dc = cs.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          value: c.close
        }
      end
      TechnicalAnalysis::Dc.calculate(dc, period: period)
    end

    def obv(interval: '5')
      dcv = candles(interval: interval).candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          close: c.close,
          volume: c.volume || 0
        }
      end

      TechnicalAnalysis::Obv.calculate(dcv)
    end

    def candle_series(interval: '5')
      candles(interval: interval)
    end
  end
end


# File: app/models/concerns/instrument_helpers.rb
module InstrumentHelpers
  extend ActiveSupport::Concern
  include CandleExtension

  included do
    # Enums common to Instrument and Derivative
    enum :exchange, { nse: 'NSE', bse: 'BSE', mcx: 'MCX' }
    enum :segment, { index: 'I', equity: 'E', currency: 'C', derivatives: 'D', commodity: 'M' }, prefix: true
    enum :instrument_code, {
      index: 'INDEX',
      futures_index: 'FUTIDX',
      options_index: 'OPTIDX',
      equity: 'EQUITY',
      futures_stock: 'FUTSTK',
      options_stock: 'OPTSTK',
      futures_currency: 'FUTCUR',
      options_currency: 'OPTCUR',
      futures_commodity: 'FUTCOM',
      options_commodity: 'OPTFUT'
    }, prefix: true

    scope :nse, -> { where(exchange: 'NSE') }
    scope :bse, -> { where(exchange: 'BSE') }

    # Validations for enums can also go here, if common
  end

  # Shared instance methods for market data fetching and helpers
  def ltp
    fetch_ltp_from_api
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def quote_ltp
    quote = quotes.order(tick_time: :desc).first
    return nil unless quote

    quote.ltp.to_f
  rescue StandardError => e
    Rails.logger.error("Failed to fetch latest quote LTP for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def fetch_ltp_from_api
    response = DhanHQ::Models::MarketFeed.ltp(exch_segment_enum)
    response.dig('data', exchange_segment, security_id.to_s, 'last_price') if response['status'] == 'success'
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP from API for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def subscribe_params
    { ExchangeSegment: exchange_segment, SecurityId: security_id.to_s }
  end

  def ws_get
    Live::TickCache.get(exchange_segment, security_id.to_s)
  end

  def ws_ltp
    ws_get&.dig(:ltp)
  end

  def ohlc
    response = DhanHQ::Models::MarketFeed.ohlc(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def historical_ohlc(from_date: nil, to_date: nil, oi: false)
    DhanHQ::Models::HistoricalData.daily(
      securityId: security_id,
      exchangeSegment: exchange_segment,
      instrument: instrument_type,
      oi: oi,
      fromDate: from_date || (Time.zone.today - 365).to_s,
      toDate: to_date || (Time.zone.today - 1).to_s,
      expiryCode: 0
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Historical OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def intraday_ohlc(interval: '5', oi: false, from_date: nil, to_date: nil, days: 90)
    to_date ||= MarketCalendar.today_or_last_trading_day.to_s
    from_date ||= (Date.parse(to_date) - days).to_s # fetch last 5 sessions by default

    DhanHQ::Models::HistoricalData.intraday(
      security_id: security_id,
      exchange_segment: exchange_segment,
      instrument: instrument_type,
      interval: interval,
      oi: oi,
      from_date: from_date || (Time.zone.today - days).to_s,
      to_date: to_date || (Time.zone.today - 1).to_s
    )
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Intraday OHLC for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  def depth
    response = DhanHQ::Models::MarketFeed.quote(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for #{self.class.name} #{security_id}: #{e.message}")
    nil
  end

  # Helper method: dynamic exchange_segment string for API calls
  def exchange_segment
    case [exchange.to_sym, segment.to_sym]
    when %i[nse index], %i[bse index] then 'IDX_I'
    when %i[nse equity] then 'NSE_EQ'
    when %i[bse equity] then 'BSE_EQ'
    when %i[nse derivatives] then 'NSE_FNO'
    when %i[bse derivatives] then 'BSE_FNO'
    when %i[nse currency] then 'NSE_CURRENCY'
    when %i[bse currency] then 'BSE_CURRENCY'
    when %i[mcx commodity] then 'MCX_COMM'
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  private

  def exch_segment_enum
    { exchange_segment => [security_id.to_i] }
  end

  def numeric_value?(value)
    value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
  end
end

# File: app/models/concerns/instrument_type_mapping.rb
# frozen_string_literal: true

module InstrumentTypeMapping
  # ------------------------------------------------------------------
  # Parent ‚Üí child mapping straight from Dhan CSV spec
  # ------------------------------------------------------------------
  PARENT_TO_CHILDREN = {
    'INDEX' => %w[FUTIDX OPTIDX],
    'EQUITY' => %w[FUTSTK OPTSTK],
    # Commodity & Currency don‚Äôt have their own high-level codes in CSV,
    # so we treat the futures variant itself as ‚Äúparent‚Äù.
    'FUTCOM' => %w[OPTFUT],
    'FUTCUR' => %w[OPTCUR]
  }.freeze

  # ------------------------------------------------------------------
  # Child ‚Üí parent lookup (built from the hash above)
  # ------------------------------------------------------------------
  CHILD_TO_PARENT =
    PARENT_TO_CHILDREN.flat_map { |parent, kids| kids.map { |kid| [kid, parent] } }
                      .to_h
                      .freeze

  # --------------------------------------------------
  # Public helpers
  # --------------------------------------------------

  # Given *any* code, return its underlying parent.
  #   underlying_for("FUTIDX")  => "INDEX"
  #   underlying_for("INDEX")   => "INDEX"
  def self.underlying_for(code)
    CHILD_TO_PARENT[code] || code
  end

  # Given an underlying parent, return all derivative codes
  #   derivative_codes_for("INDEX") => ["FUTIDX","OPTIDX"]
  def self.derivative_codes_for(parent_code)
    PARENT_TO_CHILDREN[parent_code] || []
  end

  # Convenience lists
  def self.all_parents  = PARENT_TO_CHILDREN.keys
  def self.all_children = CHILD_TO_PARENT.keys
end


# File: app/models/derivative.rb
class Derivative < ApplicationRecord
  include InstrumentHelpers

  belongs_to :instrument

  scope :options, -> { where.not(option_type: [nil, '']) }
  scope :futures, -> { where(option_type: [nil, '']) }
end


# File: app/models/holding.rb
class Holding < ApplicationRecord
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  include InstrumentHelpers

  has_many :derivatives, dependent: :destroy

  accepts_nested_attributes_for :derivatives, allow_destroy: true

  # API Methods
  def fetch_option_chain(expiry = nil)
    expiry ||= expiry_list.first
    data = DhanHQ::Models::OptionChain.fetch(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment,
      expiry: expiry
    )
    return nil unless data

    filtered_data = filter_option_chain_data(data)

    { last_price: data['last_price'], oc: filtered_data }
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{security_id}: #{e.message}")
    nil
  end

  def filter_option_chain_data(data)
    data['oc'].select do |_strike, option_data|
      call_data = option_data['ce']
      put_data = option_data['pe']

      has_call_values = call_data && call_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end
      has_put_values = put_data && put_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end

      has_call_values || has_put_values
    end
  end

  def expiry_list
    DhanHQ::Models::OptionChain.fetch_expiry_list(
      underlying_scrip: security_id.to_i,
      underlying_seg: exchange_segment
    )
  end
end


# File: app/models/position.rb
class Position < ApplicationRecord
  belongs_to :tradable, polymorphic: true, optional: true

  enum :state, { open: 'OPEN', closed: 'CLOSED' }, prefix: :state

  # convenience helpers
  def instrument? = tradable_type == 'Instrument'
  def derivative? = tradable_type == 'Derivative'

  def security_id = self[:security_id] || tradable&.security_id
  def exchange_segment = self[:exchange_segment] || tradable&.exchange_segment
end


# File: app/models/scalp_session.rb
class ScalpSession < ApplicationRecord
  enum :status, { idle: 'idle', running: 'running', stopped: 'stopped', killed: 'killed' }

  validates :trade_date, presence: true
  validates :capital, :max_day_loss, :realized_pnl, :equity_peak, numericality: true

  def equity
    capital + realized_pnl
  end
end


# File: app/models/setting.rb
class Setting < ApplicationRecord
  validates :key, presence: true, uniqueness: true

  # Cached read
  def self.fetch(key, default = nil, ttl: 30)
    Rails.cache.fetch("setting:#{key}", expires_in: ttl.seconds) do
      find_by(key:)&.value || default
    end
  end

  # Write + cache bust
  def self.put(key, value)
    rec = find_or_initialize_by(key:)
    rec.value = value.to_s
    rec.save!
    Rails.cache.delete("setting:#{key}")
    value
  end

  # Typed helpers (quality of life)
  def self.fetch_i(key, default = 0) = fetch(key, default).to_i
  def self.fetch_f(key, default = 0.0) = fetch(key, default).to_f

  def self.fetch_bool(key, default = false) # rubocop:disable Style/OptionalBooleanParameter,Naming/PredicateMethod
    raw = fetch(key, default)
    return !!raw if [true, false].include?(raw)

    %w[1 true yes on].include?(raw.to_s.strip.downcase)
  end
end

# File: app/services/application_service.rb
# frozen_string_literal: true

class ApplicationService
  def self.call(...)
    new(...).call
  end

  private

  # ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
  # üì£ Telegram Integration
  # ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë

  def notify_step(step, message = nil)
    notify("üîπ Step: #{step}\n#{message || '...'}", tag: step.to_s.upcase)
  end

  def notify_success(message = '‚úÖ Step completed successfully')
    notify(message, tag: 'SUCCESS')
  end

  def notify_failure(error, step = nil)
    notify("‚ùå Failure#{" at #{step}" if step}: #{error.class} ‚Äì #{error.message}", tag: 'FAILURE')
  end

  def notify(message, tag: nil)
    context = "[#{self.class.name}]"
    final_message = tag.present? ? "#{context} [#{tag}] \n\n #{message}" : "#{context} #{message}"
    TelegramNotifier.send_message(final_message)
  rescue StandardError => e
    log_error("Telegram Notify Failed: #{e.class} - #{e.message}")
  end

  def typing_ping
    TelegramNotifier.send_chat_action(chat_id: nil, action: 'typing')
  rescue StandardError => e
    log_error("Telegram Typing Action Failed: #{e.class} - #{e.message}")
  end

  # ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
  # üßæ Logging Helpers (auto-prefix with class name)
  # ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë

  %i[info warn error debug].each do |lvl|
    define_method("log_#{lvl}") do |msg|
      Rails.logger.send(lvl, "[#{self.class.name}] #{msg}")
    end
  end
end

# File: app/services/bars/fetch_loop.rb
# frozen_string_literal: true

module Bars
  class FetchLoop
    class << self
      def start(symbols:, timeframe: '1m', &on_series)
        stop
        @running = true
        @thread = Thread.new do
          while @running
            begin
              tick = Time.current
              symbols.each do |sym|
                inst = Instrument.segment_index.find_by(symbol_name: sym) || Instrument.segment_equity.find_by(display_name: sym)
                next unless inst

                raw = inst.intraday_ohlc(interval: interval_for(timeframe), days: 20)
                next if raw.blank?

                series = CandleSeries.new(symbol: inst.symbol_name, interval: interval_for(timeframe))
                series.load_from_raw(raw)
                on_series&.call(sym, series)
              end
            rescue StandardError => e
              Rails.logger.error("[Bars::FetchLoop] #{e.class}: #{e.message}")
            ensure
              sleep sleep_to_next_bar(timeframe, from: tick)
            end
          end
        end
      end

      def stop
        @running = false
        @thread&.kill
        @thread = nil
      end

      private

      def interval_for(tf)
        case tf.to_s
        when '1m' then '1'
        when '3m' then '3'
        when '5m' then '5'
        when '15m' then '15'
        else '1'
        end
      end

      def sleep_to_next_bar(tf, from:)
        secs = case tf.to_s
               when '1m'  then 60
               when '3m'  then 180
               when '5m'  then 300
               when '15m' then 900
               else 60
               end
        drift  = (Time.current - from).to_f
        remain = secs - (from.to_i % secs)
        [remain + 2 - drift, 5].max
      end
    end
  end
end


# File: app/services/broker/reconcile_light.rb
# app/services/broker/reconcile_light.rb
module Broker
  class ReconcileLight < ApplicationService
    def call
      reconcile_positions
      reconcile_orders # optional; super orders list is useful
    end

    def reconcile_positions
      broker = DhanHQ::Models::Position.all # GET /v2/positions
      seen = {}
      broker.each do |p|
        seg = p.exchange_segment; sid = p.security_id; prod = p.product_type
        k = State::PositionCache.key(seg:, sid:, prod:)
        seen[k] = true

        State::PositionCache.upsert!(
          seg:, sid:, prod:,
          attrs: {
            trading_symbol: p.trading_symbol,
            net_qty:        p.net_qty.to_i,
            buy_avg:        p.buy_avg.to_f,
            sell_avg:       p.sell_avg.to_f,
            realized:       p.realized_profit.to_f,
            unrealized:     p.unrealized_profit.to_f,
            external:       external?(k) # mark external if not in local orders
          }
        )
      end

      # remove closed entries
      State::PositionCache.fetch_all.keys.each do |k|
        State::PositionCache.delete!(**split(k)) unless seen[k]
      end
    end

    def reconcile_orders
      # optional: only when you need status or leg details
      supers = DhanHQ::Models::SuperOrder.all # GET /v2/super/orders
      supers.each do |o|
        cref = o["correlationId"]
        next unless cref
        State::OrderCache.put!(cref, {
          client_ref: cref,
          broker_order_id: o["orderId"],
          status: o["orderStatus"],
          quantity: o["quantity"].to_i,
          filled_qty: o["filledQty"].to_i,
          remaining_quantity: o["remainingQuantity"].to_i,
          target_price: o.dig("legDetails")&.find{_1["legName"]=="TARGET_LEG"}&.[]("price"),
          stop_loss_price: o.dig("legDetails")&.find{_1["legName"]=="STOP_LOSS_LEG"}&.[]("price"),
          trailing_jump: o.dig("legDetails")&.find{_1["legName"]=="STOP_LOSS_LEG"}&.[]("trailingJump")
        }.compact)
      end
    end

    def split(k)
      seg, sid, prod = k.split(":")
      { seg:, sid: sid.to_i, prod: }
    end

    def external?(k)
      # If no local order references this pos key recently, consider it external
      State::OrderCache.fetch_all.values.none? { |o| o[:pos_key] == k }
    end
  end
end


# File: app/services/derivatives/picker.rb
# frozen_string_literal: true

# app/services/derivatives/picker.rb
#
# Orchestrates "what to trade" for AutoPilot:
#  - fetch nearest-expiry option chain for an underlying
#  - compute iv_rank (0..1) for current chain
#  - call Option::ChainAnalyzer (your advanced scorer) to gate & rank strikes
#  - resolve the chosen strike into a tradable Derivative (security_id, lot_size)
#
# Returns Result struct or nil.
#
# Usage:
#   pick = Derivatives::Picker.call(
#     instrument: nifty,                # AR Instrument
#     side: :ce,                        # :ce or :pe (bullish=ce / bearish=pe)
#     strategy_type: 'intraday',        # 'intraday' or 'swing'
#     expiry: nil,                      # default nearest expiry
#     signal_strength: 1.0              # optional multiplier into analyzer
#   )
#   if pick
#     pick.derivative   # => AR Derivative (has security_id, lot_size)
#     pick.selected     # => Hash from analyzer (strike_price, last_price, iv, greeks‚Ä¶)
#     pick.ranked       # => Top-N ranked array from analyzer
#     pick.side         # => :ce / :pe
#     pick.expiry       # => Date
#   end
#
module Derivatives
  class Picker < ApplicationService
    Result = Struct.new(:selected, :ranked, :derivative, :expiry, :side, :iv_rank, keyword_init: true)

    def initialize(instrument:, side:, strategy_type: 'intraday', expiry: nil, signal_strength: 1.0)
      @instrument      = instrument
      @side            = side.to_s.downcase.to_sym # :ce or :pe
      @strategy_type   = strategy_type.to_s
      @signal_strength = signal_strength.to_f
      @expiry          = expiry || safe_nearest_expiry_for(instrument)
    end

    def call
      return nil unless @instrument && %i[ce pe].include?(@side) && @expiry

      chain = fetch_chain(@expiry)
      return nil unless chain && chain[:oc].present?

      iv_rank = iv_rank_for(chain)

      analyzer = Option::ChainAnalyzer.new(
        chain,
        expiry: @expiry,
        underlying_spot: (chain[:last_price].presence || ltp(@instrument)).to_f,
        iv_rank: iv_rank,
        historical_data: @instrument.intraday_ohlc(interval: '5', days: 3) || historical_data
      )
      res = analyzer.analyze(signal_type: @side, strategy_type: @strategy_type, signal_strength: @signal_strength)
      return nil unless res[:proceed] && res[:selected]

      drv = resolve_derivative(res[:selected], @expiry, @side)
      return nil unless drv

      Result.new(
        selected: res[:selected],
        ranked: res[:ranked],
        derivative: drv,
        expiry: @expiry,
        side: @side,
        iv_rank: iv_rank
      )
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] #{e.class} ‚Äì #{e.message}")
      nil
    end

    # ------------------------------------------------------------------------
    private

    def fetch_chain(expiry)
      @instrument.fetch_option_chain(expiry)
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] chain fetch failed for #{expiry}: #{e.message}")
      nil
    end

    def safe_nearest_expiry_for(inst)
      list = Array(inst.expiry_list)
      list.first if list.any?
    rescue StandardError
      nil
    end

    def ltp(inst)
      Live::TickCache.ltp(inst.exchange_segment, inst.security_id) || inst.ltp
    rescue StandardError
      nil
    end

    # Normalizes current IV within chain range ‚Üí rank ‚àà [0,1].
    def iv_rank_for(chain)
      oc = chain[:oc] || {}
      spot = (chain[:last_price] || 0).to_f
      return 0.5 if oc.empty? || spot <= 0

      strikes = oc.keys.map(&:to_f)
      atm     = strikes.min_by { |s| (s - spot).abs }
      return 0.5 unless atm

      atm_k = format('%.6f', atm)
      ce_iv = oc.dig(atm_k, 'ce', 'implied_volatility').to_f
      pe_iv = oc.dig(atm_k, 'pe', 'implied_volatility').to_f
      current = [ce_iv, pe_iv].select(&:positive?).then { |a| a.empty? ? 0 : a.sum / a.size }

      all = oc.values.flat_map { |row| %w[ce pe].map { |k| row.dig(k, 'implied_volatility').to_f } }.reject(&:zero?)
      return 0.5 if all.empty? || all.max == all.min

      ((current - all.min) / (all.max - all.min)).clamp(0.0, 1.0).round(3)
    rescue StandardError
      0.5
    end

    def historical_data
      if @strategy_type == 'intraday'
        intraday_candles
      else
        daily_candles
      end
    end

    def daily_candles
      DhanHQ::Models::HistoricalData.daily(
        securityId: @instrument.security_id,
        exchangeSegment: @instrument.exchange_segment,
        instrument: @instrument.instrument_type,
        fromDate: 45.days.ago.to_date,
        toDate: Date.yesterday
      )
    rescue StandardError
      []
    end

    def intraday_candles
      DhanHQ::Models::HistoricalData.intraday(
        security_id: @instrument.security_id,
        exchange_segment: @instrument.exchange_segment,
        instrument: @instrument.instrument_type,
        interval: '5',
        from_date: 5.days.ago.to_date.iso8601,
        to_date: Time.zone.today.iso8601
      )
    rescue StandardError
      []
    end

    def resolve_derivative(selected, expiry, side)
      @instrument.derivatives.find_by(
        strike_price: selected[:strike_price],
        expiry_date: expiry,
        option_type: side.to_s.upcase # 'CE' / 'PE'
      )
    rescue StandardError => e
      Rails.logger.error("[Derivatives::Picker] derivative lookup failed: #{e.message}")
      nil
    end
  end
end


# File: app/services/execution/order_executor.rb
module Execution
  class OrderExecutor
    def self.buy_option_ce(instrument)
      # Derive CE option symbol from spot instrument
      derivative = DerivativePicker.pick_ce(instrument)

      order = DhanHQ::Models::Order.new(
        transaction_type: 'BUY',
        exchange_segment: 'NSE_FNO',
        product_type: 'INTRADAY',
        order_type: 'MARKET',
        validity: 'DAY',
        security_id: derivative.security_id,
        quantity: derivative.lot_size
      )

      order.save
    end
  end
end

# File: app/services/execution/position_guard.rb
module Execution
  class PositionGuard
    TICK_INTERVAL_MS = 200 # safety if you rate-limit checks

    PositionState = Struct.new(
      :security_id, :segment, :entry_price, :peak_price, :entered_at,
      :trailing_mode, :underlying_symbol, :last_underlying_high_ts, :last_underlying_high
    )

    class << self
      def start(budget)
        @budget = budget
        @states = {}
        @mutex  = Mutex.new
        @running = true
        boot_ws_handlers
      end

      def stop
        @running = false
      end

      def register_intent(intent)
        state = PositionState.new(
          intent.security_id,
          intent.exchange_segment,
          BigDecimal(intent.entry_price.to_s),
          BigDecimal(intent.entry_price.to_s),
          Time.current,
          false,
          intent.underlying_symbol,
          Time.current,
          nil
        )
        @mutex.synchronize { @states[key(intent)] = state }
      end

      private

      def key(intent_or_state)
        "#{intent_or_state.segment}:#{intent_or_state.security_id}"
      end

      def boot_ws_handlers
        # Hook into your WS tick stream
        DhanHQ::WS::Bus.on_tick do |tick|
          next unless @running

          handle_tick(tick)
        end
      end

      def handle_tick(tick)
        k = "#{tick.segment}:#{tick.security_id}"
        state = @states[k]
        return unless state

        ltp = BigDecimal(tick.ltp.to_s)
        return if ltp <= 0

        # Peak tracking
        state.peak_price = [state.peak_price, ltp].max

        # Flip to trailing mode once profit exceeds max(1%, ‚Çπ1000)
        profit_pct = (ltp - state.entry_price) / state.entry_price
        if !state.trailing_mode && (profit_pct >= 0.01 || (ltp - state.entry_price) * lot_size_for(state) >= @budget.profit_trigger_rupees)
          state.trailing_mode = true
        end

        # Hard SL: 10% from entry
        if ltp <= state.entry_price * BigDecimal('0.90')
          exit_and_finalize!(state, reason: :hard_sl)
          return
        end

        # Time stop: 3 minutes and not green
        if Time.current - state.entered_at >= 3.minutes && ltp <= state.entry_price
          exit_and_finalize!(state, reason: :time_stop)
          return
        end

        # Trailing exit: 1% drop from peak once trailing_mode
        return unless state.trailing_mode && ltp <= state.peak_price * BigDecimal('0.99')

        exit_and_finalize!(state, reason: :trail_hit)
        nil

        # Optional: consolidation on underlying (update via separate underlying feed)
        # if no new underlying high for 2+ bars, consider exit
        # Pseudocode placeholders:
        # if underlying_consolidating?(state.underlying_symbol)
        #   exit_and_finalize!(state, reason: :underlying_consolidation)
        # end
      end

      def lot_size_for(state)
        # Look up derivative by security_id if needed; fallback 1
        Derivative.find_by(security_id: state.security_id)&.lot_size.to_i.nonzero? || 1
      end

      def exit_and_finalize!(state, reason:)
        # If super order placed ‚Üí modify/cancel bracket; else market exit
        Orders::Manager.exit_position!(security_id: state.security_id, segment: state.segment, reason: reason)
        # Compute realized_pnl from broker or internal calc
        realized = Orders::Analyzer.realized_pnl_for(state.security_id, state.segment) # returns decimal ‚Çπ
        @budget.on_trade_closed!(realized_pnl: realized)
        @mutex.synchronize { @states.delete("#{state.segment}:#{state.security_id}") }
        CloseStrikesManager.unsubscribe_if_unused(state.security_id, state.segment)
      rescue StandardError => e
        Rails.logger.error("[PositionGuard] exit failed #{state.inspect} #{e.class}: #{e.message}")
      end
    end
  end
end

# File: app/services/exits/alignment_guard.rb
# app/services/exits/alignment_guard.rb
class Exits::AlignmentGuard < ApplicationService
  def initialize(order:, underlying_symbol:)
    @order = order
    @symbol = underlying_symbol
  end

  def call
    inst = Instrument.segment_index.find_by(symbol_name: @symbol) || Instrument.segment_equity.find_by(display_name: @symbol)
    return true unless inst

    sig = inst.supertrend_signal(interval: '5') # :long_entry / :short_entry
    return true unless sig

    long = (@order.side.to_s == 'buy') # we buy premium for CE/PE
    # If CE ‚Üí need long_entry; if PE ‚Üí need short_entry; otherwise suggest exit
    return (sig == :long_entry) if @order.cp == 'CE'
    return (sig == :short_entry) if @order.cp == 'PE'

    true
  end
end


# File: app/services/exits/micro_tp.rb
# app/services/exits/micro_tp.rb
# Tightens TP and arms BE when live conditions indicate chop after entry.
class Exits::MicroTP < ApplicationService
  # order: Order with super_ref, tp_value, trail_sl_value, entry_price
  # ltp:   current premium
  # entry_ts: Time the position was opened
  # side: :buy_ce or :buy_pe (profit when premium rises for both)
  def initialize(order:, ltp:, entry_ts:, side:)
    @order     = order
    @ltp       = ltp.to_f
    @entry_ts  = entry_ts || Time.now
    @side      = side
    @entry_pr  = order.entry_price.to_f
    @r         = (@entry_pr * 0.25) # 25% SL baseline ‚Üí 1R
  end

  def call
    return unless valid_order?

    mfe_r   = [(@ltp - @entry_pr) / (@r.nonzero? || 1.0), 0].max
    stalled = stalled_seconds >= 180 # ‚â• 3 minutes inside deadband
    spreadp = spread_pct || 0.0

    if chop_live?(mfe_r:, stalled:, spreadp:)
      tighten_tp!
      arm_break_even!
    end

    time_stop!
  rescue StandardError => e
    Rails.logger.warn("[MicroTP] #{e.class} #{e.message}")
  end

  private

  def valid_order?
    @order&.super_ref.present? && @entry_pr.positive?
  end

  def chop_live?(mfe_r:, stalled:, spreadp:)
    # < 0.5R after 5 minutes OR stalled 3m OR spread% > 0.8
    return true if (Time.now - @entry_ts) > 300 && mfe_r < 0.5
    return true if stalled
    return true if spreadp > 0.8

    false
  end

  def tighten_tp!
    # Target: entry + 0.30R from entry premium (or keep current if tighter)
    target = PriceMath.round_tick(@entry_pr + (@r * 0.30))
    cur    = @order.tp_value.to_f
    return if cur.positive? && target >= cur # only tighten (lower TP level)

    Orders::SuperModifier.call(order: @order, new_tp_value: target)
  end

  def arm_break_even!
    # Raise trailing SL to slightly below entry (e.g., entry - 0.10R)
    be = PriceMath.round_tick(@entry_pr - (@r * 0.10))
    cur = @order.trail_sl_value.to_f
    return if cur.positive? && be <= cur # only raise/tighten trail

    Orders::SuperModifier.call(order: @order, new_trail_sl_value: be)
  end

  def time_stop!
    # Hard time stop at 8 minutes with no TP hit
    return unless (Time.now - @entry_ts) > 480

    begin
      DhanHQ::SuperOrders.close(super_order_id: @order.super_ref)
    rescue StandardError
      nil
    end
  end

  # ---- stall & spread helpers ----

  # Tracks last "meaningful move" (> 0.1R) in Rails.cache per order
  def stalled_seconds
    key = "stall:#{@order.super_ref}"
    last = Rails.cache.fetch(key) do
      { ltp: @ltp, ts: Time.now }
    end

    if (@ltp - last[:ltp]).abs >= (@r * 0.10)
      Rails.cache.write(key, { ltp: @ltp, ts: Time.now }, expires_in: 1.hour)
      0
    else
      (Time.now - (last[:ts] || Time.now)).to_i
    end
  end

  def spread_pct
    # Try to read bid/ask via your quote source; fallback to modest value
    quote = safe { Live::Quote.get(@order.instrument.exchange_segment, @order.instrument.security_id) } ||
            safe { DhanHQ::MarketData.quote(@order.instrument.security_id) }
    return 0.4 unless quote

    bid = quote[:bid].to_f
    ask = quote[:ask].to_f
    mid = [(bid + ask) / 2.0, @ltp].compact.max
    return 0.4 if mid <= 0 || ask <= 0 || bid <= 0

    (((ask - bid).abs / mid) * 100.0).round(2)
  rescue StandardError
    0.4
  end

  def safe(&)
    yield
  rescue StandardError
    nil
  end
end


# File: app/services/indicators/calculator.rb
module Indicators
  class Calculator
    def initialize(series)
      @series = series
    end

    def rsi(period = 14)
      RubyTechnicalAnalysis::RelativeStrengthIndex.new(series: @series.closes, period:).call
    end

    def macd
      RubyTechnicalAnalysis::Macd.new(series: @series.closes).call
    end

    def adx(period = 14)
      hlc = @series.candles.each_with_index.map do |c, _i|
        {
          date_time: Time.zone.at(c.timestamp || 0), # <- NEW
          high: c.high,
          low: c.low,
          close: c.close
        }
      end
      TechnicalAnalysis::Adx.calculate(hlc, period:).last.adx
    end

    def bullish_signal?
      rsi < 30 && adx > 20 && @series.closes.last > @series.closes[-2]
    end

    def bearish_signal?
      rsi > 70 && adx > 20 && @series.closes.last < @series.closes[-2]
    end
  end
end

# File: app/services/indicators/holy_grail.rb
# app/services/indicators/holy_grail.rb
# frozen_string_literal: true

require 'ruby_technical_analysis'
require 'technical_analysis'

module Indicators
  class HolyGrail < ApplicationService
    RTA = RubyTechnicalAnalysis
    TA  = TechnicalAnalysis

    # Keep the default lens as constants (unchanged)
    EMA_FAST  = 34
    EMA_SLOW  = 100
    RSI_LEN   = 14
    ADX_LEN   = 14
    ATR_LEN   = 20
    MACD_F = 12
    MACD_S = 26
    MACD_SIG = 9

    # New: default gates (used unless overridden via config:)
    DEFAULTS = {
      ema_fast: EMA_FAST,
      ema_slow: EMA_SLOW,
      rsi_len: RSI_LEN,
      adx_len: ADX_LEN,
      atr_len: ATR_LEN,
      macd_f: MACD_F,
      macd_s: MACD_S,
      macd_sig: MACD_SIG,

      # ‚Äúproceed?‚Äù gates
      adx_gate: 20.0, # >= this to allow entries
      rsi_up_min: 40.0, # bullish momentum must be above
      rsi_down_max: 60.0, # bearish momentum must be below

      # sanity for history length (keep ‚â• slow MA by default)
      min_candles: EMA_SLOW
    }.freeze

    # Handful of presets you can reuse from callers:
    def self.demo_config
      {
        # keep math stable but relax gates to near-zero so demo always ‚Äúflows‚Äù
        adx_gate: 0.0,
        rsi_up_min: 0.0,
        rsi_down_max: 100.0,
        min_candles: 1 # allow tiny series in demo
      }
    end

    Result = Struct.new(
      :bias, :adx, :momentum, :proceed?,
      :sma50, :ema200, :rsi14, :atr14, :macd, :trend,
      keyword_init: true
    ) do
      def to_h = members.zip(values).to_h
    end

    # ------- ctor -----------------------------------------------------
    def initialize(candles:, config: {})
      @candles = candles # Dhan hash-of-arrays

      @cfg = DEFAULTS.merge((config || {}).transform_keys(&:to_sym))

      min_needed = @cfg[:min_candles].to_i.positive? ? @cfg[:min_candles].to_i : DEFAULTS[:min_candles]
      raise ArgumentError, "need ‚â• #{min_needed} candles" if closes.size < min_needed
    end

    # ------- main -----------------------------------------------------
    def call
      # read lengths from cfg (still default to the original)
      ema_fast = @cfg[:ema_fast]
      ema_slow = @cfg[:ema_slow]
      rsi_len  = @cfg[:rsi_len]
      adx_len  = @cfg[:adx_len]
      atr_len  = @cfg[:atr_len]

      sma50  = sma(ema_fast)
      ema200 = ema(ema_slow)
      rsi14  = rsi(rsi_len)
      macd_h = macd_hash
      adx14  = adx(adx_len)
      atr14  = atr(atr_len)

      # bias on MA alignment
      bias =
        if    sma50 > ema200 then :bullish
        elsif sma50 < ema200 then :bearish
        else
          :neutral
        end

      # momentum on MACD+RSI, but use cfg bands now
      rsi_up_min   = @cfg[:rsi_up_min].to_f
      rsi_down_max = @cfg[:rsi_down_max].to_f

      momentum =
        if macd_h[:macd] > macd_h[:signal] && rsi14 >= rsi_up_min
          :up
        elsif macd_h[:macd] < macd_h[:signal] && rsi14 <= rsi_down_max
          :down
        else
          :flat
        end

      # proceed gate with configurable ADX
      adx_gate = @cfg[:adx_gate].to_f

      proceed =
        case bias
        when :bullish
          passed = adx14 >= adx_gate && momentum == :up
          Rails.logger.debug { "[HolyGrail] Not proceeding (bullish): adx=#{adx14} gate=#{adx_gate}, momentum=#{momentum}" } unless passed
          passed
        when :bearish
          passed = adx14 >= adx_gate && momentum == :down
          Rails.logger.debug { "[HolyGrail] Not proceeding (bearish): adx=#{adx14} gate=#{adx_gate}, momentum=#{momentum}" } unless passed
          passed
        else
          Rails.logger.debug { "[HolyGrail] Not proceeding (#{bias}): neutral bias, adx=#{adx14}, momentum=#{momentum}, gate=#{adx_gate}" }
          false
        end

      latest_time = Time.zone.at(stamps.last)
      Rails.logger.debug { "[HolyGrail] (#{latest_time}) proceed?=#{proceed}" }

      trend =
        if ema200 < closes.last && sma50 > ema200 then :up
        elsif ema200 > closes.last && sma50 < ema200 then :down
        else
          :side
        end

      Result.new(
        bias:, adx: adx14, momentum:, proceed?: proceed,
        sma50:, ema200:, rsi14:, atr14:, macd: macd_h, trend:
      )
    end

    private

    def closes = @candles['close'].map(&:to_f)
    def highs  = @candles['high'].map(&:to_f)
    def lows   = @candles['low'].map(&:to_f)
    def stamps = @candles['timestamp'] || []

    def ohlc_rows
      @ohlc_rows ||= highs.each_index.map do |i|
        {
          date_time: Time.zone.at(stamps[i] || 0),
          high: highs[i],
          low: lows[i],
          close: closes[i]
        }
      end
    end

    # ‚Äî ruby-technical-analysis ‚Äî
    def sma(len) = closes.last(len).sum / len.to_f
    def ema(len) = RTA::MovingAverages.new(series: closes, period: len).ema
    def rsi(len) = RTA::RelativeStrengthIndex.new(series: closes, period: len).call

    def macd_hash
      m, s, h = RTA::Macd.new(series: closes,
                              fast_period: @cfg[:macd_f],
                              slow_period: @cfg[:macd_s],
                              signal_period: @cfg[:macd_sig]).call
      { macd: m, signal: s, hist: h }
    end

    # ‚Äî technical_analysis gem ‚Äî
    def atr(len)
      TA::Atr.calculate(ohlc_rows.last(len * 2), period: len).first.atr
    end

    def adx(len)
      TA::Adx.calculate(ohlc_rows.last(len * 2), period: len).first.adx
    end
  end
end


# File: app/services/indicators/supertrend.rb
module Indicators
  class Supertrend < ApplicationService
    attr_reader :series, :period, :multiplier, :supertrend_values, :candles

    def initialize(series:, period: 10, multiplier: 3.0)
      @series = series
      @candles = series.candles
      @period = period
      @multiplier = multiplier
      @supertrend_values = []
    end

    def call
      atr = calculate_atr
      return [] if atr.empty?

      supertrend = []
      trend = [] # :bullish or :bearish

      candles.each_with_index do |candle, i|
        next if i < period

        hl2 = (candle.high + candle.low) / 2.0
        upper_band = hl2 + (multiplier * atr[i])
        lower_band = hl2 - (multiplier * atr[i])

        if i == period
          supertrend[i] = upper_band
          trend[i] = :bearish
        else
          prev_close = candles[i - 1].close
          prev_supertrend = supertrend[i - 1]

          if prev_close <= supertrend[i - 1]
            supertrend[i] = [upper_band, prev_supertrend].min
            trend[i] = candle.close <= supertrend[i] ? :bearish : :bullish
          else
            supertrend[i] = [lower_band, prev_supertrend].max
            trend[i] = candle.close >= supertrend[i] ? :bullish : :bearish
          end
        end

        supertrend_values[i] = supertrend[i]
      end

      supertrend_values
    end

    private

    def calculate_atr
      tr = []
      atr = []

      candles.each_with_index do |candle, i|
        if i.zero?
          tr[i] = candle.high - candle.low
        else
          prev_close = candles[i - 1].close
          tr[i] = [
            candle.high - candle.low,
            (candle.high - prev_close).abs,
            (candle.low - prev_close).abs
          ].max
        end
      end

      # Simple Moving Average for ATR
      (0...candles.size).each do |i|
        atr[i] = if i < period
                   nil
                 else
                   tr[(i - period + 1)..i].compact.sum / period
                 end
      end

      atr
    end
  end
end


# File: app/services/instruments_importer.rb
# app/services/instruments_importer.rb
# frozen_string_literal: true

require 'csv'
require 'open-uri'

class InstrumentsImporter
  CSV_URL         = 'https://images.dhan.co/api-data/api-scrip-master-detailed.csv'
  CACHE_PATH      = Rails.root.join('tmp/dhan_scrip_master.csv') # ‚Üê NEW
  CACHE_MAX_AGE   = 24.hours # ‚Üê NEW
  VALID_EXCHANGES = %w[NSE BSE].freeze
  BATCH_SIZE      = 1_000

  class << self
    # ------------------------------------------------------------
    # Public entry point
    # ------------------------------------------------------------
    def import_from_url
      csv_text = fetch_csv_with_cache # ‚Üê NEW (was: URI.open(CSV_URL).read)
      import_from_csv(csv_text)
    end

    # ------------------------------------------------------------
    # Fetch CSV with 24-hour cache
    # ------------------------------------------------------------
    # ‚Üê NEW helper
    def fetch_csv_with_cache
      if CACHE_PATH.exist? && Time.current - CACHE_PATH.mtime < CACHE_MAX_AGE
        Rails.logger.info "Using cached CSV (#{CACHE_PATH})"
        return CACHE_PATH.read
      end

      Rails.logger.info 'Downloading fresh CSV from Dhan‚Ä¶'
      csv_text = URI.open(CSV_URL).read

      CACHE_PATH.dirname.mkpath
      File.write(CACHE_PATH, csv_text)
      Rails.logger.info "Saved CSV to #{CACHE_PATH}"

      csv_text
    rescue StandardError => e
      Rails.logger.warn "CSV download failed: #{e.message}"
      raise e if CACHE_PATH.exist? == false   # don‚Äôt swallow if no fallback

      Rails.logger.warn 'Falling back to cached CSV (may be stale)'
      CACHE_PATH.read
    end
    private :fetch_csv_with_cache             # keep helper private

    def import_from_csv(csv_content)
      instruments_rows, derivatives_rows = build_batches(csv_content)
      Rails.logger.debug instruments_rows.size, derivatives_rows.size
      # instruments_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }
      # derivatives_rows.uniq!  { |r| r.values_at(:security_id, :symbol_name, :exchange, :segment) }

      import_instruments!(instruments_rows)  unless instruments_rows.empty?
      import_derivatives!(derivatives_rows)  unless derivatives_rows.empty?
    end

    private

    # ------------------------------------------------------------
    # 1. Split CSV rows
    # ------------------------------------------------------------
    def build_batches(csv_content)
      instruments = []
      derivatives = []

      CSV.parse(csv_content, headers: true).each do |row|
        next unless VALID_EXCHANGES.include?(row['EXCH_ID'])

        attrs = build_attrs(row)

        if row['SEGMENT'] == 'D'   # Derivative
          derivatives << attrs.slice(*Derivative.column_names.map(&:to_sym))
        else                       # Cash / Index
          instruments << attrs.slice(*Instrument.column_names.map(&:to_sym))
        end
      end

      [instruments, derivatives]
    end

    def build_attrs(row)
      now = Time.zone.now
      {
        security_id: row['SECURITY_ID'],
        exchange: row['EXCH_ID'],
        segment: row['SEGMENT'],
        isin: row['ISIN'],
        instrument_code: row['INSTRUMENT'],
        underlying_security_id: row['UNDERLYING_SECURITY_ID'],
        underlying_symbol: row['UNDERLYING_SYMBOL'],
        symbol_name: row['SYMBOL_NAME'],
        display_name: row['DISPLAY_NAME'],
        instrument_type: row['INSTRUMENT_TYPE'],
        series: row['SERIES'],
        lot_size: row['LOT_SIZE']&.to_i,
        expiry_date: safe_date(row['SM_EXPIRY_DATE']),
        strike_price: row['STRIKE_PRICE']&.to_f,
        option_type: row['OPTION_TYPE'],
        tick_size: row['TICK_SIZE']&.to_f,
        expiry_flag: row['EXPIRY_FLAG'],
        bracket_flag: row['BRACKET_FLAG'],
        cover_flag: row['COVER_FLAG'],
        asm_gsm_flag: row['ASM_GSM_FLAG'],
        asm_gsm_category: row['ASM_GSM_CATEGORY'],
        buy_sell_indicator: row['BUY_SELL_INDICATOR'],
        buy_co_min_margin_per: row['BUY_CO_MIN_MARGIN_PER']&.to_f,
        sell_co_min_margin_per: row['SELL_CO_MIN_MARGIN_PER']&.to_f,
        buy_co_sl_range_max_perc: row['BUY_CO_SL_RANGE_MAX_PERC']&.to_f,
        sell_co_sl_range_max_perc: row['SELL_CO_SL_RANGE_MAX_PERC']&.to_f,
        buy_co_sl_range_min_perc: row['BUY_CO_SL_RANGE_MIN_PERC']&.to_f,
        sell_co_sl_range_min_perc: row['SELL_CO_SL_RANGE_MIN_PERC']&.to_f,
        buy_bo_min_margin_per: row['BUY_BO_MIN_MARGIN_PER']&.to_f,
        sell_bo_min_margin_per: row['SELL_BO_MIN_MARGIN_PER']&.to_f,
        buy_bo_sl_range_max_perc: row['BUY_BO_SL_RANGE_MAX_PERC']&.to_f,
        sell_bo_sl_range_max_perc: row['SELL_BO_SL_RANGE_MAX_PERC']&.to_f,
        buy_bo_sl_range_min_perc: row['BUY_BO_SL_RANGE_MIN_PERC']&.to_f,
        sell_bo_sl_min_range: row['SELL_BO_SL_MIN_RANGE']&.to_f,
        buy_bo_profit_range_max_perc: row['BUY_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        sell_bo_profit_range_max_perc: row['SELL_BO_PROFIT_RANGE_MAX_PERC']&.to_f,
        buy_bo_profit_range_min_perc: row['BUY_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        sell_bo_profit_range_min_perc: row['SELL_BO_PROFIT_RANGE_MIN_PERC']&.to_f,
        mtf_leverage: row['MTF_LEVERAGE']&.to_f,
        created_at: now,
        updated_at: now
      }
    end

    # ------------------------------------------------------------
    # 3. Upsert instruments
    # ------------------------------------------------------------
    def import_instruments!(rows)
      res = Instrument.import(
        rows,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            display_name isin instrument_code instrument_type
            underlying_symbol lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Instruments: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4. Upsert derivatives
    # ------------------------------------------------------------
    def import_derivatives!(rows)
      with_parent, without_parent = attach_instrument_ids(rows)

      Rails.logger.info "Derivatives w/ parent: #{with_parent.size}"
      Rails.logger.info "Derivatives w/o parent: #{without_parent.size}"

      return if with_parent.empty?

      res = Derivative.import(
        with_parent,
        batch_size: BATCH_SIZE,
        on_duplicate_key_update: {
          conflict_target: %i[security_id symbol_name exchange segment],
          columns: %i[
            symbol_name display_name isin instrument_code instrument_type
            underlying_symbol series lot_size tick_size updated_at
          ]
        }
      )
      Rails.logger.info "Upserted Derivatives: #{res.ids.size}"
    end

    # ------------------------------------------------------------
    # 4a. Attach instrument_id to each derivative row
    # ------------------------------------------------------------
    def attach_instrument_ids(rows)
      enum_to_csv = Instrument.instrument_codes

      # üîë lookup key = [csv_code, UNDERLYING_SYMBOL]
      lookup = Instrument.pluck(
        :id, :instrument_code, :underlying_symbol, :exchange, :segment
      ).each_with_object({}) do |(id, enum_code, sym, _exch, _seg), h|
        next if sym.blank?

        csv_code = enum_to_csv[enum_code] || enum_code # keep CSV code itself
        key      = [csv_code, sym.upcase]
        h[key]   = id
      end

      Rails.logger.debug { "lookup size: #{lookup.size}" }

      with_parent    = []
      without_parent = []
      count = 0
      rows.each do |h|
        count += 1 if h[:underlying_symbol]
        next without_parent << h if h[:underlying_symbol].blank?

        parent_code = InstrumentTypeMapping.underlying_for(h[:instrument_code]) # FUTIDX ‚ûú INDEX
        key         = [parent_code, h[:underlying_symbol].upcase]

        if (pid = lookup[key])
          h[:instrument_id] = pid
          with_parent << h
        else
          without_parent << h
        end
      end

      [with_parent, without_parent]
    end

    # ------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------
    def safe_date(str)
      Date.parse(str)
    rescue StandardError
      nil
    end

    def map_segment(char)
      { 'I' => 'index', 'E' => 'equity', 'C' => 'currency',
        'D' => 'derivatives', 'M' => 'commodity' }[char] || char.downcase
    end
  end
end

# File: app/services/live/quote.rb
# frozen_string_literal: true

module Live
  class Quote
    # Returns { ltp:, bid:, ask:, ts: } using TickCache first; depth API fallback.
    def self.get(exchange_segment, security_id)
      # 1) WebSocket tick if we have it
      tick = begin
        Live::TickCache.get(exchange_segment, security_id)
      rescue StandardError
        nil
      end
      if tick
        bid = (tick[:best_bid_price] || tick[:bid]).to_f
        ask = (tick[:best_ask_price] || tick[:ask]).to_f
        ltp = (tick[:ltp] || tick[:last_price]).to_f
        return { ltp: ltp, bid: bid, ask: ask, ts: Time.zone.now } if ltp.positive?
      end

      # 2) REST quote fallback
      depth = begin
        DhanHQ::Models::MarketFeed.depth(exchange_segment: exchange_segment, security_id: security_id)
      rescue StandardError
        nil
      end
      if depth
        best_bid = Array(depth[:bids]).first&.dig(:price).to_f
        best_ask = Array(depth[:asks]).first&.dig(:price).to_f
        ltp      = depth[:last_traded_price].to_f.nonzero? || depth[:ltp].to_f
        return { ltp: ltp, bid: best_bid, ask: best_ask, ts: Time.zone.now }
      end

      # 3) as a last resort ‚Äî plain LTP
      ltp = begin
        Dhanhq::API::Quote.ltp(security_id)
      rescue StandardError
        nil
      end
      return { ltp: ltp.to_f, bid: nil, ask: nil, ts: Time.zone.now } if ltp

      nil
    end
  end
end


# File: app/services/live/tick_cache.rb
# frozen_string_literal: true

require 'concurrent'

module Live
  class TickCache
    MAP = Concurrent::Map.new

    def self.put(t)
      MAP["#{t[:segment]}:#{t[:security_id]}"] = t
    end

    def self.get(segment, security_id)
      MAP["#{segment}:#{security_id}"]
    end

    def self.ltp(segment, security_id)
      MAP["#{segment}:#{security_id}"]&.dig(:ltp)
    end

    def self.clear
      MAP.clear
    end
  end
end


# File: app/services/live/ws_hub.rb
# frozen_string_literal: true

require 'singleton'
require 'concurrent'

module Live
  class WsHub
    include Singleton

    def initialize
      @running  = Concurrent::AtomicBoolean.new(false)
      @client   = nil
      @subs     = Concurrent::Set.new # "SEG:SID"
      @handlers = Concurrent::Array.new
    end

    def start!(mode: :quote)
      return self if @running.true?

      @client = DhanHQ::WS::Client.new(mode: mode).start
      @client.on(:tick) { |t| handle_tick(t) }
      @running.make_true
      self
    end

    def stop!
      return self unless @running.true?

      @running.make_false
      @client&.disconnect! # graceful + no reconnect
      @client = nil
      self
    end

    # Subscribe single instrument (idempotent)
    def subscribe(seg:, sid:)
      key = k(seg, sid)
      return self if @subs.include?(key)

      @subs.add(key)
      @client&.subscribe_one(segment: seg, security_id: sid)
      self
    end

    # Unsubscribe (if you want to shrink the stream)
    def unsubscribe(seg:, sid:)
      key = k(seg, sid)
      return self unless @subs.include?(key)

      @subs.delete(key)
      @client&.unsubscribe_one(segment: seg, security_id: sid)
      self
    end

    # Convenient multi-subscribe
    def subscribe_many(list)
      list.each { |h| subscribe(seg: h[:segment] || h['segment'], sid: h[:security_id] || h['security_id']) }
      self
    end

    # Register per-app tick listener (non-blocking please)
    def on_tick(&blk)
      @handlers << blk
      self
    end

    # Subscribe all currently-open positions (call on boot if desired)
    def subscribe_from_open_positions!
      Position.where(status: %w[OPEN ACTIVE LIVE]).pluck(:exchange_segment, :security_id).each do |seg, sid|
        subscribe(seg: seg, sid: sid.to_s)
      end
      self
    end

    private

    def handle_tick(t)
      TickCache.put(t) # global last-known tick
      begin
        ActiveSupport::Notifications.instrument('tick.dhanhq', tick: t)
      rescue StandardError
        nil
      end
      # Local handlers
      @handlers.each do |h|
        h.call(t)
      rescue StandardError
        nil
      end
    end

    def k(seg, sid) = "#{seg}:#{sid}"
  end
end


# File: app/services/market_calendar.rb
module MarketCalendar
  MARKET_HOLIDAYS = [
    # Add static or API-fetched holiday dates here
    Date.new(2025, 8, 15)
    # ...
  ]

  def self.trading_day?(date)
    weekday = date.on_weekday?
    !MARKET_HOLIDAYS.include?(date) && weekday
  end

  def self.last_trading_day(from: Time.zone.today)
    date = from
    date -= 1 until trading_day?(date)
    date
  end

  def self.today_or_last_trading_day
    trading_day?(Time.zone.today) ? Time.zone.today : last_trading_day
  end
end


# File: app/services/mtf/resampler.rb
# frozen_string_literal: true

module Mtf
  class Resampler
    Bucket = Struct.new(:ts, :o, :h, :l, :c, :vol, keyword_init: true)

    # series: CandleSeries on 1m/3m/5m; minutes: 15 / 60 / 240
    def self.to(series, minutes:)
      raise 'series empty' if series.candles.empty?

      step   = minutes * 60
      out    = []
      bucket = nil

      series.candles.each do |bar|
        t = bar.timestamp.to_i
        bt = t - (t % step) # bucket start

        if bucket.nil? || bucket.ts != bt
          out << bucket_to_candle(bucket) if bucket
          bucket = Bucket.new(ts: bt, o: bar.open, h: bar.high, l: bar.low, c: bar.close, vol: bar.volume.to_i)
        else
          bucket.h = [bucket.h, bar.high].max
          bucket.l   = [bucket.l, bar.low].min
          bucket.c   = bar.close
          bucket.vol = bucket.vol.to_i + bar.volume.to_i
        end
      end

      out << bucket_to_candle(bucket) if bucket

      CandleSeries.new(symbol: series.symbol, interval: minutes.to_s).tap do |cs|
        out.each { |c| cs.add_candle(c) }
      end
    end

    def self.bucket_to_candle(b)
      Candle.new(
        ts: Time.at(b.ts).in_time_zone,
        open: b.o,
        high: b.h,
        low: b.l,
        close: b.c,
        volume: b.vol.to_i
      )
    end
  end
end


# File: app/services/mtf/series_loader.rb
# frozen_string_literal: true

module Mtf
  class SeriesLoader
    Result = Struct.new(:m5, :m15, :h1, :h4, keyword_init: true)

    # instrument: your Instrument record
    # base_interval: '5' (we‚Äôll resample to 15/60/240)
    def self.load(instrument:, base_interval: '5')
      raw = instrument.intraday_ohlc(interval: base_interval)
      return nil if raw.blank?

      m5 = CandleSeries.new(symbol: instrument.symbol_name, interval: base_interval)
      m5.load_from_raw(raw)

      m15 = Mtf::Resampler.to(m5, minutes: 15)
      h1  = Mtf::Resampler.to(m5, minutes: 60)
      h4  = Mtf::Resampler.to(m5, minutes: 240)

      Result.new(m5: m5, m15: m15, h1: h1, h4: h4)
    end
  end
end


# File: app/services/openai/behaviour_explainer.rb
module Openai
  class BehaviourExplainer < ApplicationService
    def initialize(analysis_hash)
      @data = analysis_hash
    end

    def call
      prompt = build_prompt
      typing_ping
      completion = OpenAI::Client.new.chat(
        parameters: {
          model: 'gpt-4',
          messages: [
            { role: 'system', content: 'You are an options trading expert' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7
        }
      )
      result = completion.dig('choices', 0, 'message', 'content')
      notify("üìò AI Options Insight for #{@data[:symbol]}:\n\n#{result}", tag: 'AI_EXPLAIN')
      result
    rescue StandardError => e
      notify_failure(e, :openai)
      nil
    end

    def build_prompt
      <<~PROMPT
        Given the following ATM options data for #{@data[:symbol]} (#{@data[:expiry]}), analyze the market sentiment and expected move direction:

        CE:
        ‚Ä¢ Price: #{@data[:ce][:last_price]}
        ‚Ä¢ IV: #{@data[:ce][:iv]}
        ‚Ä¢ Œî: #{@data[:ce][:delta]}
        ‚Ä¢ Œ∏: #{@data[:ce][:theta]}
        ‚Ä¢ OI: #{@data[:ce][:oi]}
        ‚Ä¢ Price Change: #{@data[:ce][:price_change]}

        PE:
        ‚Ä¢ Price: #{@data[:pe][:last_price]}
        ‚Ä¢ IV: #{@data[:pe][:iv]}
        ‚Ä¢ Œî: #{@data[:pe][:delta]}
        ‚Ä¢ Œ∏: #{@data[:pe][:theta]}
        ‚Ä¢ OI: #{@data[:pe][:oi]}
        ‚Ä¢ Price Change: #{@data[:pe][:price_change]}

        Spot: #{@data[:spot]}
        ATM: #{@data[:atm]}

        Respond with:
        - Sentiment: Bullish / Bearish / Neutral
        - Reasoning
        - Suggested next move for CE or PE buying (if any)
      PROMPT
    end
  end
end

# File: app/services/option/chain_analyzer.rb
# frozen_string_literal: true

module Option
  class ChainAnalyzer
    IV_RANK_MIN        = 0.00
    IV_RANK_MAX        = 0.80
    THETA_AVOID_HOUR   = 14.5 # 2:30 PM
    TOP_RANKED_LIMIT   = 10
    MIN_ADX            = 20

    attr_reader :option_chain, :expiry, :underlying_spot, :historical_data, :iv_rank, :ta, :cfg

    def initialize(option_chain, expiry:, underlying_spot:, iv_rank:, historical_data: [], config: Option::ChainConfig.current)
      @cfg = config
      @option_chain     = option_chain.with_indifferent_access
      @expiry           = Date.parse(expiry.to_s)
      @underlying_spot  = underlying_spot.to_f
      @iv_rank          = iv_rank.to_f
      @historical_data  = historical_data || []
      @ta = (Indicators::HolyGrail.call(candles: historical_data) if historical_data.present?)

      Rails.logger.debug { "[Option::ChainAnalyzer] Analyzing Options for #{expiry}" }
      raise ArgumentError, 'Option Chain is missing or empty!' if @option_chain[:oc].blank?
    end

    # Main entry
    def analyze(signal_type:, strategy_type:, signal_strength: 1.0)
      result = {
        proceed: true,
        reason: nil,
        signal_type: signal_type, # :ce / :pe
        trend: nil,
        momentum: nil,
        adx: nil,
        selected: nil,
        ranked: [],
        ta_snapshot: ta ? ta.to_h : {}
      }

      # 1) Core sanity gates
      if iv_rank_outside_range?
        result[:proceed] = false
        result[:reason]  = 'IV rank outside range'
      elsif discourage_late_entry_due_to_theta?
        result[:proceed] = false
        result[:reason]  = 'Late entry, theta risk'
      end

      # 2) Bias / momentum / ADX (HolyGrail if available)
      result[:trend]    = ta ? ta.bias.to_sym     : intraday_trend
      result[:momentum] = ta ? ta.momentum.to_sym : :flat
      result[:adx]      = ta&.adx
      adx_ok            = ta ? ta.adx.to_f >= MIN_ADX : true

      if result[:proceed] && !(trend_confirms?(result[:trend], signal_type) && adx_ok && result[:momentum] != :flat)
        result[:proceed] = false
        result[:reason]  = 'trend/momentum filter'
      end

      # 3) Candidate strikes ‚Üí score ‚Üí rank
      if result[:proceed]
        filtered = gather_filtered_strikes(signal_type)
        if filtered.empty?
          result[:proceed] = false
          result[:reason]  = 'No tradable strikes found'
        else
          m_boost = (result[:momentum] == :strong ? 1.15 : 1.0)
          ranked  = filtered.map do |opt|
            score = score_for(opt, strategy_type, signal_type, signal_strength) * m_boost
            opt.merge(score: score)
          end.sort_by { |o| -o[:score] }

          result[:ranked]   = ranked.first(TOP_RANKED_LIMIT)
          result[:selected] = result[:ranked].first
        end
      end

      result
    end

    # Public helper
    def current_trend = intraday_trend
    alias trend current_trend

    private

    def iv_rank_outside_range?
      @iv_rank < IV_RANK_MIN || @iv_rank > IV_RANK_MAX
    end

    def gather_filtered_strikes(signal_type)
      side = signal_type.to_sym # :ce / :pe

      @option_chain[:oc].filter_map do |strike_str, row|
        opt = row[side.to_s]
        next unless opt

        # Must have price + IV
        next if opt['implied_volatility'].to_f.zero? || opt['last_price'].to_f.zero?

        strike_price = strike_str.to_f
        delta_abs    = opt.dig('greeks', 'delta').to_f.abs

        # Min Œî gates (time‚Äëof‚Äëday)
        next if delta_abs < min_delta_now

        # Adaptive ATM window
        next unless within_atm_range?(strike_price)

        build_strike_data(strike_price, opt)
      end
    end

    # Dynamic Œî thresholds
    def min_delta_now
      h = Time.zone.now.hour
      return 0.45 if h >= 14
      return 0.35 if h >= 13
      return 0.30 if h >= 11

      0.25
    end

    # Adaptive ATM window by IV rank
    def atm_range_pct
      case iv_rank
      when 0.0..0.2 then 0.01
      when 0.2..0.5 then 0.015
      else               0.025
      end
    end

    def within_atm_range?(strike)
      band = atm_range_pct
      lo   = @underlying_spot * (1 - band)
      hi   = @underlying_spot * (1 + band)
      strike.between?(lo, hi)
    end

    def build_strike_data(strike_price, opt)
      {
        strike_price: strike_price,
        last_price: opt['last_price'].to_f,
        iv: opt['implied_volatility'].to_f,
        oi: opt['oi'].to_i,
        volume: opt['volume'].to_i,
        greeks: {
          delta: opt.dig('greeks', 'delta').to_f,
          gamma: opt.dig('greeks', 'gamma').to_f,
          theta: opt.dig('greeks', 'theta').to_f,
          vega: opt.dig('greeks', 'vega').to_f
        },
        previous_close_price: opt['previous_close_price'].to_f,
        previous_oi: opt['previous_oi'].to_i,
        previous_volume: opt['previous_volume'].to_i,
        price_change: opt['last_price'].to_f - opt['previous_close_price'].to_f,
        oi_change: opt['oi'].to_i - opt['previous_oi'].to_i,
        volume_change: opt['volume'].to_i - opt['previous_volume'].to_i,
        bid_ask_spread: (opt['top_ask_price'].to_f - opt['top_bid_price'].to_f).abs
      }
    end

    def score_for(opt, strategy, signal_type, signal_strength)
      spread          = opt[:bid_ask_spread] <= 0 ? 0.1 : opt[:bid_ask_spread]
      last_price      = opt[:last_price].to_f
      relative_spread = spread / (last_price.nonzero? || 1.0)

      oi        = [opt[:oi], 1].max
      volume    = [opt[:volume], 1].max
      delta     = opt[:greeks][:delta].abs
      gamma     = opt[:greeks][:gamma]
      theta     = opt[:greeks][:theta]
      vega      = opt[:greeks][:vega]
      price_chg = opt[:price_change]
      oi_chg    = opt[:oi_change]
      vol_chg   = opt[:volume_change]

      # weights: intraday vs swing
      lw, mw, = (strategy.to_s == 'intraday' ? [0.35, 0.35, 0.3] : [0.25, 0.25, 0.5])

      # Liquidity (penalize wide spreads)
      liquidity_score = ((oi * volume) + vol_chg.abs) / (relative_spread.nonzero? || 0.01)

      # Flow/momentum
      momentum_score  = (oi_chg / 1000.0)
      momentum_score += price_chg.positive? ? price_chg : price_chg.abs if delta >= 0 && price_chg.positive?

      # Theta pressure ‚Üë near expiry
      days_left     = (@expiry - Time.zone.today).to_i
      theta_penalty = theta.abs * (days_left < 3 ? 2.0 : 1.0)
      greeks_score  = (delta * 100) + (gamma * 10) + (vega * 2) - (theta_penalty * 3)

      # Price efficiency
      efficiency = last_price.zero? ? 0.0 : (price_chg / last_price)
      efficiency_score = efficiency * 30

      total = (liquidity_score * lw) +
              (momentum_score  * mw) +
              (greeks_score    * theta_weight) +
              efficiency_score

      # Skew checks
      z = local_iv_zscore(opt[:iv], opt[:strike_price])
      total *= 0.90 if z > 1.5

      tilt = skew_tilt
      total *= 1.10 if (signal_type == :ce && tilt == :call) || (signal_type == :pe && tilt == :put)

      # Historical IV sanity
      hist_vol = historical_volatility
      if hist_vol.positive?
        iv_ratio = opt[:iv] / hist_vol
        total *= 0.9 if iv_ratio > 1.5
      end

      total * signal_strength
    end

    def theta_weight
      Time.zone.now.hour >= 13 ? 4.0 : 3.0
    end

    def local_iv_zscore(strike_iv, strike)
      neighbours = @option_chain[:oc].keys.map(&:to_f).select { |s| (s - strike).abs <= 300 }
      ivs = neighbours.filter_map do |s|
        node = @option_chain[:oc][format('%.6f', s)]
        (node && node['ce'] && node['ce']['implied_volatility']).to_f
      end
      return 0 if ivs.empty?

      mean = ivs.sum / ivs.size
      var  = ivs.sum { |v| (v - mean)**2 } / ivs.size
      std  = Math.sqrt(var)
      std.zero? ? 0 : (strike_iv - mean) / std
    end

    def skew_tilt
      ce_ivs = collect_side_ivs(:ce)
      pe_ivs = collect_side_ivs(:pe)
      avg_ce = ce_ivs.any? ? ce_ivs.sum / ce_ivs.size.to_f : nil
      avg_pe = pe_ivs.any? ? pe_ivs.sum / pe_ivs.size.to_f : nil

      return :call if avg_ce && avg_pe && avg_ce > avg_pe * 1.1
      return :put  if avg_pe && avg_ce && avg_pe > avg_ce * 1.1

      :neutral
    end

    def collect_side_ivs(side)
      @option_chain[:oc].values.filter_map do |row|
        v = row.dig(side.to_s, 'implied_volatility')
        v.to_f if v && v.to_f > 0
      end
    end

    # simple HV (annualized %)
    def historical_volatility
      return 0 if @historical_data.blank?

      closes = @historical_data['close'] || []
      return 0 if closes.size < 10

      rets = []
      closes.each_cons(2) do |a, b|
        rets << Math.log(b.to_f / a.to_f)
      rescue StandardError
        rets << 0
      end
      mean = rets.sum / (rets.size.nonzero? || 1)
      var  = rets.sum { |r| (r - mean)**2 } / (rets.size.nonzero? || 1)
      Math.sqrt(var) * Math.sqrt(252) * 100.0
    end

    # Flow bias from CE vs PE change around ATM
    def intraday_trend
      atm = determine_atm_strike
      return :neutral unless atm

      window  = 3
      sums    = { ce: 0.0, pe: 0.0 }
      strikes = @option_chain[:oc].keys.map(&:to_f)
      strikes.select { |s| (s - atm).abs <= (window * 100) }.each do |s|
        key = format('%.6f', s)
        %i[ce pe].each do |side|
          opt = @option_chain[:oc].dig(key, side.to_s)
          next unless opt

          change = opt['last_price'].to_f - opt['previous_close_price'].to_f
          sums[side] += change
        end
      end
      diff = sums[:ce] - sums[:pe]
      return :bullish if diff.positive?
      return :bearish if diff.negative?

      :neutral
    end

    def trend_confirms?(trend, signal_type)
      return true if trend == :neutral

      (trend == :bullish && signal_type == :ce) || (trend == :bearish && signal_type == :pe)
    end

    def discourage_late_entry_due_to_theta?
      now           = Time.zone.now
      expiry_today  = (@expiry == now.to_date)
      current_hours = now.hour + (now.min / 60.0)
      expiry_today && current_hours > THETA_AVOID_HOUR
    end

    def determine_atm_strike
      strikes = @option_chain[:oc].keys.map(&:to_f)
      return nil if strikes.empty?

      strikes.min_by { |s| (s - @underlying_spot).abs }
    end
  end
end


# File: app/services/option/chain_config.rb
# frozen_string_literal: true

module Option
  class ChainConfig
    class << self
      def current = new

      # ------------- gates -------------
      def iv_rank_min        = Setting.fetch_f('opt.iv_rank_min', 0.00)
      def iv_rank_max        = Setting.fetch_f('opt.iv_rank_max', 0.80)
      def theta_avoid_hour   = Setting.fetch_f('opt.theta_avoid_hour', 14.5) # 2:30pm
      def min_adx            = Setting.fetch_f('opt.min_adx', 25.0)

      # ------------- ranking -----------
      def top_ranked_limit   = Setting.fetch_i('opt.top_ranked_limit', 10)
      def efficiency_weight  = Setting.fetch_f('opt.efficiency_weight', 30.0)

      # ------------- Œî thresholds by hour -----------
      # Hours are 24h integer keys; value = min |Œî|
      def min_delta_by_hour
        json = Setting.fetch('opt.min_delta_by_hour_json', nil)
        (json ? JSON.parse(json) : { '11' => 0.30, '13' => 0.35, '14' => 0.45, 'else' => 0.25 })
          .transform_keys!(&:to_s)
      rescue StandardError
        { '11' => 0.30, '13' => 0.35, '14' => 0.45, 'else' => 0.25 }
      end

      # ------------- ATM band by IV rank -----------
      # Each tuple: [max_iv_rank, pct_band]
      def atm_bands
        json = Setting.fetch('opt.atm_bands_json', nil)
        json ? JSON.parse(json) : [[0.20, 0.010], [0.50, 0.015], [1.00, 0.025]]
      rescue StandardError
        [[0.20, 0.010], [0.50, 0.015], [1.00, 0.025]]
      end

      # ------------- scoring knobs -----------
      def lw_intraday = Setting.fetch_f('opt.liquidity_weight_intraday', 0.35)
      def mw_intraday = Setting.fetch_f('opt.momentum_weight_intraday', 0.35)
      def gw_intraday = Setting.fetch_f('opt.greeks_weight_intraday',   0.30)

      def lw_swing    = Setting.fetch_f('opt.liquidity_weight_swing',   0.25)
      def mw_swing    = Setting.fetch_f('opt.momentum_weight_swing',    0.25)
      def gw_swing    = Setting.fetch_f('opt.greeks_weight_swing',      0.50)

      def theta_weight_before_13 = Setting.fetch_f('opt.theta_weight_before_13', 3.0)
      def theta_weight_after_13  = Setting.fetch_f('opt.theta_weight_after_13',  4.0)
      def theta_penalty_days     = Setting.fetch_i('opt.theta_penalty_days', 3)
      def theta_penalty_mult     = Setting.fetch_f('opt.theta_penalty_mult', 2.0)

      def momentum_strong_boost  = Setting.fetch_f('opt.momentum_strong_boost', 1.15)

      # IV skew / z‚Äëscore adjustments
      def zscore_penalize_above  = Setting.fetch_f('opt.zscore_penalize_above', 1.5)
      def zscore_factor          = Setting.fetch_f('opt.zscore_factor', 0.90)
      def skew_tilt_boost        = Setting.fetch_f('opt.skew_tilt_boost', 1.10)

      # IV vs HV sanity
      def iv_hv_ratio_cap        = Setting.fetch_f('opt.iv_hv_ratio_cap', 1.5)
      def iv_hv_ratio_factor     = Setting.fetch_f('opt.iv_hv_ratio_factor', 0.90)

      # Misc
      def atm_window_strikes     = Setting.fetch_i('opt.atm_window_strikes', 3)
    end
  end
end


# File: app/services/options/chain_analyzer.rb
# frozen_string_literal: true

module Options
  # Backcompat facade: delegates selection to Derivatives::Picker (which uses
  # Option::ChainAnalyzer under the hood) and returns the old "legacy row" hash.
  class ChainAnalyzer < ApplicationService
    def initialize(underlying:, side:, config: {})
      @ul     = underlying
      @side   = side.to_s.downcase.to_sym # :ce / :pe
      @config = { strategy_type: 'intraday' }.merge(config || {})
    end

    def call
      pick = Derivatives::Picker.call(
        instrument: @ul,
        side: @side,
        strategy_type: @config[:strategy_type]
      )

      return nil unless pick&.selected && pick.derivative

      # Re-fetch chain for the chosen expiry to extract bid/ask exactly like before
      chain = safe_fetch_option_chain(@ul, pick.expiry)
      return nil if chain.blank? || chain[:oc].blank?

      leg = to_legacy_row(@ul, chain, pick.selected, pick.expiry, pick.side)
      return nil unless leg && leg[:ltp].to_f.positive?

      leg
    rescue StandardError => e
      Rails.logger.error("[Options::ChainAnalyzer] #{e.class} #{e.message}")
      nil
    end

    private

    def safe_fetch_option_chain(inst, expiry)
      inst.fetch_option_chain(expiry)
    rescue StandardError => e
      Rails.logger.error("[Options::ChainAnalyzer] option-chain fetch failed (#{expiry}): #{e.message}")
      nil
    end

    # unchanged: exactly your previous mapper, so legacy consumers get the same shape/fields
    def to_legacy_row(inst, chain, sel, expiry, side)
      strike_f = sel[:strike_price].to_f
      strike_key = format('%.6f', strike_f)
      side_s     = side.to_s

      node      = chain[:oc][strike_key]
      side_node = node && node[side_s]
      return nil unless side_node

      derivative = inst.derivatives.find_by(
        strike_price: strike_f,
        expiry_date: expiry,
        option_type: side.to_s.upcase
      )
      return nil unless derivative

      bid     = side_node['top_bid_price'].to_f
      ask     = side_node['top_ask_price'].to_f
      mid     = [(bid + ask) / 2.0, sel[:last_price].to_f].compact.max
      spread  = ask.positive? && bid.positive? ? (ask - bid).abs : nil
      spread_pct = mid.positive? && spread ? ((spread / mid) * 100.0) : nil

      {
        security_id: derivative.security_id,
        symbol: derivative.symbol_name || inst.symbol_name,
        cp: side.to_s.upcase.to_sym, # :CE / :PE
        strike: strike_f,
        ltp: sel[:last_price].to_f,
        bid: bid,
        ask: ask,
        spread_pct: (spread_pct && spread_pct.round(3)) || 999.0,
        volume: sel[:volume].to_i,
        oi: sel[:oi].to_i,
        iv: sel[:iv].to_f,
        lot_size: derivative.lot_size || inst.lot_size,
        exchange_segment: derivative.exchange_segment
      }
    end
  end
end


# File: app/services/orders/analyzer.rb
module Orders
  class Analyzer < ApplicationService
    def self.realized_pnl_for(security_id, segment)
      pos = State::PositionCache.get(seg: segment, sid: security_id, prod: 'INTRADAY')
      return 0.0 unless pos

      Pnl::LiveCalculator.for_position(pos)[:unrealized].to_f # close enough until broker confirms
    rescue StandardError
      0.0
    end
  end
end


# File: app/services/orders/closer.rb
# frozen_string_literal: true

module Orders
  class Closer < ApplicationService
    # Accept either a cached order hash or a client_ref
    def initialize(order: nil, client_ref: nil)
      @order_hash = order || (client_ref && State::OrderCache.get(client_ref))
    end

    def call
      return unless @order_hash&.dig(:broker_order_id)

      DhanHQ::Models::SuperOrder.new(order_id: @order_hash[:broker_order_id]).cancel('ENTRY_LEG')
    rescue StandardError => e
      Rails.logger.warn("[Orders::Closer] cancel failed: #{e.class} #{e.message}")
      false
    end
  end
end

# File: app/services/orders/executor.rb
# frozen_string_literal: true

module Orders
  class Executor < ApplicationService
    # instrument: Instrument/Derivative
    # side: "BUY"/"SELL"
    # qty: lots/contracts
    # entry_type: :market / :limit
    # risk_params: { sl_value:, tp_value:, trail_sl_value:, trail_sl_jump: }
    # client_ref: unique idempotency key
    def initialize(instrument:, side:, qty:, entry_type:, risk_params:, client_ref:, entry_price: nil)
      @instrument  = instrument
      @side        = side.to_s.upcase
      @qty         = qty.to_i
      @entry_type  = entry_type.to_sym
      @risk_params = risk_params || {}
      @client_ref  = client_ref
      @entry_price = entry_price
    end

    def call
      guard = Risk::Guard.new
      raise 'Trading disabled' unless guard.trading_enabled?

      PgLocks.with_lock("super:#{@instrument.id}") do
        # 1) Idempotency via cache
        if (existing = State::OrderCache.get(@client_ref))
          return existing
        end

        # 2) Build payload
        params = Orders::SuperParamsBuilder.call(
          instrument: @instrument,
          side: @side,
          qty: @qty,
          entry_type: @entry_type,
          entry_price: @entry_price,
          sl_value: @risk_params[:sl_value],
          tp_value: @risk_params[:tp_value],
          trail_sl_jump: @risk_params[:trail_sl_value],
          client_ref: @client_ref
        )

        pp params
        # 3) Place Super Order (returns model with order_id/order_status)
        so = DhanHQ::Models::SuperOrder.create(params)
        raise 'SuperOrder.create failed' unless so&.order_id

        # 4) Cache order snapshot
        order_hash = {
          client_ref: @client_ref,
          broker_order_id: so.order_id,
          status: so.order_status || 'PENDING',
          side: @side,
          qty: @qty,
          entry_type: @entry_type,
          entry_price: params[:price], # avg price may not be immediate
          stop_loss_price: params[:stop_loss_price],
          target_price: params[:target_price],
          trailing_value: params[:trailing_value],
          trailing_jump: params[:trailing_jump],
          exchange_segment: @instrument.exchange_segment,
          security_id: @instrument.security_id,
          pos_key: State::PositionCache.key(seg: @instrument.exchange_segment,
                                            sid: @instrument.security_id,
                                            prod: 'INTRADAY'),
          ts: Time.zone.now
        }.compact
        State::OrderCache.put!(@client_ref, order_hash)

        # 5) Bump PositionCache (optimistic)
        bump_position_cache!(order_hash)

        order_hash
      end
    end

    private

    def bump_position_cache!(o)
      seg = o[:exchange_segment]
      sid = o[:security_id]
      prod = 'INTRADAY'
      cur = State::PositionCache.get(seg:, sid:, prod:) || {}
      net = cur[:net_qty].to_i + (@side == 'BUY' ? @qty : -@qty)

      State::PositionCache.upsert!(
        seg:, sid:, prod:,
        attrs: cur.merge(
          seg: seg, sid: sid, prod: prod,
          net_qty: net,
          buy_avg: cur[:buy_avg], # leave to broker reconcile
          sell_avg: cur[:sell_avg],
          updated_by: 'Orders::Executor'
        )
      )
    end
  end
end

# File: app/services/orders/manager.rb
# app/services/orders/manager.rb
# frozen_string_literal: true

module Orders
  class Manager < ApplicationService
    # Try to flatten using SuperOrder; fallback to plain MARKET opposite leg
    def self.exit_position!(security_id:, segment:, reason:)
      # 1) If we have a cached super order for this instrument, cancel it.
      order = State::OrderCache.fetch_all.values.find do |o|
        o[:security_id].to_i == security_id.to_i && o[:exchange_segment].to_s == segment.to_s
      end

      if order&.dig(:broker_order_id)
        begin
          ok = DhanHQ::Models::SuperOrder.new(order_id: order[:broker_order_id]).cancel('ENTRY_LEG')
          Rails.logger.info("[Orders::Manager] cancel super #{segment}:#{security_id} => #{ok} (#{reason})")
          return true if ok
        rescue StandardError => e
          Rails.logger.warn("[Orders::Manager] super cancel failed: #{e.class} #{e.message}")
        end
      end

      # 2) Fallback: plain opposite market order
      begin
        side = (infer_side_from_pos(segment:, security_id:) == 'LONG' ? 'SELL' : 'BUY')
        lot  = Derivative.find_by(security_id: security_id)&.lot_size || 1

        DhanHQ::Models::Order.create!(
          transaction_type: side,
          exchange_segment: segment,
          product_type: 'INTRADAY',
          order_type: 'MARKET',
          validity: 'DAY',
          security_id: security_id,
          quantity: lot
        )
        Rails.logger.info("[Orders::Manager] market flatten #{segment}:#{security_id} (#{reason})")
        true
      rescue StandardError => e
        Rails.logger.error("[Orders::Manager] fallback exit failed #{segment}:#{security_id} ‚Äì #{e.class}: #{e.message}")
        false
      end
    end

    def self.infer_side_from_pos(segment:, security_id:)
      pos = State::PositionCache.get(seg: segment, sid: security_id, prod: 'INTRADAY') || {}
      qty = pos[:net_qty].to_i
      qty >= 0 ? 'LONG' : 'SHORT'
    end
  end
end

# File: app/services/orders/super_modifier.rb
# frozen_string_literal: true

module Orders
  class SuperModifier < ApplicationService
    # Accept either a cached order hash or a client_ref
    def initialize(order: nil, client_ref: nil, new_sl_value: nil, new_tp_value: nil, new_trail_sl_value: nil)
      @order_hash = order || (client_ref && State::OrderCache.get(client_ref))
      @client_ref = client_ref || @order_hash&.dig(:client_ref)
      @new_sl     = new_sl_value && PriceMath.round_tick(new_sl_value)
      @new_tp     = new_tp_value && PriceMath.round_tick(new_tp_value)
      @new_trail  = new_trail_sl_value && PriceMath.round_tick(new_trail_sl_value)
    end

    def call
      return unless @order_hash && @order_hash[:broker_order_id]

      payload = {}

      cur_sl    = @order_hash[:stop_loss_price]&.to_f
      cur_tp    = @order_hash[:target_price]&.to_f
      cur_trail = @order_hash[:trailing_value]&.to_f

      payload[:stop_loss_price] = @new_sl   if @new_sl   && cur_sl   && @new_sl >= cur_sl   # tighten only
      payload[:target_price]    = @new_tp   if @new_tp   && cur_tp   && @new_tp <= cur_tp   # nearer only
      payload[:trailing_value]  = @new_trail if @new_trail && (cur_trail.nil? || @new_trail >= cur_trail)

      return if payload.empty?

      ok = DhanHQ::Models::SuperOrder.new(order_id: @order_hash[:broker_order_id]).modify(payload)

      if ok
        # refresh cache
        merged = @order_hash.merge(
          stop_loss_price: payload[:stop_loss_price] || cur_sl,
          target_price: payload[:target_price] || cur_tp,
          trailing_value: payload[:trailing_value] || cur_trail,
          status: 'MODIFIED',
          ts: Time.zone.now
        )
        State::OrderCache.put!(@client_ref, merged)
      end
      ok
    end
  end
end

# File: app/services/orders/super_params_builder.rb
# frozen_string_literal: true

module Orders
  class SuperParamsBuilder
    # Build request body for POST /v2/super/orders
    #
    # Arguments:
    #   instrument:    Instrument/Derivative with #security_id and #exchange_segment
    #   side:          :buy / :sell (or "BUY"/"SELL")
    #   qty:           Integer quantity (lots/shares as per instrument)
    #   entry_type:    :market / :limit
    #   sl_value:      Absolute stop-loss price (premium/price), required
    #   tp_value:      Absolute target price, required
    #   client_ref:    Your idempotency key -> mapped to correlationId
    #
    # Optional:
    #   entry_price:     Limit price (required when entry_type == :limit)
    #   trail_sl_jump:   Trailing jump (absolute price jump)
    #   product_type:    'INTRADAY' | 'CNC' | 'MARGIN' | 'MTF' (default: 'INTRADAY')
    #   validity:        'DAY' (default)
    #   dhan_client_id:  If your gem/config doesn‚Äôt inject it, pass here
    #
    # Returns: Hash with Dhan-compliant keys/casing
    def self.call(
      instrument:,
      side:,
      qty:,
      entry_type:,
      sl_value:,
      tp_value:,
      client_ref:,
      entry_price: nil,
      trail_sl_jump: nil,
      product_type: 'INTRADAY',
      validity: 'DAY',
      dhan_client_id: nil
    )
      # ------------ validations ------------
      raise ArgumentError, 'qty must be positive'            if qty.to_i <= 0
      raise ArgumentError, 'sl_value must be present'        if sl_value.nil?
      raise ArgumentError, 'tp_value must be present'        if tp_value.nil?

      ord_type = entry_type.to_s.upcase # "MARKET" | "LIMIT"
      price    = if ord_type == 'LIMIT'
                   PriceMath.round_tick(entry_price).tap do |p|
                     raise ArgumentError, 'limit order requires valid entry_price' if p.nil? || p <= 0
                   end
                 end

      txn_side = side.to_s.upcase # "BUY" | "SELL"

      # ------------ build payload ------------
      {
        # identifiers / routing
        # correlation_id: client_ref.to_s, # for tracking/idempotency
        transaction_type: txn_side,                           # BUY / SELL
        exchange_segment: instrument.exchange_segment,        # e.g. "NSE_FNO"
        product_type: product_type.to_s.upcase, # INTRADAY / CNC / MARGIN / MTF
        order_type: ord_type, # LIMIT / MARKET
        validity: validity.to_s.upcase, # DAY (required by some setups)

        # instrument + qty
        security_id: instrument.security_id.to_s,
        quantity: qty.to_i,

        # price legs
        price: price, # only for LIMIT (omitted for MARKET)
        target_price: PriceMath.round_tick(tp_value),
        stop_loss_price: PriceMath.round_tick(sl_value),
        trailing_jump: trail_sl_jump && PriceMath.round_tick(trail_sl_jump)
      }.compact
    end
  end
end

# File: app/services/pg_locks.rb
module PgLocks
  def self.with_lock(key)
    lock_id = Zlib.crc32(key.to_s)
    ActiveRecord::Base.connection.execute("SELECT pg_advisory_lock(#{lock_id})")
    yield
  ensure
    ActiveRecord::Base.connection.execute("SELECT pg_advisory_unlock(#{lock_id})")
  end
end

# File: app/services/pnl/live_calculator.rb
module Pnl
  class LiveCalculator
    def self.for_position(pos)
      # pos is a hash from PositionCache
      ltp = Live::TickCache.ltp(pos[:seg], pos[:sid]).to_f
      avg = (pos[:net_qty].to_i >= 0 ? pos[:buy_avg] : pos[:sell_avg]).to_f
      qty = pos[:net_qty].to_i.abs

      # For options, multiply by lot size (lookup from Instrument/Derivative) if you want total ‚Çπ
      lot = pos[:lot_size] || 1
      direction = pos[:net_qty].to_i >= 0 ? +1 : -1
      unreal = (ltp - avg) * qty * lot * direction
      { ltp:, unrealized: unreal.round(2) }
    end
  end
end

# File: app/services/portfolio/sync.rb
module Portfolio
  class Sync < ApplicationService
    def call
      sync_holdings
      sync_positions
    end

    def sync_holdings
      arr = DhanHQ::Models::Holding.all # => array of hashes per API
      Array(arr).each do |h|
        Holding
          .find_or_initialize_by(exchange: h.exchange, security_id: h.security_id)
          .update!(
            trading_symbol: h.trading_symbol,
            isin: h.isin,
            total_qty: h.total_qty,
            dp_qty: h.dp_qty,
            t1_qty: h.t1_qty,
            available_qty: h.available_qty,
            collateral_qty: h.collateral_qty,
            avg_cost_price: h.avg_cost_price
          )
      end
    rescue DhanHQ::InternalServerError => e
      Rails.logger.error("Failed to sync holdings: #{e.message}")
      []
    end

    def sync_positions
      arr = DhanHQ::Models::Position.all

      Array(arr).each do |p|
        Position
          .find_or_initialize_by(exchange_segment: p.exchange_segment, security_id: p.security_id)
          .update!(
            dhan_client_id: p.dhan_client_id,
            trading_symbol: p.trading_symbol,
            position_type: p.position_type,
            product_type: p.product_type,
            buy_avg: p.buy_avg,
            buy_qty: p.buy_qty,
            cost_price: p.cost_price,
            sell_avg: p.sell_avg,
            sell_qty: p.sell_qty,
            net_qty: p.net_qty,
            realized_profit: p.realized_profit,
            unrealized_profit: p.unrealized_profit,
            rbi_reference_rate: p.rbi_reference_rate,
            multiplier: p.multiplier,
            carry_forward_buy_qty: p.carry_forward_buy_qty,
            carry_forward_sell_qty: p.carry_forward_sell_qty,
            carry_forward_buy_value: p.carry_forward_buy_value,
            carry_forward_sell_value: p.carry_forward_sell_value,
            day_buy_qty: p.day_buy_qty,
            day_sell_qty: p.day_sell_qty,
            day_buy_value: p.day_buy_value,
            day_sell_value: p.day_sell_value,
            drv_expiry_date: begin
              Date.parse(p.drv_expiry_date)
            rescue StandardError
              nil
            end,
            drv_option_type: p.drv_option_type,
            drv_strike_price: p.drv_strike_price,
            cross_currency: p.cross_currency
          )
      end
    end
  end
end

# File: app/services/price_math.rb
module PriceMath
  TICK = 0.05

  def self.round_tick(x)
    return nil if x.nil?

    ((x.to_f / TICK).round * TICK).round(2)
  end

  def self.floor_tick(x)
    ((x.to_f / TICK).floor * TICK).round(2)
  end

  def self.ceil_tick(x)
    ((x.to_f / TICK).ceil * TICK).round(2)
  end

  def self.valid_tick?(x)
    # Avoid float fuzziness: work in paise
    ((x.to_f * 100).round % (TICK * 100).to_i).zero?
  end
end

# File: app/services/regime/chop_detector.rb
# app/services/regime/chop_detector.rb
# Detects sideways/range conditions using lightweight signals from CandleSeries.
module Regime
  class ChopDetector
    # Any 2 true ‚áí choppy
    # cs5/cs15 are CandleSeries instances (5m/15m) you already have.
    def self.choppy_pre_entry?(cs5, cs15, opts = {})
      adx_th    = (opts[:adx_min] || 18).to_i
      atr_mult  = (opts[:atr_quiet_mult] || 0.8).to_f
      cross_win = (opts[:vwap_cross_window] || 30).to_i

      low_adx   = safe { cs5.adx(14) }&.<(adx_th) || false
      quiet_atr = begin
        atr_now  = safe { cs5.atr(5) } || 0.0
        atr_med  = safe { cs5.atr(5).median(50) } || atr_now
        atr_now.positive? && atr_med.positive? && (atr_now < atr_med * atr_mult)
      rescue StandardError
        false
      end
      vwap_x    = vwap_crossings(cs5, cross_win) >= 3
      nr5       = narrow_range?(cs5, 5)

      [low_adx, quiet_atr, vwap_x, nr5].count(true) >= 2
    end

    # ---- helpers ----

    def self.vwap_crossings(cs, window)
      vwap = safe { cs.vwap_series(window: window) } # preferred if you have it
      closes = safe { cs.close_series(window: window) }
      if vwap && closes && vwap.size == closes.size && vwap.size > 1
        signs = closes.zip(vwap).map { |c, v| (c <=> v) } # -1, 0, 1
        signs.each_cons(2).count { |a, b| (a <=> b) == -1 || (a <=> b) == 1 }
      else
        # Fallback: approximate with current vwap line if only one value
        0
      end
    rescue StandardError
      0
    end

    def self.narrow_range?(cs, n)
      # NR(n): current bar range <= min range of last n bars
      bars = safe { cs.last_n(n + 1) } || []
      return false unless bars.size >= 2

      rng = ->(b) { (b[:high] - b[:low]).to_f }
      cur = rng.call(bars.last)
      hist = bars[0...-1].map(&rng)
      cur <= hist.min
    rescue StandardError
      false
    end

    def self.safe(&)
      yield
    rescue StandardError
      nil
    end
  end
end

# File: app/services/risk/guard.rb
module Risk
  class Guard
    DEFAULT_MAX_TICK_AGE = 5 # seconds

    def trading_enabled?
      Setting.fetch_bool('trading_enabled', true)
    end

    def per_trade_risk_rupees
      Setting.fetch_i('risk.per_trade_rupees', 0)
    end

    def daily_loss_cap_rupees
      Setting.fetch_i('risk.daily_loss_cap_rupees', 0)
    end

    def max_trades_per_day
      Setting.fetch_i('risk.max_trades_per_day', 0)
    end

    # ---- Gates ----

    # Returns [allowed(Boolean), reason(String)]
    # expected_risk_rupees: how much you'd risk if this entry is placed (use per_trade_risk_rupees)
    # seg/sid: instrument identifiers for staleness check
    def entry_allowed?(expected_risk_rupees:, seg:, sid:, max_tick_age: DEFAULT_MAX_TICK_AGE)
      return [false, 'trading_disabled'] unless trading_enabled?

      return [false, 'ticks_stale'] if stale?(seg:, sid:, max_age: max_tick_age)

      return [false, 'max_trades_reached'] unless trade_budget_ok?

      return [false, 'daily_loss_cap'] unless daily_loss_ok?(expected_risk_rupees: expected_risk_rupees)

      [true, 'ok']
    end

    # Alias for simpler boolean interface
    # Returns true if entry is allowed, false otherwise
    def ok_to_enter?(expected_risk_rupees:, seg:, sid:, max_tick_age: DEFAULT_MAX_TICK_AGE)
      allowed, _reason = entry_allowed?(expected_risk_rupees: expected_risk_rupees, seg: seg, sid: sid, max_tick_age: max_tick_age)
      allowed
    end

    # Freshness of ticks
    def stale?(seg:, sid:, max_age: DEFAULT_MAX_TICK_AGE)
      tick = begin
        Live::TickCache.get(seg, sid)
      rescue StandardError
        nil
      end
      return true unless tick && tick[:ts].is_a?(Time)

      (Time.zone.now - tick[:ts]) > max_age
    end

    # New entry should not push realized losses beyond the cap
    # Rule: remaining_loss_budget >= expected_risk
    def daily_loss_ok?(expected_risk_rupees:)
      cap  = [daily_loss_cap_rupees, 0].max
      loss = realized_loss_today_abs
      remaining = cap - loss
      remaining >= expected_risk_rupees.to_i
    end

    def trade_budget_ok?
      # Count entries (orders) created today; adjust scope if you count positions instead
      taken = Order.where('created_at::date = ?', Date.current).count
      taken < max_trades_per_day
    end

    # ---- Helpers ----

    # Absolute value of today's realized loss (rupees); profits don't increase budget
    def realized_loss_today_abs
      pnl = Position.where(state: :closed)
                    .where('updated_at::date = ?', Date.current)
                    .sum(:realized_pnl).to_f
      pnl.negative? ? pnl.abs : 0.0
    end
  end
end


# File: app/services/risk/scalp_params.rb
# app/services/risk/scalp_params.rb
# Convenience wrapper for building scalp or momentum params.
class Risk::ScalpParams
  def self.for(entry_premium:, mode:)
    case mode
    when :scalp
      Risk::ToSuperParams.call(
        entry_premium: entry_premium,
        sl_pct: 0.25,  # keep risk constant
        tp_pct: 0.30,  # smaller, grab-able TP
        trail_pct: 0.18,
        trail_jump_pct: 0.10
      )
    else # :momentum (default)
      Risk::ToSuperParams.call(
        entry_premium: entry_premium,
        sl_pct: 0.25,
        tp_pct: 0.50,
        trail_pct: 0.20,
        trail_jump_pct: 0.10
      )
    end
  end
end


# File: app/services/risk/to_super_params.rb
# app/services/risk/to_super_params.rb
class Risk::ToSuperParams
  # sl/tp/trail/jump are ABSOLUTE premium values derived from entry premium
  def self.call(entry_premium:, sl_pct: 0.25, tp_pct: 0.50, trail_pct: 0.20, trail_jump_pct: 0.10)
    ep = entry_premium.to_f
    raise ArgumentError, 'entry_premium must be > 0' if ep <= 0

    sl   = [PriceMath.round_tick(ep * sl_pct),   0.05].max
    tp   = [PriceMath.round_tick(ep * tp_pct),   0.05].max
    tval = [PriceMath.round_tick(ep * trail_pct), 0.05].max
    tjmp = [PriceMath.round_tick(ep * trail_jump_pct), 0.05].max

    {
      sl_value: sl,
      tp_value: tp,
      trail_sl_value: tval,
      trail_sl_jump: tjmp
    }
  end
end


# File: app/services/runner/auto_pilot.rb
# frozen_string_literal: true

module Runner
  class AutoPilot < ApplicationService
    WINDOW = { start: '09:20', stop: '15:15' }.freeze

    MODE = Struct.new(:name, :tf, :adx_min, :profit_arm_pct, :time_stop_s, :scalp,
                      keyword_init: true)

    NORMAL = MODE.new(
      name: :normal, tf: '5', adx_min: 20, profit_arm_pct: 0.01, time_stop_s: 480, scalp: false
    )
    SCALP = MODE.new(
      name: :scalp, tf: '3', adx_min: 16, profit_arm_pct: 0.01, time_stop_s: 240, scalp: true
    )
    DEMO = MODE.new(
      name: :demo, tf: '1', adx_min: 0, profit_arm_pct: 0.0, time_stop_s: 0, scalp: false
    )

    def initialize(symbols: [], mode: :normal, roster: nil, demo: false)
      @symbols = Array(symbols).presence || %w[NIFTY BANKNIFTY SENSEX]
      @mode    = case mode.to_s
                 when 'scalp' then SCALP
                 when 'demo'  then DEMO
                 else NORMAL
                 end
      @demo = demo || (mode.to_s == 'demo')
      @roster  = roster || @symbols
      @running = Concurrent::AtomicBoolean.new(false)
      @last_entry_at = {}
    end

    def call
      start!
    end

    def start!
      return if @running.true?

      @running.make_true
      Live::WsHub.instance.start!(mode: :quote)
      subscribe_underlyings!

      # Kick off bars loop (fetch 5m/3m series) and trade loop
      @thread = Thread.new { main_loop }
      self
    end

    def stop!
      @running.make_false
      @thread&.kill
      self
    end

    private

    def main_loop
      loop do
        break unless @running.true?

        now = Time.zone.now
        run_once if inside_session?(now)
        sleep(@demo ? 15 : 30) # light cadence; bars fetch is heavier below
      end
    end

    def run_once
      if @demo
        # one-shot fetch per symbol ‚Üí process immediately
        @roster.each do |sym|
          if (inst = fetch_instrument(sym))
            raw = inst.intraday_ohlc(interval: tf_for(@mode.tf), days: 5)
            if raw.present?
              series = CandleSeries.new(symbol: inst.symbol_name, interval: tf_for(@mode.tf))
              series.load_from_raw(raw)
              process_symbol(sym, series)
            else
              notify_step(:fetch, "no OHLC for #{sym}")
            end
          else
            notify_step(:fetch, "instrument not found for #{sym}")
          end
        end
      else
        # original looping fetch
        Bars::FetchLoop.start(symbols: @roster, timeframe: tf_for(@mode.tf)) do |sym, series|
          process_symbol(sym, series)
        end
        sleep 12
        Bars::FetchLoop.stop
      end
    end

    def process_symbol(sym, series)
      notify_step(:gate_start, "‚Üí #{sym} (#{@mode.name}/tf=#{@mode.tf})")

      if Regime::ChopDetector.choppy_pre_entry?(series, series, adx_min: @mode.adx_min)
        notify_step(:gate_chop, "skip: choppy/adx<#{@mode.adx_min}")
        return
      else
        notify_step(:gate_chop, "ok (adx>=#{@mode.adx_min})")
      end

      trend = holy_or_supertrend(series)
      if %i[side neutral].include?(trend)
        notify_step(:gate_trend, 'skip: neutral/side')
        return
      else
        notify_step(:gate_trend, "ok: #{trend.upcase}")
      end

      inst = fetch_instrument(sym)
      unless inst
        notify_step(:instrument, "skip: not found #{sym}")
        return
      end

      side = (trend == :up ? :ce : :pe)
      notify_step(:picker, "choose side=#{side}")

      leg = Options::ChainAnalyzer.call(
        underlying: inst, side: side,
        config: { strategy_type: (@mode.scalp ? 'intraday' : 'margin') }
      )

      unless leg && leg[:ltp].to_f.positive?
        notify_step(:picker, 'skip: no leg/ltp<=0')
        return
      end
      notify_step(:picker, "picked strike=#{leg[:strike]} ltp=#{leg[:ltp]} lot=#{leg[:lot_size]}")

      qty = leg[:lot_size].to_i
      if qty <= 0
        notify_step(:qty, 'skip: qty<=0')
        return
      end
      notify_step(:qty, "qty=#{qty}")

      if entered_recently?(sym)
        notify_step(:cooldown, 'skip: recent entry cool‚Äëdown')
        return
      end
      notify_step(:cooldown, 'ok')

      sl, tp, trail = rr_for(inst, leg, series)
      notify_step(:risk_levels, "SL=#{sl} TP=#{tp} TRL=#{trail}")

      expected_risk = qty * leg[:ltp] * 0.10
      unless risk_ok?(inst, expected_risk_rupees: expected_risk)
        notify_step(:risk_guard, "skip: risk not ok (‚Çπ#{expected_risk.round(2)})")
        return
      end
      notify_step(:risk_guard, "ok (‚Çπ#{expected_risk.round(2)})")

      place_super(inst, side, qty, sl: sl, tp: tp, trail: trail)
      @last_entry_at[sym] = Time.current unless @demo
      notify_step(:placed, @demo ? "DEMO: would place BUY #{side.upcase}" : 'order placed')
    rescue StandardError => e
      Rails.logger.warn("[AutoPilot] #{sym} #{e.class}: #{e.message}")
      notify_failure(e, :process_symbol)
    end

    def rr_for(inst, leg, series)
      # ATR% ‚Üí map to SL/TP/trail like your AlertProcessors did
      atr = begin
        series.atr(20)
      rescue StandardError
        nil
      end
      atr_pct = if atr && (c = series.closes.last).to_f.positive?
                  atr.to_f / c
                end

      if atr_pct&.positive?
        sl_pct    = (atr_pct * 2.0).clamp(0.05, 0.18)
        tp_pct    = (atr_pct * 4.0).clamp(0.10, 0.40)
        trail_pct = atr_pct.clamp(0.03, 0.12)
      else
        sl_pct = 0.10
        tp_pct = 0.20
        trail_pct = 0.03 # defaults
      end

      price = leg[:ltp].to_f
      [
        (price * (1 - sl_pct)),
        (price * (1 + tp_pct)),
        (price * trail_pct)
      ].map { |x| PriceMath.round_tick(x) }
    end

    def place_super(inst, side, qty, sl:, tp:, trail:)
      client_ref = "AP-#{inst.security_id}-#{side}-#{Time.now.to_i}"
      params = Orders::SuperParamsBuilder.call(
        instrument: inst,
        side: :buy,
        qty: qty,
        entry_type: :market,
        sl_value: sl,
        tp_value: tp,
        trail_sl_value: (trail.positive? ? trail : nil),
        trail_sl_jump: (trail.positive? ? trail : nil),
        client_ref: client_ref
      )
      Rails.logger.info("[AutoPilot] Super params ‚Üí #{params}")
      notify_step(:super_params, params.inspect)

      # DEMO forces dry-run; otherwise keep existing PLACE_ORDER flag
      if @demo || !Setting.fetch_bool('PLACE_ORDER', false)
        notify("üí° DRYRUN SUPER PARAMS\n#{params.inspect}", tag: 'DRYRUN')
      else
        order = Orders::Executor.call(
          instrument: inst, side: :buy, qty: qty, entry_type: :market,
          risk_params: { sl_value: sl, tp_value: tp, trail_sl_value: trail, trail_sl_jump: trail },
          client_ref: client_ref
        )
        begin
          Live::WsHub.instance.subscribe(seg: order.instrument.exchange_segment, sid: order.instrument.security_id.to_s)
        rescue StandardError
          nil
        end
        register_for_management(order, inst.symbol_name, side: side)
      end
    end

    def register_for_management(order, underlying, side:)
      # Attach into PositionGuard
      intent = {
        security_id: order.instrument.security_id,
        exchange_segment: order.instrument.exchange_segment,
        entry_price: order.entry_price || 0.0,
        underlying_symbol: underlying
      }
      Execution::PositionGuard.register_intent(intent)
      # micro‚ÄëTP manager can be scheduled via a simple timer on each tick too (optional)
    end

    # ----- helpers -----
    def subscribe_underlyings!
      @symbols.each do |sym|
        inst = fetch_instrument(sym)
        Live::WsHub.instance.subscribe(seg: inst.exchange_segment, sid: inst.security_id.to_s) if inst
      end
    end

    def demo_mode?
      @demo
    end

    def holy_or_supertrend(series)
      cfg = demo_mode? ? Indicators::HolyGrail.demo_config : {}
      hg = Indicators::HolyGrail.call(candles: series.to_hash, config: cfg)

      notify_step(:demo_gate, "HolyGrail cfg=#{cfg.inspect}") if demo_mode?
      case hg&.bias
      when :bullish then :up
      when :bearish then :down
      else :side
      end
    rescue StandardError
      # fallback: simple supertrend compare
      st = Indicators::Supertrend.new(series: series).call
      return :side if st.empty?

      series.closes.last > st.last ? :up : :down
    end

    def to_dhan_hash(series)
      {
        'timestamp' => series.candles.map { |c| c.timestamp.to_i },
        'open' => series.opens,
        'high' => series.highs,
        'low' => series.lows,
        'close' => series.closes,
        'volume' => series.candles.map(&:volume)
      }
    end

    def fetch_instrument(sym)
      Instrument.segment_index.find_by(symbol_name: sym) || Instrument.segment_equity.find_by(display_name: sym)
    end

    def risk_ok?(inst, expected_risk_rupees:)
      Risk::Guard.new.ok_to_enter?(expected_risk_rupees: expected_risk_rupees.to_i,
                                   seg: inst.exchange_segment, sid: inst.security_id.to_s)
    end

    def entered_recently?(sym)
      return false if @demo

      t = @last_entry_at[sym]
      t && (Time.current - t) < 90 # cool‚Äëdown 90s per underlying
    end

    def inside_session?(now = Time.zone.now)
      return true if @demo

      t1 = Time.zone.parse(WINDOW[:start])
      t2 = Time.zone.parse(WINDOW[:stop])
      now.between?(t1, t2) && MarketCalendar.trading_day?(now.to_date)
    end

    def tf_for(tf)
      { '1' => '1', '3' => '3', '5' => '5', '15' => '15' }[tf.to_s] || '5'
    end

    def notify_step(action, message)
      Rails.logger.info("[AutoPilot] #{action} ‚Üí #{message}")
    end

    def numeric_value?(value)
      value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
    end
  end
end


# File: app/services/runner/positions_loop.rb
# app/services/runner/positions_loop.rb (inside loop, when you have p, ltp)
Positions::Manager.call(position: p)
Exits::MicroTP.call(
  order: p.order,
  ltp: ltp,
  entry_ts: p.created_at,
  side: (if p.order&.side&.to_sym == :buy
           p.option_call? ? :buy_ce : :buy_pe
         else
           :unknown
         end)
)

# app/services/runner/positions_loop.rb
module Runner
  class PositionsLoop
    INTERVAL = 0.5 # seconds
    TZ       = 'Asia/Kolkata'

    def initialize
      @risk    = Risk::Guard.new
      @running = false
    end

    def start
      return if @running

      @running = true
      @thread = Thread.new { run! }
      @thread
    end

    def stop
      @running = false
      @thread&.join(1)
    end

    private

    def run!
      Thread.current.name = begin
        'PositionsLoop'
      rescue StandardError
        nil
      end
      loop do
        break unless @running

        begin
          Position.open.includes(:order, :instrument).find_each do |p|
            manage_position(p)
          end
        rescue StandardError => e
          Rails.logger.error("[PositionsLoop] #{e.class} #{e.message}\n#{e.backtrace&.first(5)&.join("\n")}")
        ensure
          sleep INTERVAL
        end
      end
      Rails.logger.info('[PositionsLoop] stopped')
    end

    def manage_position(p)
      ins = p.instrument
      ltp = Live::TickCache.ltp(ins.exchange_segment, ins.security_id)
      return unless ltp

      # update unrealized P&L in rupees for options buying (premium delta * qty)
      entry = p.entry_price.to_f.nonzero? || p.order&.entry_price.to_f
      qty   = p.order&.qty.to_i
      if entry && entry > 0 && qty > 0
        p.unrealized_pnl = (ltp.to_f - entry) * qty
        p.save! if p.changed?
      end

      # trailer + micro TP / BE (tighten-only)
      Orders::SuperModifier.call(order: p.order) # no-op if nothing to change
      Exits::MicroTP.call(order: p.order, ltp: ltp, entry_ts: p.created_at, side: infer_side(p))

      # hard-flat if placing another loss would breach cap is not enough;
      # here we protect against live drawdown crossing the cap immediately:
      hard_flat_if_cap_breached!
    end

    def infer_side(p)
      # For long options we buy premium; if you store CE/PE, wire this properly.
      :buy_ce
    end

    def hard_flat_if_cap_breached!
      cap  = @risk.daily_loss_cap_rupees
      loss = @risk.realized_loss_today_abs
      # approximate unrealized loss across all open positions (only negative P&L counts)
      unreal = Position.open.sum('LEAST(unrealized_pnl, 0)').to_f.abs
      return unless (loss + unreal) >= cap && cap > 0

      Rails.logger.warn("[HARD-FLAT] Daily cap breached (#{loss + unreal} >= #{cap}) ‚Üí closing all + disabling trading")
      flatten_all!
      Setting.put('trading_enabled', 'false')
    end

    def flatten_all!
      Position.open.includes(:order).find_each do |p|
        Orders::Closer.call(order: p.order) if p.order&.super_ref.present?
      rescue StandardError => e
        Rails.logger.error("[HARD-FLAT] close failed pos=#{p.id} #{e.class} #{e.message}")
      end
    end
  end
end


# File: app/services/runner/recent_signals.rb
# app/services/runner/recent_signals.rb
module Runner
  class RecentSignals
    KEY = 'recent_signals'.freeze

    # store a short-lived fingerprint per underlying (e.g., 30s)
    def self.seen?(underlying_id:, fingerprint:, ttl: 30)
      key = "#{KEY}:#{underlying_id}:#{fingerprint}"
      already = Rails.cache.exist?(key)
      Rails.cache.write(key, true, expires_in: ttl)
      already
    end
  end
end


# File: app/services/sizing.rb
# app/services/sizing.rb
module Sizing
  # qty in contracts (lot-sized)
  def self.qty_for_rupees_risk(premium:, lot_size:, per_trade_rupees:, sl_pct: 0.25)
    return 0 if premium.to_f <= 0 || lot_size.to_i <= 0 || per_trade_rupees.to_i <= 0

    sl_points = PriceMath.round_tick(premium.to_f * sl_pct.to_f)
    per_lot_risk = sl_points * lot_size.to_i
    return 0 if per_lot_risk <= 0

    lots = (per_trade_rupees.to_i / per_lot_risk).floor
    [lots, 1].max * lot_size.to_i
  end
end


# File: app/services/telegram_notifier.rb
# frozen_string_literal: true

require 'net/http'
require 'uri'

class TelegramNotifier
  TELEGRAM_API = 'https://api.telegram.org'

  def self.send_message(text, chat_id: nil, **extra_params)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendMessage', chat_id:, text:, **extra_params)
  end

  def self.send_chat_action(action:, chat_id: nil)
    chat_id ||= ENV.fetch('TELEGRAM_CHAT_ID')
    post('sendChatAction', chat_id:, action:)
  end

  private_class_method def self.post(method, **params)
    uri = URI("#{TELEGRAM_API}/bot#{ENV.fetch('TELEGRAM_BOT_TOKEN')}/#{method}")
    res = Net::HTTP.post_form(uri, params)
    Rails.logger.error("Telegram #{method} failed: #{res.body}") unless res.is_a?(Net::HTTPSuccess)
    res
  rescue StandardError => e
    Rails.logger.error("Telegram #{method} error: #{e.message}")
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/import_instruments.rake
namespace :instruments do
  desc 'Import instruments from DhanHQ CSV'
  task import: :environment do
    pp 'Starting instruments import...'
    start_time = Time.current

    begin
      InstrumentsImporter.import_from_url

      duration = Time.current - start_time
      pp "\nImport completed successfully in #{duration.round(2)} seconds!"
      pp "Total Instruments: #{Instrument.count}"
      pp "Total Derivatives: #{Derivative.count}"

      # Show some stats
      pp "\n--- Stats ---"
      pp "NSE Instruments: #{Instrument.nse.count}"
      pp "BSE Instruments: #{Instrument.bse.count}"
      pp "NSE Derivatives: #{Derivative.nse.count}"
      pp "BSE Derivatives: #{Derivative.bse.count}"
      pp "Options: #{Derivative.options.count}"
      pp "Futures: #{Derivative.futures.count}"
      pp 'Instruments: Instrument.count'
      pp 'Derivatives: Derivative.count'
      pp "TOTAL: #{Instrument.count + Derivative.count}"
    rescue StandardError => e
      pp "Import failed: #{e.message}"
      pp e.backtrace.join("\n")
    end
  end

  desc 'Clear all instruments and derivatives'
  task clear: :environment do
    pp 'Clearing all instruments and derivatives...'
    Derivative.delete_all
    Instrument.delete_all
    pp 'Cleared successfully!'
  end

  desc 'Reimport (clear and import)'
  task reimport: %i[clear import]
end


# File: lib/tasks/trader.rake
# lib/tasks/trader.rake
namespace :trader do
  desc 'Start strategy and positions loops'
  task start: :environment do
    instruments = Instrument.where(symbol: %w[NIFTY BANKNIFTY SENSEX]) # adjust
    $strategy_loop  = Runner::StrategyLoop.new(instruments: instruments).start
    $positions_loop = Runner::PositionsLoop.new.start
    puts 'Loops started. Ctrl-C to stop (if foreground).'
    sleep
  end

  desc 'Stop loops (flip kill-switch)'
  task stop: :environment do
    Setting.put('trading_enabled', 'false')
    puts 'Kill-switch flipped off.'
  end
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

# Rails.application.config.middleware.insert_before 0, Rack::Cors do
#   allow do
#     origins "example.com"
#
#     resource "*",
#       headers: :any,
#       methods: [:get, :post, :put, :patch, :delete, :options, :head]
#   end
# end


# File: config/initializers/dhanhq.rb
require 'DhanHQ'

DhanHQ.configure_with_env
DhanHQ.logger.level = (ENV['DHAN_LOG_LEVEL'] || 'INFO').upcase.then { |l| Logger.const_get(l) }

# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += %i[
  passw email secret token _key crypt salt certificate otp ssn cvv cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/openai.rb
OpenAI.configure do |config|
  config.access_token = ENV.fetch('OPENAI_API_KEY', nil)
end

# File: config/initializers/ws_hub.rb
# frozen_string_literal: true

if ENV['ENABLE_WS'] == 'true'
  cfg = Rails.application.config_for(:dhan_ws)
  Rails.application.config.to_prepare do
    Live::WsHub.instance.start!(mode: (cfg['mode'] || 'quote').to_sym)
    Array(cfg['initial']).each do |h|
      Live::WsHub.instance.subscribe(seg: h[:segment], sid: h[:security_id])
    end
  end

  at_exit do
    Live::WsHub.instance.stop!
  rescue StandardError
    nil
  end
end


